<?xml version="1.0" encoding="utf-8"?>
<search> 
  
    
    <entry>
      <title>2019하반기 스터디 주제 공유</title>
      <link href="/2019/07/03/2019%ED%95%98%EB%B0%98%EA%B8%B0-%EC%8A%A4%ED%84%B0%EB%94%94-%EC%A3%BC%EC%A0%9C-%EA%B3%B5%EC%9C%A0/"/>
      <url>/2019/07/03/2019%ED%95%98%EB%B0%98%EA%B8%B0-%EC%8A%A4%ED%84%B0%EB%94%94-%EC%A3%BC%EC%A0%9C-%EA%B3%B5%EC%9C%A0/</url>
      
        <content type="html"><![CDATA[<h1 id="2019-하반기-스터디-주제는-생산성-입니다"><a href="#2019-하반기-스터디-주제는-생산성-입니다" class="headerlink" title="2019 하반기 스터디 주제는 생산성 입니다"></a>2019 하반기 스터디 주제는 생산성 입니다</h1><p><img src="https://spectator.imgix.net/content/uploads/2017/12/iStock-827158860.jpg?auto=compress,enhance,format&amp;crop=faces,entropy,edges&amp;fit=crop&amp;w=820&amp;h=550" alt="생산성"></p><p>소프트웨어 개발에 있어 다양한 생산성을 관점으로 주제를 선정해주세요</p><ul><li>devops</li><li>배포 자동화</li><li>작업 시간을 줄일수 있는 다양한 라이브러리나 프레임워크</li><li>이외에 다양하게 개발 업무시간을 단축 시켜주는 기술, 방법론, 툴 소개</li></ul><h3 id="스터디-일정"><a href="#스터디-일정" class="headerlink" title="스터디 일정"></a>스터디 일정</h3><ul><li>내부 스터디 11월 완료</li><li><p>공개세미나 2020년 1월 or 2월</p><h3 id="스터디-방법"><a href="#스터디-방법" class="headerlink" title="스터디 방법"></a>스터디 방법</h3><ol><li>주제 선정<ul><li>스터디할 주제를 선정합니다</li></ul></li><li>목표 설정<ul><li>선정한 주제를 가지고 어떤것을 공부할것인지, 얼마만큼 공부할것인지를 결정</li></ul></li><li>스터디 방법 설정<ul><li>어떠한 방식으로 진행할것인지(회사에서 실제 사용하면서 정리, 유튜브, 책, 사이트 등의 스터디 방식을 공유)</li></ul></li><li>컨펌후 진행<ul><li>진행자에게 컨펌후 스터디 시작</li></ul></li></ol></li></ul><h3 id="스터디-조인방법"><a href="#스터디-조인방법" class="headerlink" title="스터디 조인방법"></a>스터디 조인방법</h3><p><a href="mailto:devload@naver.com" target="_blank" rel="noopener">devload@naver.com</a>에 다음과 같은 정보를 공유해주시면 아해팀이 커뮤니케이션하는 슬랙에 초대해드리겠습니다</p><ul><li>이름</li><li>회사명</li><li>연차(대충 주시면 돼요)</li><li>스터디 동기(이거도 대충 주시면 돼요)</li><li>스터디 주제(생각하시는 주제를 대충 주시면 돼요)</li><li>가입 경로(sns, 공개세미나, 지인추천, 기타)</li><li><p>연락처</p><h3 id="아해스터디"><a href="#아해스터디" class="headerlink" title="아해스터디"></a>아해스터디</h3><p>아해 스터디는 개인이 주제를 선정 -&gt; 스터디 진행 -&gt; 내부세미나 -&gt; 공개세미나 순으로 진행이 됩니다</p><p>대부분의 커뮤니케이션은 원격으로 진행되며 스터디를 진행하시면서 정보공유, 네트워크를 아해맴버들과 함께 하면서 진행합니다</p><p>내부적인 세미나 진행후 다양한 개발자를 모시고 컨퍼런스 형식으로 공개세미나를 진행합니다</p><p>기타 궁금하신 사항은 메일(<a href="mailto:devload@naver.com" target="_blank" rel="noopener">devload@naver.com</a>) 또는 아해 페이스북(<a href="http://www.facebook.com/AheaCommunity" target="_blank" rel="noopener">http://www.facebook.com/AheaCommunity</a>) 메세지를 통해 문의해주시면 상세히 답변드리겠습니다</p></li></ul>]]></content>
      
      
      <categories>
          
          <category> 공지 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 공지 </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>Selenium VS Puppeteer VS HTTP Client</title>
      <link href="/2019/05/01/Selenium-VS-Puppeteer-VS-HTTP-Client/"/>
      <url>/2019/05/01/Selenium-VS-Puppeteer-VS-HTTP-Client/</url>
      
        <content type="html"><![CDATA[<p>Selenium VS Puppeteer VS HTTP Client 대해 알아볼 예정 입니다.<br>각각의 특징은 무엇인지 알아 보겠습니다.</p><h3 id="Selenium"><a href="#Selenium" class="headerlink" title="Selenium"></a>Selenium</h3><p><img src="https://user-images.githubusercontent.com/6037055/57007275-527b2200-6c22-11e9-9ec6-3938285bbc67.png" alt="Selenium HomePage"></p><p>Selenium이란 <code>Web Browser 자동화</code>를 위해 태어 났으며, 보통 <code>Cross Browser Test</code>와 <code>UI Test</code>에 활용 합니다.</p><p>Selenium 에서 오픈 중인 프로젝트는</p><ul><li>Selenium-WebDriver : 로컬 또는 원격 시스템에서 브라우저를 기본적으로 구동 할 수 있습니다.</li><li>Selenium-Grid : 여러 서버에서 동시에 여러 테스트를 실행하여 여러 브라우저 나 운영 체제를 테스트하는 데 걸리는 시간을 줄여 Selenium Remote Control을 다른 수준으로 끌어 올립니다.</li><li>Selenium IDE : 브라우저에서 테스트를 기록하고 재생할 수있게 해주는 Chrome 및 Firefox 확장 기능입니다.</li><li>Selenium Remote Control : 거의 모든 프로그래밍 언어와 테스트 프레임 워크를 사용하여 웹 브라우저를 로컬 또는 다른 컴퓨터에서 제어 할 수있는 클라이언트 / 서버 시스템입니다.<br><img src="https://seleniumhq.github.io/docs/images/test_framework.png" alt="Selenium Ecosystem 활용"></li></ul><p>이 존재 하며, 자세한건 사이트에서 직접 참조 바람<br><a href="https://www.seleniumhq.org/projects/" target="_blank" rel="noopener">https://www.seleniumhq.org/projects/</a></p><p>Cross Browser Test와 UI Test에 주로 이용되는 프로젝트는 <code>Selenium-WebDriver</code>이며, 이는 <a href="https://w3c.github.io/webdriver/" target="_blank" rel="noopener">W3스펙에 의한 WebDriver</a> 구현체를 쉽게 사용하게 추상화하여 여러 WebDriver를 지원하고 프로그래밍이 가능한 Web Browser를 제공 함</p><p>Selenium-Webdriver는 다양한 언어를 지원하기 위해 라이브러리를 제공 합니다.</p><ul><li>Java</li><li>C#</li><li>Javascript(Node.js)</li><li>Python</li></ul><p>Spring 진영에서는 End-To-End Test 지원을 위한 Spring MVC Test중 Selenium을 사용 할 수 있습니다.<br><a href="https://docs.spring.io/spring-test-htmlunit/docs/current/reference/html5/" target="_blank" rel="noopener">https://docs.spring.io/spring-test-htmlunit/docs/current/reference/html5/</a></p><pre class=" language-java"><code class="language-java"># Spring MVC Test 코드<span class="token punctuation">(</span>HtmlUnit을 활용<span class="token punctuation">)</span><span class="token function">assertThat</span><span class="token punctuation">(</span>newMessagePage<span class="token punctuation">.</span><span class="token function">getUrl</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">toString</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">endsWith</span><span class="token punctuation">(</span><span class="token string">"/messages/123"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>String id <span class="token operator">=</span> newMessagePage<span class="token punctuation">.</span><span class="token function">getHtmlElementById</span><span class="token punctuation">(</span><span class="token string">"id"</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">getTextContent</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token function">assertThat</span><span class="token punctuation">(</span>id<span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">isEqualTo</span><span class="token punctuation">(</span><span class="token string">"123"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>String summary <span class="token operator">=</span> newMessagePage<span class="token punctuation">.</span><span class="token function">getHtmlElementById</span><span class="token punctuation">(</span><span class="token string">"summary"</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">getTextContent</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token function">assertThat</span><span class="token punctuation">(</span>summary<span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">isEqualTo</span><span class="token punctuation">(</span><span class="token string">"Spring Rocks"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>String text <span class="token operator">=</span> newMessagePage<span class="token punctuation">.</span><span class="token function">getHtmlElementById</span><span class="token punctuation">(</span><span class="token string">"text"</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">getTextContent</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token function">assertThat</span><span class="token punctuation">(</span>text<span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">isEqualTo</span><span class="token punctuation">(</span><span class="token string">"In case you didn't know, Spring Rocks!"</span><span class="token punctuation">)</span><span class="token punctuation">;</span></code></pre><h4 id="지원하는-드라이버들-2019-04-28-기준"><a href="#지원하는-드라이버들-2019-04-28-기준" class="headerlink" title="지원하는 드라이버들 (2019.04.28 기준)"></a>지원하는 드라이버들 (2019.04.28 기준)</h4><table><thead><tr><th>Browser</th><th>Maintainer</th><th>Versions Supported</th></tr></thead><tbody><tr><td>Chromium</td><td><a href="https://sites.google.com/a/chromium.org/chromedriver/" target="_blank" rel="noopener">Chromium</a></td><td>All versions</td></tr><tr><td>Firefox</td><td><a href="https://github.com/mozilla/geckodriver" target="_blank" rel="noopener">Mozilla</a></td><td>54 and newer</td></tr><tr><td>Internet Explorer</td><td>Selenium</td><td>6 and newer</td></tr><tr><td>Opera</td><td>Opera <a href="https://github.com/operasoftware/operachromiumdriver" target="_blank" rel="noopener">Chromium</a> / <a href="https://github.com/operasoftware/operaprestodriver" target="_blank" rel="noopener">Presto</a></td><td>10.5 and newer</td></tr><tr><td>Safari</td><td><a href="https://webkit.org/blog/6900/webdriver-support-in-safari-10/" target="_blank" rel="noopener">Apple</a></td><td>10 and newer</td></tr></tbody></table><p>selenium-webdriver를 공부하기 위한 예제<br><code>크롬</code>과 <code>파이어폭스</code> 2가지 <code>webdriver를 받아 구글 검색 예제</code>를 작성<br>자세한 내용은 아래의 링크를 참조 바람.<br><a href="https://seleniumhq.github.io/selenium/docs/api/javascript/index.html" target="_blank" rel="noopener">https://seleniumhq.github.io/selenium/docs/api/javascript/index.html</a></p><h3 id="Puppeteer"><a href="#Puppeteer" class="headerlink" title="Puppeteer"></a>Puppeteer</h3><p><img src="https://user-images.githubusercontent.com/10379601/29446482-04f7036a-841f-11e7-9872-91d1fc2ea683.png" alt="Puppeteer"></p><p>Puppeteer는 Headless Chrome Node.js API입니다. Puppeteer는 Chrome과 통신하기 위해 <code>Chrome DevTools Protocol</code>를 사용 하며, Chrome Devtools의 모든 기능을 Node.js에서 사용 가능하게 해줍니다. 개인적으로 API 호출 하나하나가 Browser를 사용하듯이 직관적이라고 느꼇습니다.<br><a href="https://pptr.dev" target="_blank" rel="noopener">Puppeteer API DOC</a><br><a href="https://chromedevtools.github.io/devtools-protocol/" target="_blank" rel="noopener">Chrome DevTools Protocol Viewer</a><br><a href="https://github.com/transitive-bullshit/awesome-puppeteer" target="_blank" rel="noopener">Awesome Puppeteer(활용 예제 모음)</a></p><p>Puppeteer 특징은 다음과 같습니다.</p><ul><li>페이지의 스크린 샷과 PDF를 생성</li><li>SPA (Single Page Application)를 크롤링하고 사전 렌더링 된 내용 (즉, “SSR”(Server-Side Rendering))을 생성</li><li>Form 테스트, UI 테스트, 키보드 입력 등 자동화</li><li>최신 JavaScript 및 브라우저 기능을 사용하여 테스트</li><li>사이트 의 타임 라인 추적 을 캡처하여 성능 문제를 진단</li><li>Chrome 확장 프로그램을 테스트</li></ul><h4 id="Chrome-DevTools-Protocol"><a href="#Chrome-DevTools-Protocol" class="headerlink" title="Chrome DevTools Protocol"></a>Chrome DevTools Protocol</h4><p>DevTools Protocol는 Chrome을 직접 사용 할 수있는 프로토콜이며 다양한 언어의 라이브러리가 존재 하지만, Puppeteer처럼 구글에서 관리되는 프로젝트가 아닙니다.<br>다른 언어의 라이브러리는 <a href="https://github.com/ChromeDevTools/awesome-chrome-devtools" target="_blank" rel="noopener">Awesome chrome-devtools</a> 참조 하세요</p><h3 id="HTTP-Client"><a href="#HTTP-Client" class="headerlink" title="HTTP Client"></a>HTTP Client</h3><p>리눅스에서 사용하는 curl, wget등이 있으며 각각 지원언어에 따른 HTTP Client들이 존재 합니다.<br>HTTP를 사용하기에 가장 간단한 방법이며 Web의 정보를 쉽게 취득 할 수 있습니다.</p><pre class=" language-bash"><code class="language-bash"><span class="token comment" spellcheck="true"># 구글 뉴스 스크래핑</span>curl https://news.google.com/?tab<span class="token operator">=</span>wn<span class="token operator">&amp;</span>hl<span class="token operator">=</span>ko<span class="token operator">&amp;</span>gl<span class="token operator">=</span>KR<span class="token operator">&amp;</span>ceid<span class="token operator">=</span>KR:ko <span class="token operator">></span> google_news.html</code></pre><h2 id="비교"><a href="#비교" class="headerlink" title="비교"></a>비교</h2><table><thead><tr><th>종류</th><th>속도</th><th>Community</th><th>API DOC(주관적임)</th><th>지원 언어</th><th>Javascript 실행</th></tr></thead><tbody><tr><td> Selenium-Webdriver</td><td>보통</td><td>활발</td><td>보통</td><td>Java, C#. Python, Javascript(Node.js)</td><td>O </td></tr><tr><td> Puppeteer</td><td>빠름</td><td>적음</td><td>좋음</td><td>Javascript(Node.js)</td><td>O</td></tr><tr><td> HTTP Client</td><td>매우빠름</td><td>활발</td><td>?</td><td>다양</td><td>X</td></tr></tbody></table><h3 id="속도"><a href="#속도" class="headerlink" title="속도"></a>속도</h3><h4 id="HTTP-Client-1"><a href="#HTTP-Client-1" class="headerlink" title="HTTP Client"></a>HTTP Client</h4><pre class=" language-javascript"><code class="language-javascript"><span class="token keyword">const</span> https <span class="token operator">=</span> <span class="token function">require</span><span class="token punctuation">(</span><span class="token string">'https'</span><span class="token punctuation">)</span><span class="token punctuation">;</span>https<span class="token punctuation">.</span><span class="token keyword">get</span><span class="token punctuation">(</span><span class="token string">'https://news.google.com/?tab=wn&amp;hl=ko&amp;gl=KR&amp;ceid=KR:ko'</span><span class="token punctuation">,</span> res <span class="token operator">=</span><span class="token operator">></span> <span class="token punctuation">{</span>    res<span class="token punctuation">.</span><span class="token function">setEncoding</span><span class="token punctuation">(</span><span class="token string">'utf8'</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token punctuation">}</span><span class="token punctuation">)</span></code></pre><p> <img src="https://user-images.githubusercontent.com/6037055/57009725-6e3af400-6c33-11e9-9dd7-ab6bd88d8a34.png" alt="Node.js HTTP Client"></p><h4 id="Selenium-1"><a href="#Selenium-1" class="headerlink" title="Selenium"></a>Selenium</h4><pre class=" language-javascript"><code class="language-javascript"><span class="token function">require</span><span class="token punctuation">(</span><span class="token string">'chromedriver'</span><span class="token punctuation">)</span><span class="token keyword">const</span> <span class="token punctuation">{</span>Builder<span class="token punctuation">,</span> By<span class="token punctuation">,</span> Key<span class="token punctuation">,</span> until<span class="token punctuation">}</span> <span class="token operator">=</span> <span class="token function">require</span><span class="token punctuation">(</span><span class="token string">'selenium-webdriver'</span><span class="token punctuation">)</span><span class="token punctuation">(</span><span class="token keyword">async</span> <span class="token punctuation">(</span>browserName<span class="token punctuation">)</span> <span class="token operator">=</span><span class="token operator">></span> <span class="token punctuation">{</span>    <span class="token keyword">let</span> driver <span class="token operator">=</span> <span class="token keyword">await</span> <span class="token keyword">new</span> <span class="token class-name">Builder</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">forBrowser</span><span class="token punctuation">(</span><span class="token string">'chrome'</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">build</span><span class="token punctuation">(</span><span class="token punctuation">)</span>    <span class="token keyword">try</span> <span class="token punctuation">{</span>        <span class="token keyword">await</span> driver<span class="token punctuation">.</span><span class="token keyword">get</span><span class="token punctuation">(</span><span class="token string">'https://news.google.com/?tab=wn&amp;hl=ko&amp;gl=KR&amp;ceid=KR:ko'</span><span class="token punctuation">)</span>    <span class="token punctuation">}</span> <span class="token keyword">catch</span> <span class="token punctuation">(</span><span class="token class-name">e</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>        console<span class="token punctuation">.</span><span class="token function">error</span><span class="token punctuation">(</span>e<span class="token punctuation">)</span>    <span class="token punctuation">}</span> <span class="token keyword">finally</span> <span class="token punctuation">{</span>        <span class="token keyword">await</span> driver<span class="token punctuation">.</span><span class="token function">quit</span><span class="token punctuation">(</span><span class="token punctuation">)</span>    <span class="token punctuation">}</span><span class="token punctuation">}</span><span class="token punctuation">)</span><span class="token punctuation">(</span><span class="token punctuation">)</span></code></pre><p><img src="https://user-images.githubusercontent.com/6037055/57700429-f0e09c00-7694-11e9-8795-b4ad84cf6939.png" alt="Node.js Selenium-WebDriver"></p><h4 id="Puppeteer-1"><a href="#Puppeteer-1" class="headerlink" title="Puppeteer"></a>Puppeteer</h4><pre class=" language-javascript"><code class="language-javascript"><span class="token keyword">const</span> puppeteer <span class="token operator">=</span> <span class="token function">require</span><span class="token punctuation">(</span><span class="token string">'puppeteer'</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token punctuation">(</span><span class="token keyword">async</span> <span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">=</span><span class="token operator">></span> <span class="token punctuation">{</span>    <span class="token keyword">const</span> browser <span class="token operator">=</span> <span class="token keyword">await</span> puppeteer<span class="token punctuation">.</span><span class="token function">launch</span><span class="token punctuation">(</span><span class="token punctuation">{</span>headless<span class="token punctuation">:</span> <span class="token boolean">true</span><span class="token punctuation">}</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token keyword">const</span> page <span class="token operator">=</span> <span class="token keyword">await</span> browser<span class="token punctuation">.</span><span class="token function">newPage</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token keyword">await</span> page<span class="token punctuation">.</span><span class="token function">goto</span><span class="token punctuation">(</span><span class="token string">'https://news.google.com/?tab=wn&amp;hl=ko&amp;gl=KR&amp;ceid=KR:ko'</span><span class="token punctuation">)</span>    <span class="token keyword">await</span> browser<span class="token punctuation">.</span><span class="token function">close</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token punctuation">}</span><span class="token punctuation">)</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span></code></pre><p> <img src="https://user-images.githubusercontent.com/6037055/57009934-b73f7800-6c34-11e9-8d7b-5a2368b48bc8.png" alt="Node.js Puppeteer(No Headless)"><br> <img src="https://user-images.githubusercontent.com/6037055/57009979-fbcb1380-6c34-11e9-9cb3-73c450e66cbd.png" alt="Node.js Puppeteer(Headless)"></p><h4 id="시간-정리"><a href="#시간-정리" class="headerlink" title="시간 정리"></a>시간 정리</h4><ol><li>HTTP Client <code>0.11초</code></li><li>Puppeteer(Headless) <code>0.66초</code></li><li><p>Selenium, Puppeteer(No Headless) <code>1.56초</code> </p><h2 id="정리"><a href="#정리" class="headerlink" title="정리"></a>정리</h2><blockquote><ul><li>단순 HTML Content만 Scraping 할 경우 HTTP Client 추천</li><li>크로스 브라우저 UI 테스트가 필요할 경우 와 다양한 지원을 원하면 Selenium 추천</li><li>로그인과 Javascript 구동, SPA의 스크래핑이 필요하고 Chrome의 DevTools 기능을 사용 하고 싶을 경우 Puppeteer(DevTools Protocol) 추천</li></ul></blockquote></li></ol><p>P.S<br><a href="https://github.com/transitive-bullshit/awesome-puppeteer" target="_blank" rel="noopener">Puppeteer 프로젝트들(Awesome Puppeteer)</a>을 살펴 보는 와중에 눈에 띄는 재미있는 프로젝트를 2개 발견 하였습니다.</p><ul><li><a href="https://github.com/thomasdondorf/puppeteer-cluster" target="_blank" rel="noopener">puppeteer-cluster</a> - Worker를 생성해 CPU자원을 최대한 사용가능(모니터링 지원)</li><li><a href="https://github.com/checkly/puppeteer-recorder" target="_blank" rel="noopener">puppeteer-recorder</a> - 크롬 확장프로그램으로 녹화 기능을 통해 Puppeteer Node.js Script를 생성</li></ul><blockquote><p>StackOverflow<br>Webdriver VS Devtools에 대해서 비교 해놓음<br><a href="https://stackoverflow.com/questions/50939116/what-is-the-difference-between-webdriver-and-devtool-protocol" target="_blank" rel="noopener">https://stackoverflow.com/questions/50939116/what-is-the-difference-between-webdriver-and-devtool-protocol</a></p></blockquote>]]></content>
      
      
      <categories>
          
          <category> WEB </category>
          
      </categories>
      
      
        <tags>
            
            <tag> HeadlessBrowser </tag>
            
            <tag> Chrome </tag>
            
            <tag> headless </tag>
            
            <tag> javascript </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>WebDriver VS DevTools Protocol</title>
      <link href="/2019/05/01/WebDriver-VS-DevTools-Protocol/"/>
      <url>/2019/05/01/WebDriver-VS-DevTools-Protocol/</url>
      
        <content type="html"><![CDATA[<h2 id="WebDriver"><a href="#WebDriver" class="headerlink" title="WebDriver"></a>WebDriver</h2><p><img src="https://user-images.githubusercontent.com/6037055/57774314-29e04580-7755-11e9-8b1b-8f7be681c8ec.png" alt="WebDriver Flow"><br><code>Web Browser 자동화</code>를 위해 태어 났으며, 보통 <code>Cross Browser Test</code>와 <code>UI Test</code>에 활용 합니다. WebDriver는 <a href="https://w3c.github.io/webdriver/" target="_blank" rel="noopener">W3에서 정의한 WebDriver 스펙</a>에 맞춰 각 브라우저 마다 구현된 WebDriver가 있으며 Selenium WebDriver를 통해 통합적으로 다룰 수 있습니다. 아래에는 각 브라우저별 지원 드라이버 입니다.</p><h3 id="지원하는-드라이버들-2019-04-28-기준"><a href="#지원하는-드라이버들-2019-04-28-기준" class="headerlink" title="지원하는 드라이버들 (2019.04.28 기준)"></a>지원하는 드라이버들 (2019.04.28 기준)</h3><table><thead><tr><th>Browser</th><th>Maintainer</th><th>Versions Supported</th></tr></thead><tbody><tr><td>Chromium</td><td><a href="https://sites.google.com/a/chromium.org/chromedriver/" target="_blank" rel="noopener">Chromium</a></td><td>All versions</td></tr><tr><td>Firefox</td><td><a href="https://github.com/mozilla/geckodriver" target="_blank" rel="noopener">Mozilla</a></td><td>54 and newer</td></tr><tr><td>Internet Explorer</td><td>Selenium</td><td>6 and newer</td></tr><tr><td>Opera</td><td>Opera <a href="https://github.com/operasoftware/operachromiumdriver" target="_blank" rel="noopener">Chromium</a> / <a href="https://github.com/operasoftware/operaprestodriver" target="_blank" rel="noopener">Presto</a></td><td>10.5 and newer</td></tr><tr><td>Safari</td><td><a href="https://webkit.org/blog/6900/webdriver-support-in-safari-10/" target="_blank" rel="noopener">Apple</a></td><td>10 and newer</td></tr></tbody></table><h2 id="DevTools-Protocol-Debugging-Protocol"><a href="#DevTools-Protocol-Debugging-Protocol" class="headerlink" title="DevTools Protocol(Debugging Protocol)"></a>DevTools Protocol(Debugging Protocol)</h2><p><img src="https://46c4ts1tskv22sdav81j9c69-wpengine.netdna-ssl.com/wp-content/uploads/mswbprod/sites/33/2018/05/b46a7b838118991ffd34a9092310ccf0-1024x501.png" alt="Edge DevTools Protocol"><br>Web의 발전함에 따라 Web 개발 기술도 점점 고도화 되어가고 있습니다. 이를 원활히 지원하기 위해 각 브라우저에서는 전문적으로 디버깅을 할 수 있는 <code>DevTools Protocol</code>을 지원 합니다.<br><img src="https://user-images.githubusercontent.com/6037055/57776332-24d1c500-775a-11e9-9437-54a537e0961a.png" alt="Chrome DevTools 지원 기능"><br><code>DevTools Protocol</code>는 Web Application을 진단할 수 있도록 Elements, Network, Perfomance, TimeLime, Trace등 다양한 기능을 지원하고 있습니다.</p><h3 id="지원중인브라우저"><a href="#지원중인브라우저" class="headerlink" title="지원중인브라우저"></a>지원중인브라우저</h3><p><img src="https://user-images.githubusercontent.com/6037055/57775898-159e4780-7759-11e9-992a-652672b50d97.png" alt="DevTools Protocol API 지원 현황"><br><a href="http://compatibility.remotedebug.org/" target="_blank" rel="noopener">브라우저별 지원 API</a>를 통해 사용 가능한 API를 확인 하실 수 있습니다.<br>아래는 DevTools Protocol 지원 브라우저 입니다.</p><ul><li><a href="https://chromedevtools.github.io/devtools-protocol/" target="_blank" rel="noopener">Chrome DevTools</a></li><li><a href="https://github.com/WebKit/webkit/tree/master/Source/JavaScriptCore/inspector/protocol" target="_blank" rel="noopener">WebKit / Safari</a></li><li><a href="https://chromedevtools.github.io/devtools-protocol/v8/" target="_blank" rel="noopener">Node.js</a></li><li>Firefox - <a href="https://groups.google.com/forum/#!msg/mozilla.dev.platform/4-4A8W-nP5g/Y9C9UkWTAAAJ" target="_blank" rel="noopener">in development</a></li><li><a href="https://docs.microsoft.com/en-us/microsoft-edge/devtools-protocol/" target="_blank" rel="noopener">Edge DevTools Protocol</a></li></ul><h2 id="출처"><a href="#출처" class="headerlink" title="출처"></a>출처</h2><ul><li><a href="https://blogs.windows.com/msedgedev/2018/05/11/introducing-edge-devtools-protocol/" target="_blank" rel="noopener">https://blogs.windows.com/msedgedev/2018/05/11/introducing-edge-devtools-protocol/</a></li><li><a href="https://seleniumhq.github.io/docs/wd.html" target="_blank" rel="noopener">https://seleniumhq.github.io/docs/wd.html</a></li><li><a href="https://stackoverflow.com/questions/50939116/what-is-the-difference-between-webdriver-and-devtool-protocol" target="_blank" rel="noopener">https://stackoverflow.com/questions/50939116/what-is-the-difference-between-webdriver-and-devtool-protocol</a></li><li><a href="https://github.com/WICG/devtools-protocol" target="_blank" rel="noopener">https://github.com/WICG/devtools-protocol</a></li></ul>]]></content>
      
      
      <categories>
          
          <category> WEB </category>
          
      </categories>
      
      
        <tags>
            
            <tag> HeadlessBrowser </tag>
            
            <tag> Chrome </tag>
            
            <tag> headless </tag>
            
            <tag> javascript </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>rabbitmq exchange 라우팅 패턴</title>
      <link href="/2019/04/30/rabbitmq-exchange-%EB%9D%BC%EC%9A%B0%ED%8C%85-%ED%8C%A8%ED%84%B4/"/>
      <url>/2019/04/30/rabbitmq-exchange-%EB%9D%BC%EC%9A%B0%ED%8C%85-%ED%8C%A8%ED%84%B4/</url>
      
        <content type="html"><![CDATA[<h3 id="Exchange-라우팅-패턴"><a href="#Exchange-라우팅-패턴" class="headerlink" title="Exchange 라우팅 패턴"></a>Exchange 라우팅 패턴</h3><ul><li><p>RabbitMQ 최대 강점은 애플리케이션이 제공한 라우팅 정보를 기반으로 서로 다른 큐로 유연하게 라우팅 가능</p></li><li><p>RabbitMQ의 4가지 기본 유형의 익스체인지와 유형을 알아본다.</p></li><li><p>Direct Exchange</p></li><li><p>Fanout Exchange</p></li><li><p>Topic Exchange</p></li><li><p>Headers Exchange</p></li></ul><h3 id="Direct-Exchange"><a href="#Direct-Exchange" class="headerlink" title="Direct Exchange"></a>Direct Exchange</h3><ul><li>다이렉트 익스체인지는 라우팅 키를 기반으로 메시지를 큐에 전달한다.</li><li>특정 큐에 메시지를 하나씩 전달한다.</li><li>RabbitMq에 기본으로 내장돼 있어서 추가 플러그인이 필요하지 않다.(매우 단순함)</li></ul><p>direct exchange 는 unicast routing 방식에 적합하다.. 여기서 unicast routing 이란….</p><blockquote><p>고유 주소로 식별된 하나의 네트워크 목적지에 메시지를 전송하는 방식<br>참고 : <a href="https://ko.wikipedia.org/wiki/%EC%9C%A0%EB%8B%88%EC%BA%90%EC%8A%A4%ED%8A%B8" target="_blank" rel="noopener">https://ko.wikipedia.org/wiki/%EC%9C%A0%EB%8B%88%EC%BA%90%EC%8A%A4%ED%8A%B8</a></p></blockquote><ol><li>큐와 익스체인지가 routing key K를 이용해서 바인딩됨.</li><li>이때 새로운 메시지와 routing key R 이 도착하면 exchange는 K = R일 경우 큐로 라우팅 한다.</li></ol><p>Direct exchanges는 다양한 소비자에게 일을 분배 하기 위해 사용된다.<br><strong>중요!!! AMQP 0-9-1, 메시지가 queue가 아닌 cunsumer들 사이에서 로드 밸런싱 된다는 것.</strong></p><p><img src="/images\amqp\3-1.png" alt=""></p><h3 id="Fanout-Exchange"><a href="#Fanout-Exchange" class="headerlink" title="Fanout Exchange"></a>Fanout Exchange</h3><ul><li>다이렉트 익스체인지와 달리 전체 큐를 대상으로 처리한다.</li><li>Fanout Exchange로 발행된 메시지는 Fanout Exchange에 연결된 모든 큐에 전달된다.</li><li>라우팅 키를 평가할 필요가 없기 때문에 상당한 성능적인 이점이 있다.</li></ul><blockquote><p>스포츠 뉴스 사이트에서 모바일 클라이언트에게 실시간 점수를 업데이트할 수 있다.<br>글로벌 이벤트에 활용될 수 있다.</p></blockquote><p><img src="/images\amqp\3-2.png" alt=""></p><h3 id="Topic-Exchange"><a href="#Topic-Exchange" class="headerlink" title="Topic Exchange"></a>Topic Exchange</h3><ul><li>Topic Exchange는 하나 이상의 큐에게 Routing key 패턴 기반으로 Queue에 binding 한다</li><li>publish/subscribe pattern에 사용되거나 다양한 범위에서 사용된다.</li><li>주로 multicast routing에 사용된다.</li></ul><p>예를 들어 image.new.profile, image.new.gallery, image.delete.profile이라는 라우팅 키가 있을때<br>image.new.# : image.new.profile, image.new.gallery</p><p>#.profile : image.new.profile, image.delete.profile<br>위와 같이 Routing key의 특정 파트에 맞게 메시지를 Routing 할 수 있다.</p><ul><li>패턴 매칭을 사용하는 대신 전체 라우팅 키로 큐를 연결하면 된다.</li><li>#을 라우팅 키로 큐에 연결하면 Fanout exchange와 같은 효과를 낼 수 있다.</li></ul><h3 id="Header-Exchange"><a href="#Header-Exchange" class="headerlink" title="Header Exchange"></a>Header Exchange</h3><ul><li>다양한 속성에서 라우팅 키보다 쉽게 사용하도록 디자인되었다.</li><li>메시지 속성 중 headers 테이블을 사용해 특정한 규칙의 라우팅을 처리한다.</li><li>Queue.Bind 메소드의 인수로 x-match를 사용한다.<ul><li>x-match = any 일 경우 헤더 테이블 값 중 하나가 연결된 값 중 하나와 일치하면 메시지 전달</li><li>x-match = all 일 경우 모든 값이 일치해야 메시지를 전달한다.</li></ul></li></ul><p>출처 : <a href="https://www.rabbitmq.com/tutorials/amqp-concepts.html" target="_blank" rel="noopener">https://www.rabbitmq.com/tutorials/amqp-concepts.html</a></p>]]></content>
      
      
      
        <tags>
            
            <tag> Message Queue </tag>
            
            <tag> AMQP </tag>
            
            <tag> RabbitMQ </tag>
            
            <tag> Exchange </tag>
            
            <tag> Routing </tag>
            
            <tag> patten </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>AMQ 모델과 Exchange, Queue, Binding 에 대해</title>
      <link href="/2019/04/30/AMQ-%EB%AA%A8%EB%8D%B8%EA%B3%BC-Exchange-Queue-Binding-%EC%97%90-%EB%8C%80%ED%95%B4/"/>
      <url>/2019/04/30/AMQ-%EB%AA%A8%EB%8D%B8%EA%B3%BC-Exchange-Queue-Binding-%EC%97%90-%EB%8C%80%ED%95%B4/</url>
      
        <content type="html"><![CDATA[<h3 id="rabbitmq-강점과-유연성은-amqp-스펙에서-나온다"><a href="#rabbitmq-강점과-유연성은-amqp-스펙에서-나온다" class="headerlink" title="* rabbitmq 강점과 유연성은 amqp 스펙에서 나온다."></a>* rabbitmq 강점과 유연성은 amqp 스펙에서 나온다.</h3><ul><li><p>rabbitmq를 설명하기 앞서 amqp가 무엇인지 부터 알아보자.</p><p>amqp (advanced message queuing protocol)</p><ul><li><p>메시징 프로토콜!!!!</p></li><li><p>amqp 스펙은 여러가지가 있는데 rabbitmq는 0-8, 0-9-1과 밀접하게 관련돼 있다.</p></li><li><p>rabbitmq는 amqp 스펙을 구현했는데, 주요 아케텍쳐와 통신 방식이 핵심이다. </p></li></ul></li></ul><p>AMQP 스펙은 HTTP 프로토콜과 달리 네트워크 프로토콜의 정의뿐 아니라 서버 측 서비스와 동작 방식도 정의한다.</p><p>AMQ 모델은 메시지 라우팅 동작을 정의 하는 메시지 브로커의 <strong>세 가지 추상 컴포넌트</strong>를 다음과 같이 정의한다. </p><p>* 익스체인지 : 메시지 브로커에서 큐에 메시지를 전달하는 컴포넌트</p><p>* 큐 : 메시지를 저장하는 디스크 상이나 메모리 상의 자료구조</p><p>* 바인딩: 익스체인지에 전달된 메시지가 어떤 큐에 저장돼야 하는지 정의하는 컴포넌트 </p><p>여기서 이 3개 이해 못하고 넘어가면 두고두고 이해가 안간다.. </p><p>꼭 이해하고 넘어가자.</p><p><img src="/images\amqp\2-1.png" alt=""></p><ol><li>Producer가 exchange에게 메세지를 publish한다. (우체국으로 편지를 보내는거와 같다)</li><li><p>exchange는 binding이라는 규칙을 사용해 메세지의 복사본을 Queue에 배포한다.<br>-&gt; (원문) Exchanges then distribute message copies to queues using rules called bindings.<br>-&gt; 실제 메시지를 큐에 넣는 대신 메시지에 대한 참조가 queue에 추가 된다. 메시지를 전달할 준비가 되면 큐는 이 참조를 사용해서 클라이언트에 전송한다. 메시지가 여러 목적지에 발행될 때, 참조만 저장해서 메모리를 적게 사용한다.  </p></li><li><p>broker는 subscribe하고 있는 consumer에게 메시지를 전달하거나<br>요청시 queue에서 메시지를 fetch하거나 pull한다</p></li></ol><h4 id="–-Exchange-–"><a href="#–-Exchange-–" class="headerlink" title="-– Exchange -–"></a>-– Exchange -–</h4><p>- amqp 모델이 정의하는 세 컴포넌트 중 하나. </p><p>- rabbitmq로 전송한 메시지를 수신하고 메시지를 보낼 위치를 결정한다.</p><p>- 발행한 메시지가 처음 도착하는 지점, 메시지가 목적지에 도달할 수 있도록 라우팅 규칙 적용 담당.</p><p>- 다양한 라우팅 규칙이 존재함(Direct exchange, Fanout exchange, Topic exchange, Headers exchange)</p><h4 id="–Queue-—"><a href="#–Queue-—" class="headerlink" title="-–Queue —"></a>-–Queue —</h4><p>- AMQP 스펙에 따라 큐 설정이 immutable 함.(선언 후 지정한 설정 변경 불가, 설정 변경시 삭제 후 다시 만들어야 함)</p><p>- 수신한 메시지를 저장하는 역할을 한다. 메시지에 수행하는 작업을 정의하는 설정정보가 있다. </p><p>queue 동작을 결정하는 다양한 설정이 존재 한다.</p><ul><li>자동 삭제 큐<br>-&gt; comsumer와 연결을 맺고 메시지를 전달한 후 연결을 끓으면 큐 제거.</li><li>큐 독점 설정<br>-&gt; 설정하지 않으면 다수 consumer 가 큐를 구독 할 수 있음.<br>-&gt; 활성화 시 소비자가 연결 해제된 후 큐가 자동으로 제거 됨.<br>-&gt; 선언한 연결과 채널에서만 사용 할 수 있다. </li><li>자동 메시지 만료<br>-&gt; 일정 기간 동안 사용하지 않은 큐를 삭제 할 수 있는 기능<br>-&gt; 만료될 떄 즉시 제거되는것을 보장안함.</li><li>대기 메시지 수 제한<br>-&gt; 3.1.0부터 메시지 최대 크기를 설정 할 수 있음.<br>-&gt; 최대 크기에 도달 하면 새로운 메시지가 추가 될 때 가장 먼저 받은 메시지를 삭제한다.</li><li>오래된 메시지 큐에서 제거<br>-&gt; 메시지를 오랫동안 소비 않을떄 자동으로 삭제하는 기능</li></ul><p>queue 볼때 그냥 FIFO 아니야 하고 쉽게 봤는데 RabbitMq에서 쓰이는 queue는 진짜 한도 끝도 없다.</p><p>일단 개념 부터 Message Orderingm, Mirrored and Distributed Queues, Priorities, </p><p>CPU Utilisation and Parallelism Considerations  이런것도 있고 여기서 파생되는 문서가 너무 많다… </p><p>Priorities만 하더라도 AMQP 0-9-1 사양과 달리 RabbitMQ 대기열은 기본적으로 우선 순위를 지원하지 않는다. </p><p>얼랭 프로세스에 의해 1~10까지만 사용한다고 추천된다. </p><p>If priority queues are desired, we recommend using between 1 and 10. Currently using more priorities will consume more resources (Erlang processes). </p><p>이런게 한두가지가 아니라 필요하면 그때 찾아보고 개념만 이해하는게 좋을거 같다.</p><h4 id="–-Binding-—"><a href="#–-Binding-—" class="headerlink" title="-– Binding —"></a>-– Binding —</h4><p>- amqp 모델은 바인딩을 사용해서 큐와 익스체인지 관계를 정의한다. </p><p>- exchange와 queue간의 가상연결로 메시지가 익스체인지에서 큐로 이동할 수 있도록 하는 역할  </p><p>- Binding과Binding key는 익스체인지가 <strong>어떤 큐에</strong> 메시지를 전달해야 하는지를 의미한다.</p><p>- 익스체인지에 메시지를 발행할 때 애플리케이션은 라우팅 키 속성을 사용한다. </p><p>요약 ::::: </p><pre><code>     1. 애플리케이션이 메시지를 익스체인지에게 발행할때 routing-key 속성을 사용한다.      2. exchange가 메시지를 큐로 전달하기 위해 메시지의routing-key를 binding 키에 맞춰서 평가한다.     3. binding 키는 큐를 익스체인지에 연결하고 , 라우팅키를 평가하는 기준이다.  </code></pre><p>출처 :<br><a href="https://www.rabbitmq.com/tutorials/amqp-concepts.html" target="_blank" rel="noopener">https://www.rabbitmq.com/tutorials/amqp-concepts.html</a></p><p><a href="https://www.rabbitmq.com/amqp-0-9-1-reference.html" target="_blank" rel="noopener">https://www.rabbitmq.com/amqp-0-9-1-reference.html</a></p><p><a href="https://www.rabbitmq.com/queues.html" target="_blank" rel="noopener">https://www.rabbitmq.com/queues.html</a></p>]]></content>
      
      
      
        <tags>
            
            <tag> Message Queue </tag>
            
            <tag> AMQP </tag>
            
            <tag> RabbitMQ </tag>
            
            <tag> Exchange </tag>
            
            <tag> binding </tag>
            
            <tag> queue </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>5G 초연결시대에 웹 HTTP의 대안은 QUIC?</title>
      <link href="/2019/04/30/5G-%EC%B4%88%EC%97%B0%EA%B2%B0%EC%8B%9C%EB%8C%80%EC%97%90-%EC%9B%B9-HTTP%EC%9D%98-%EB%8C%80%EC%95%88%EC%9D%80-QUIC/"/>
      <url>/2019/04/30/5G-%EC%B4%88%EC%97%B0%EA%B2%B0%EC%8B%9C%EB%8C%80%EC%97%90-%EC%9B%B9-HTTP%EC%9D%98-%EB%8C%80%EC%95%88%EC%9D%80-QUIC/</url>
      
        <content type="html"><![CDATA[<h2 id="QUIC-소개"><a href="#QUIC-소개" class="headerlink" title="QUIC 소개"></a>QUIC 소개</h2><p>QUIC (Quick UDP Internet Connection)<br>구글에서 QUIC라는 프로토콜 설계하였고 2013년 6월 공개 했다.</p><p>국제 인터넷 표준화 기구 (IETF)에 QUIC 프로토콜 표준화를 제안하였다.</p><p>Google-QUIC은 오로지 HTTP만 전송했으나 IETF QUIC 워킹 그룹을 통해 IETF-QUIC 은 TLS 1.3의 암호화 보안을 적용해 개선하였다.</p><p>HTTP-over-QUIC은 2018년 11월에 HTTP/3로 개명하였고 QUIC 버전 1의 최종 명세 2019년 7월 발표 예정이다.</p><h2 id="QUIC-프로토콜에-대해"><a href="#QUIC-프로토콜에-대해" class="headerlink" title="QUIC 프로토콜에 대해"></a>QUIC 프로토콜에 대해</h2><p>기능 설명에 앞서서 QUIC를 이해하기 위해서는 TCP와 UDP에 대한 이해가 필요하다.</p><h4 id="TCP란"><a href="#TCP란" class="headerlink" title="TCP란?"></a>TCP란?</h4><p>전송 제어 프로토콜<br>(Transmission Control Protocol, TCP)</p><p><img src="https://user-images.githubusercontent.com/28129081/56914109-35453700-6aee-11e9-82a7-6f2b0ea32418.png" alt="출처: https://hpbn.co/transport-layer-security-tls/#tls-handshake"></p><p>TCP는 요청마다 3-way Handshake 와 SSL과 같은 암호화가 추가 된다면 TLS handshake 로 인한 RTT(Round Trip Time) 증가한다.<br>또한 HOL(head of line) 블로킹 문제 등이 있다.</p><h5 id="HOL-Head-Of-Line-블로킹"><a href="#HOL-Head-Of-Line-블로킹" class="headerlink" title="HOL(Head Of Line) 블로킹"></a>HOL(Head Of Line) 블로킹</h5><p><img src="https://user-images.githubusercontent.com/28129081/56914303-b8ff2380-6aee-11e9-98f0-f0c45d256a0d.png" alt="출처: https://hpbn.co/building-blocks-of-tcp/#head-of-line-blocking"><br> 위 그림을 보면 P1을 받아오지 못해 재요청을 하여 데이터를 받아오는것을 볼 수 있다. 데이터를 다시 요청함으로써 신뢰성을 높이지만 반대로 통신이 지연되는 것을 알 수 있다.<br>이는 TCP 통신의 장점이자 단점으로 보이는 문제라 볼수 있는데 이를 Head Of Line Blocking이라 한다.</p><h4 id="UDP-란"><a href="#UDP-란" class="headerlink" title="UDP 란?"></a>UDP 란?</h4><p>사용자 데이터그램 프로토콜<br>(User Datagram Protocol, UDP)</p><p><img src="https://user-images.githubusercontent.com/28129081/56914420-067b9080-6aef-11e9-8752-c69a8028374d.png" alt="UDP"><br>TCP처럼 3way-handshake가 없으며 RTT(Round Trip Time) 적어 속도가 빠른 반면에 데이터의 손실 가능성이 있고 그로 인해 신뢰성이 떨어진다고 볼 수 있다.</p><p>때문에 유튜브 영상 또는 게임에서 캐릭터 이동 등 데이터가 손실이 있더라도 괜찮은(?) 상황에서 많이 사용된다고 한다.</p><p>P2P통신에서도 UDP를 많이 쓴다고 하는데 중개서버를 활용한 UDP 홀펀칭이라는 기법을 사용한다고 한다.</p><p>시간이 된다면 추후 UDP 홀펀칭 기법도 스터디하여 소개할 수 있도록 하겠다.</p><p>여기까지 간단하게 TCP와 UDP에 대한 이해는 넘어가고 본격적으로 QUIC에 대해 알아보자.</p><h3 id="QUIC-프로토콜"><a href="#QUIC-프로토콜" class="headerlink" title="QUIC 프로토콜"></a>QUIC 프로토콜</h3><p><img src="https://user-images.githubusercontent.com/28129081/56917902-a4735900-6af7-11e9-8617-3dc7547eda7a.JPG" alt="출처: https://http3-explained.haxx.se/en/the-protocol.html"></p><p>위 그림과 같이 QUIC은 UDP 기반 위에서 구현한 전송 프로토콜이다. UDP는 데이터 신뢰성을 보장하지 않지만 <span style="color:red"><strong>QUIC 계층추가</strong></span>를 통해 TCP와 같은 <span style="color:red"><strong>신뢰성을 제공</strong></span>한다</p><p>HTTP2의 <span style="color:red"><strong>Multiplexing</strong></span> 과 같이 하나의 연결로 다수의 병렬 스트림으로 데이터를 동시 전송하며 UDP 기반이지만 그와 다르게 TCP와 같은 <span style="color:red"><strong>순서에 맞는 전송처리</strong></span>를 한다.</p><p>HTTP2에서는 여러 스트림중에 하나의 스트림이 패킷을 잃을 경우 복구가 되지 않았지만 QUIC은 다른 스트림이 전송 중에 잃은 <span style="color:red"><strong>스트림의 패킷을 재전송</strong></span>을 하여 완료가 가능하다고 한다.</p><p>0-RTT와 1-RTT설정을 지원하여 기존의 TCP와는 다른 빠른 핸드쉐이크를 지원한다. TLS 1.3 전송 보안을 지원하는데 핸드쉐이크시 더 적은 RTT를 위해 사용한다.<br>TLS 1.3은 RTT를 개선하였고 보안을 강화하기 위해서 TLS 1.2에서 지원하던 보안에 취약했던 기능들을 삭제를 했다고 한다.</p><p>HTTP/2에서 <strong>HPACK</strong>은 순차적인 스트림 전달에 의존하기 때문에 QUIC에 맞게 스트림을 순서 없이 전달 가능하게 수정하였는데 이를 <span style="color:red"><strong>QPACK</strong></span>이라고 한다.</p><p>최종적으로 TCP와 TCP+TLS 그리고 QUIC을 비교하면 아래그림과 같다.<br><img src="https://user-images.githubusercontent.com/28129081/56918649-8a3a7a80-6af9-11e9-8b3b-f52d33ad229f.png" alt="출처: https://blog.chromium.org/2015/04/a-quic-update-on-googles-experimental.html"><br>이렇게 HTTP3는 UDP기반을 통해 RTT를 0에 가깝게 줄여 속도향상을 가져왔다. 그리고 QUIC+TLS1.3 계층을 통해 TCP의 장점인 데이터의 신뢰성까지 보완했다고 볼 수 있다.<br>곧 오는 2019년 7월에 예정에 맞추어 QUIC 버전 1 이 정식으로 공개되고 나면 다시 한번 웹 시장은 5G 시대에 발 맞추어 기업들의 속도 경쟁에 요동칠 것으로 보인다. </p><p>조금 더 들어가 다음으로는 HTTP/2를 소개하도록 하겠다.</p><h2 id="HTTP-2-소개"><a href="#HTTP-2-소개" class="headerlink" title="HTTP/2 소개"></a>HTTP/2 소개</h2><p>구글에서 2009년 중반에 SPDY 발표 하였고 HTTP/2 프로토콜의 출발점으로 SPDY 사양이 채택되어 2015년 5월에 RFC 7540(HTTP/2) 및 RFC 7541(HPACK) 발행되었다.</p><h4 id="바이너리-프레이밍-계층"><a href="#바이너리-프레이밍-계층" class="headerlink" title="바이너리 프레이밍 계층"></a>바이너리 프레이밍 계층</h4><p><img src="https://user-images.githubusercontent.com/28129081/56918877-22386400-6afa-11e9-97a9-4de7c79cdb9d.PNG" alt="출처: https://hpbn.co/http2/#request-and-response-multiplexing"><br>위 그림의 오른쪽을 보면 이전 버전인 HTTP/1.1 에서는 헤더와 메시지의 그림이 하나로 묶여있던것을 볼수 있는데 HTTP/2 에서는 <strong>헤더 프레임</strong>과 <strong>데이터 프레임</strong>으로 나뉜것을 볼수 있다. 이들은 바이너리 형식으로 인코딩되어 처리가 된다.</p><p>프레임이라는 단어 및 그림을 계속 연상하면서 가보자.</p><h4 id="멀티플렉싱"><a href="#멀티플렉싱" class="headerlink" title="멀티플렉싱"></a>멀티플렉싱</h4><p><img src="https://user-images.githubusercontent.com/28129081/56919415-7e4fb800-6afb-11e9-9f09-d7fa1de4a5fe.PNG" alt="출처: https://hpbn.co/http2/#request-and-response-multiplexing"></p><p>위 그림은 스트림들이 어떻게 처리가 되는지를 보여준다. 스트림 단위로 병렬로 처리되고 있음을 볼 수 있다.<br>이는 기존 TCP의 문제인 HOL(Head Of Line) Blocking 문제로 인한 시간지연을 제거했다고 볼 수 있다.</p><h4 id="서버푸시"><a href="#서버푸시" class="headerlink" title="서버푸시"></a>서버푸시</h4><p><img src="https://user-images.githubusercontent.com/28129081/56924418-d1c80300-6b07-11e9-9b5f-4718594c5c90.PNG" alt="출처: https://hpbn.co/http2/#request-and-response-multiplexing"><br>위 그림은 오른쪽 클라이언트가 왼쪽 서버에 stream1에 해당하는 frame1을 전송했다. 그리고 클라이언트는 계속해서 stream1의 frame2를 보내는 중이었다.<br>그런데 하나의 요청으로 서버는 추가적인 모든 데이터를 클라이언트에 푸시를 할 수가 있다.</p><p>이를 HTTP/2의 강력한 기능 중 하나인 <strong>서버푸시</strong>라 한다.</p><h4 id="헤더압축"><a href="#헤더압축" class="headerlink" title="헤더압축"></a>헤더압축</h4><p><img src="https://user-images.githubusercontent.com/28129081/56924693-84986100-6b08-11e9-95d1-f1d1116486dc.PNG" alt="출처: https://hpbn.co/http2/#request-and-response-multiplexing"><br>이번 그림은 헤더압축을 나타내는 그림이다. request1과 request 2를 잘 보면 헤더정보가 url path만 다르고 같은 값들로 채워져 있다.<br>request1에 해당하는 Sream1을 전달한 후에 request 2 의 헤더정보를 담고 있는 Sream2의 중복되는 헤더 정보를 제외하고 다른Stream으로 서버에 요청을 할 것이다.<br><strong>중복된 헤더정보를 제거</strong>함으로써 페이지 로드 시간이 상당히 감소했다고 한다.</p><p>지금까지 HTTP/3 과 HTTP/2 에 대한 개념과 기능에 대해 알아보았다.<br>정리하자면 아래와 같다.</p><ul><li>첫째, HTTP/3는 <span style="color:red"><strong>스트림의 패킷 재전송</strong></span>을 통한 복구 완료가 가능하다는 점.</li><li>둘째, HPACK 의 순차적인 스트림 전달을 순서 없이 전달 가능하게 하여 <strong>병렬처리 성능을 개선</strong>하여 나온 <span style="color:red"><strong>QPACK</strong></span>.</li><li>마지막으로 셋째, UDP기반위의 <span style="color:red"><strong>QUIC 프로토콜</strong></span>을 통해 암호화 보안(TLS 1.3)을 적용했음에도 이론상 <span style="color:red"><strong>0-RTT</strong></span>라는 것이 HTTP/3의 장점이라고 말하고 있다.</li></ul><p>병렬처리 성능 및 속도, 보안 향상, 데이터의 신뢰성 등. 어느것 하나 빠짐없어 보이는 장점들을 보며 곧 다가올 2019년 7월 발표 예정일이 기대가 된다.</p><p><br></p><div style="font-size:14px;"><br>참고자료<br>[HTTP2]<br><a href="https://developers.google.com/web/fundamentals/performance/http2/" target="_blank" rel="noopener">https://developers.google.com/web/fundamentals/performance/http2/</a><br><a href="https://hpbn.co/http2/#request-and-response-multiplexing" target="_blank" rel="noopener">https://hpbn.co/http2/#request-and-response-multiplexing</a><br>[HTTP/3 explained]<br>저자 Daniel Stenberg - curl 개발자 (<a href="https://http3-explained.haxx.se/en/" target="_blank" rel="noopener">https://http3-explained.haxx.se/en/</a>)<br></div>]]></content>
      
      
      <categories>
          
          <category> WEB </category>
          
      </categories>
      
      
        <tags>
            
            <tag> QUIC </tag>
            
            <tag> HTTP/3 </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>JAVA8말고 JAVA9를 사용해볼까</title>
      <link href="/2019/04/23/Java9/"/>
      <url>/2019/04/23/Java9/</url>
      
        <content type="html"><![CDATA[<p><img src="/images/java9/java9.jpg" alt=""></p><p>현재 많은 개발자가 Java8 버전을 사용하여 개발을 하고 있습니다.</p><p>Java9 부터는 6개월마다 새로운 버전의 Java가 출시되면서 현재 12버전까지 출시 하였습니다.</p><p>그 중에서  JAVA9 버전에 관해 대해 자세히 알아봅니다.</p><h2 id="JDK-출시-및-지원-기간"><a href="#JDK-출시-및-지원-기간" class="headerlink" title="JDK 출시 및 지원 기간"></a>JDK 출시 및 지원 기간</h2><p><img src="/images/java9/oracleJdk.gif" alt=""></p><p>JDK 출시 및 지원기간에 대해 알아보겠습니다.<br>파란색 마커는 무료 버전 OpenJDK의 출시시기 및 지원 기간을 나타내고 주황색 마커는 유료 버전 Oracle JDK를 뜻합니다.무료 OpenJDK 6 개월마다 메이저 버전 업이 등장하고 그 때마다 지원 기간이 종료하는 것을 알 수 있습니다.<br>Java 11부터 Java는 3 년마다 “LTS”(Long Term Support)라는 장기 지원에 대응 한 메이저 버전이 등장합니다. 그 LTS 버전마다 Oracle JDK의 메이저 버전 업을 합니다.</p><p>메이저 버전 업 후에는 이전 주요 버전에 대한 마이너 버전 업을하지 않게됩니다.</p><p><img src="/images/java9/java-version.png" alt=""></p><p>왜 Java는 6 개월마다 메이저 버전 업으로 출시 모델을 변경하는 걸까요?<br>Java는 지금까지 큰 기능 추가에 따라 메이저 버전 업을 해왔습니다. 큰 새로운 기능의 개발에 오랜 시간이 걸리고 때로는 개발 일정 지연도 있었습니다. 예를 들어, Java 6에서 7로 메이저 버전 업에는 4 년 8 개월, Java 7에서 8로 2 년 8 개월, Java 8-9로는 3 년 6 개월 걸렸습니다. 최근에는 Java는 다른 언어 나 기술과 비교하면 진화가 느린 다소 오래된 것으로 보입니다.기존 출시 모델을 바꾸게 6 개월마다로 전환 한 것은 이러한 점에서 Java를 지금까지보다 빠른 속도로 전진 시키려고하고 있기 때문입니다.</p><h2 id="마이그레이션시-우려-사항"><a href="#마이그레이션시-우려-사항" class="headerlink" title="마이그레이션시 우려 사항"></a>마이그레이션시 우려 사항</h2><p>많은 개발자들이 Java8에서 Java9로 업그레이드 할 때 많은 변경으로 인해 애플리케이션이 중단될수 있다는 걱정이 있습니다. 변경 사항 중 하나는 내부 API의 캡슐화 입니다. 애플리케이션에서 내부 API를 사용하지 않는 경우 Java9 이상으로 마이그레이션 하는것은 어렵지 않습니다.</p><h2 id="알아두면-좋을-변경된-점"><a href="#알아두면-좋을-변경된-점" class="headerlink" title="알아두면 좋을 변경된 점"></a>알아두면 좋을 변경된 점</h2><h3 id="HTTP-2-Client"><a href="#HTTP-2-Client" class="headerlink" title="HTTP 2 Client"></a><strong>HTTP 2 Client</strong></h3><ul><li>HttpURLConnection를 대체<ul><li>요청,응답의 하나의 스레드만 지원</li><li>오버헤드 발생</li></ul></li><li>jdk.incubator.http 패키지 추가</li><li>HTTP/1.1 및 HTTP/2 프로토콜 지원<ul><li>JAVA1.8 까지는 HTTP/ 1.1만을 지원</li></ul></li><li>동기/비동기 지원</li></ul><pre class=" language-java"><code class="language-java">HttpClient client <span class="token operator">=</span> HttpClient    <span class="token punctuation">.</span><span class="token function">newBuilder</span><span class="token punctuation">(</span><span class="token punctuation">)</span>    <span class="token punctuation">.</span><span class="token function">version</span><span class="token punctuation">(</span>Version<span class="token punctuation">.</span>HTTP_2<span class="token punctuation">)</span>    <span class="token punctuation">.</span><span class="token function">build</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token comment" spellcheck="true">//동기 호출</span>HttpResponse<span class="token operator">&lt;</span>String<span class="token operator">></span> response <span class="token operator">=</span> client<span class="token punctuation">.</span><span class="token function">send</span><span class="token punctuation">(</span>    HttpRequest        <span class="token punctuation">.</span><span class="token function">newBuilder</span><span class="token punctuation">(</span>TEST_URI<span class="token punctuation">)</span>        <span class="token punctuation">.</span><span class="token function">POST</span><span class="token punctuation">(</span>BodyProcessor<span class="token punctuation">.</span><span class="token function">fromString</span><span class="token punctuation">(</span><span class="token string">"Hello world"</span><span class="token punctuation">)</span><span class="token punctuation">)</span>        <span class="token punctuation">.</span><span class="token function">build</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">,</span>    BodyHandler<span class="token punctuation">.</span><span class="token function">asString</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token comment" spellcheck="true">//비동기 호출</span><span class="token comment" spellcheck="true">//임의의 정수가 비동기적으로 요청, 완료 될 때까지 주 스레드 대기</span>List<span class="token operator">&lt;</span>CompletableFuture<span class="token operator">&lt;</span>String<span class="token operator">>></span> responseFutures <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">Random</span><span class="token punctuation">(</span><span class="token punctuation">)</span>    <span class="token punctuation">.</span><span class="token function">ints</span><span class="token punctuation">(</span><span class="token number">10</span><span class="token punctuation">)</span>    <span class="token punctuation">.</span><span class="token function">mapToObj</span><span class="token punctuation">(</span>String<span class="token operator">:</span><span class="token operator">:</span>valueOf<span class="token punctuation">)</span>    <span class="token punctuation">.</span><span class="token function">map</span><span class="token punctuation">(</span>message <span class="token operator">-</span><span class="token operator">></span> client        <span class="token punctuation">.</span><span class="token function">sendAsync</span><span class="token punctuation">(</span>          HttpRequest<span class="token punctuation">.</span><span class="token function">newBuilder</span><span class="token punctuation">(</span>TEST_URI<span class="token punctuation">)</span>            <span class="token punctuation">.</span><span class="token function">POST</span><span class="token punctuation">(</span>BodyProcessor<span class="token punctuation">.</span><span class="token function">fromString</span><span class="token punctuation">(</span>message<span class="token punctuation">)</span><span class="token punctuation">)</span>            <span class="token punctuation">.</span><span class="token function">build</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">,</span>          BodyHandler<span class="token punctuation">.</span><span class="token function">asString</span><span class="token punctuation">(</span><span class="token punctuation">)</span>        <span class="token punctuation">)</span>        <span class="token punctuation">.</span><span class="token function">thenApply</span><span class="token punctuation">(</span>r <span class="token operator">-</span><span class="token operator">></span> r<span class="token punctuation">.</span><span class="token function">body</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span>    <span class="token punctuation">)</span>    <span class="token punctuation">.</span><span class="token function">collect</span><span class="token punctuation">(</span>Collectors<span class="token punctuation">.</span><span class="token function">toList</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>CompletableFuture<span class="token punctuation">.</span><span class="token function">allOf</span><span class="token punctuation">(</span>responseFutures<span class="token punctuation">.</span><span class="token function">toArray</span><span class="token punctuation">(</span><span class="token keyword">new</span> <span class="token class-name">CompletableFuture</span><span class="token operator">&lt;</span><span class="token operator">?</span><span class="token operator">></span><span class="token punctuation">[</span><span class="token number">0</span><span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">join</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>responseFutures<span class="token punctuation">.</span><span class="token function">stream</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">forEach</span><span class="token punctuation">(</span>future <span class="token operator">-</span><span class="token operator">></span> <span class="token punctuation">{</span>  LOGGER<span class="token punctuation">.</span><span class="token function">info</span><span class="token punctuation">(</span><span class="token string">"Async response: "</span> <span class="token operator">+</span> future<span class="token punctuation">.</span><span class="token function">getNow</span><span class="token punctuation">(</span>null<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token punctuation">}</span><span class="token punctuation">)</span><span class="token punctuation">;</span>Map<span class="token operator">&lt;</span>HttpRequest<span class="token punctuation">,</span> CompletableFuture<span class="token operator">&lt;</span>HttpResponse<span class="token operator">&lt;</span>String<span class="token operator">>>></span> responses <span class="token operator">=</span>  client<span class="token punctuation">.</span><span class="token function">sendAsync</span><span class="token punctuation">(</span>    HttpRequest<span class="token punctuation">.</span><span class="token function">newBuilder</span><span class="token punctuation">(</span>TEST_URI<span class="token punctuation">)</span>      <span class="token punctuation">.</span><span class="token function">POST</span><span class="token punctuation">(</span>BodyProcessor<span class="token punctuation">.</span><span class="token function">fromString</span><span class="token punctuation">(</span>TEST_MESSAGE<span class="token punctuation">)</span><span class="token punctuation">)</span>      <span class="token punctuation">.</span><span class="token function">build</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">,</span>    MultiProcessor<span class="token punctuation">.</span><span class="token function">asMap</span><span class="token punctuation">(</span>request <span class="token operator">-</span><span class="token operator">></span> Optional<span class="token punctuation">.</span><span class="token function">of</span><span class="token punctuation">(</span>BodyHandler<span class="token punctuation">.</span><span class="token function">asString</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">)</span>  <span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">join</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>responses<span class="token punctuation">.</span><span class="token function">forEach</span><span class="token punctuation">(</span><span class="token punctuation">(</span>request<span class="token punctuation">,</span> responseFuture<span class="token punctuation">)</span> <span class="token operator">-</span><span class="token operator">></span> <span class="token punctuation">{</span>  LOGGER<span class="token punctuation">.</span><span class="token function">info</span><span class="token punctuation">(</span><span class="token string">"Async response: "</span> <span class="token operator">+</span> responseFuture<span class="token punctuation">.</span><span class="token function">getNow</span><span class="token punctuation">(</span>null<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token punctuation">}</span><span class="token punctuation">)</span><span class="token punctuation">;</span></code></pre><h3 id="More-Concurrency-Updates-reactive-stream"><a href="#More-Concurrency-Updates-reactive-stream" class="headerlink" title="More Concurrency Updates (reactive stream)"></a>More Concurrency Updates (reactive stream)</h3><ul><li>CompletableFuture  개선</li><li>reactive stream 도입<ul><li>게시자, 구독자, 구독, 프로세서</li></ul></li><li>java.util.concurrent.Flow 패키지 추가</li></ul><p>Reactive Streams 표준 구현은 <a href="https://docs.oracle.com/javase/9/docs/api/java/util/concurrent/Flow.html" target="_blank" rel="noopener">java.util.concurrent.Flow</a> 클래스에 있으며 <code>Flow</code>클래스 내에 정적 인터페이스로 번들로 제공</p><pre class=" language-java"><code class="language-java"><span class="token keyword">public</span> <span class="token keyword">final</span> <span class="token keyword">class</span> <span class="token class-name">Flow</span> <span class="token punctuation">{</span>    <span class="token keyword">private</span> <span class="token function">Flow</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span><span class="token punctuation">}</span> <span class="token comment" spellcheck="true">// 인스턴스 생성 불가</span>    <span class="token annotation punctuation">@FunctionalInterface</span>    <span class="token keyword">public</span> <span class="token keyword">static</span> <span class="token keyword">interface</span> <span class="token class-name">Publisher</span><span class="token operator">&lt;</span>T<span class="token operator">></span> <span class="token punctuation">{</span>        <span class="token keyword">public</span> <span class="token keyword">void</span> <span class="token function">subscribe</span><span class="token punctuation">(</span>Subscriber<span class="token operator">&lt;</span><span class="token operator">?</span> <span class="token keyword">super</span> T<span class="token operator">></span> subscriber<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span>    <span class="token keyword">public</span> <span class="token keyword">static</span> <span class="token keyword">interface</span> <span class="token class-name">Subscriber</span><span class="token operator">&lt;</span>T<span class="token operator">></span> <span class="token punctuation">{</span>        <span class="token keyword">public</span> <span class="token keyword">void</span> <span class="token function">onSubscribe</span><span class="token punctuation">(</span>Subscription subscription<span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token keyword">public</span> <span class="token keyword">void</span> <span class="token function">onNext</span><span class="token punctuation">(</span>T item<span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token keyword">public</span> <span class="token keyword">void</span> <span class="token function">onError</span><span class="token punctuation">(</span>Throwable throwable<span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token keyword">public</span> <span class="token keyword">void</span> <span class="token function">onComplete</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span>    <span class="token keyword">public</span> <span class="token keyword">static</span> <span class="token keyword">interface</span> <span class="token class-name">Subscription</span> <span class="token punctuation">{</span>        <span class="token keyword">public</span> <span class="token keyword">void</span> <span class="token function">request</span><span class="token punctuation">(</span><span class="token keyword">long</span> n<span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token keyword">public</span> <span class="token keyword">void</span> <span class="token function">cancel</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span>    <span class="token keyword">public</span> <span class="token keyword">static</span> <span class="token keyword">interface</span> <span class="token class-name">Processor</span><span class="token operator">&lt;</span>T<span class="token punctuation">,</span>R<span class="token operator">></span> <span class="token keyword">extends</span> <span class="token class-name">Subscriber</span><span class="token operator">&lt;</span>T<span class="token operator">></span><span class="token punctuation">,</span> Publisher<span class="token operator">&lt;</span>R<span class="token operator">></span> <span class="token punctuation">{</span><span class="token punctuation">}</span><span class="token punctuation">}</span></code></pre><p>게시자 구현이 포함되어 있는 <code>SubmissionPublisher</code></p><ul><li><code>submit(T item)</code>메서드를 사용하여 구독자에게 푸시 할 항목을 허용하는 단순한 게시자 역할</li><li><code>submit</code>메서드를 실행하면 구독자에게 비동기적으로 푸시</li></ul><pre class=" language-java"><code class="language-java"><span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">PrintSubscriber</span> <span class="token keyword">implements</span> <span class="token class-name">Subscriber</span><span class="token operator">&lt;</span>Integer<span class="token operator">></span> <span class="token punctuation">{</span>    <span class="token keyword">private</span> Subscription subscription<span class="token punctuation">;</span>    <span class="token annotation punctuation">@Override</span>    <span class="token keyword">public</span> <span class="token keyword">void</span> <span class="token function">onSubscribe</span><span class="token punctuation">(</span>Subscription subscription<span class="token punctuation">)</span> <span class="token punctuation">{</span>        <span class="token keyword">this</span><span class="token punctuation">.</span>subscription <span class="token operator">=</span> subscription<span class="token punctuation">;</span>        subscription<span class="token punctuation">.</span><span class="token function">request</span><span class="token punctuation">(</span><span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span>    <span class="token annotation punctuation">@Override</span>    <span class="token keyword">public</span> <span class="token keyword">void</span> <span class="token function">onNext</span><span class="token punctuation">(</span>Integer item<span class="token punctuation">)</span> <span class="token punctuation">{</span>        System<span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span><span class="token string">"Received item: "</span> <span class="token operator">+</span> item<span class="token punctuation">)</span><span class="token punctuation">;</span>        subscription<span class="token punctuation">.</span><span class="token function">request</span><span class="token punctuation">(</span><span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span>    <span class="token annotation punctuation">@Override</span>    <span class="token keyword">public</span> <span class="token keyword">void</span> <span class="token function">onError</span><span class="token punctuation">(</span>Throwable error<span class="token punctuation">)</span> <span class="token punctuation">{</span>        System<span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span><span class="token string">"Error occurred: "</span> <span class="token operator">+</span> error<span class="token punctuation">.</span><span class="token function">getMessage</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span>    <span class="token annotation punctuation">@Override</span>    <span class="token keyword">public</span> <span class="token keyword">void</span> <span class="token function">onComplete</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>        System<span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span><span class="token string">"PrintSubscriber is complete"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span><span class="token punctuation">}</span><span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">SubmissionPublisherExample</span> <span class="token punctuation">{</span>    <span class="token keyword">public</span> <span class="token keyword">static</span> <span class="token keyword">void</span> <span class="token function">main</span><span class="token punctuation">(</span>String<span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span> args<span class="token punctuation">)</span> <span class="token keyword">throws</span> InterruptedException <span class="token punctuation">{</span>        SubmissionPublisher<span class="token operator">&lt;</span>Integer<span class="token operator">></span> publisher <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">SubmissionPublisher</span><span class="token operator">&lt;</span><span class="token operator">></span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        publisher<span class="token punctuation">.</span><span class="token function">subscribe</span><span class="token punctuation">(</span><span class="token keyword">new</span> <span class="token class-name">PrintSubscriber</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        System<span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span><span class="token string">"Submitting items..."</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">int</span> i <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span> i <span class="token operator">&lt;</span> <span class="token number">10</span><span class="token punctuation">;</span> i<span class="token operator">++</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>            publisher<span class="token punctuation">.</span><span class="token function">submit</span><span class="token punctuation">(</span>i<span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token punctuation">}</span>        Thread<span class="token punctuation">.</span><span class="token function">sleep</span><span class="token punctuation">(</span><span class="token number">1000</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        publisher<span class="token punctuation">.</span><span class="token function">close</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span><span class="token punctuation">}</span><span class="token comment" spellcheck="true">/*Submitting items...Received item: 0Received item: 1Received item: 2Received item: 3Received item: 4Received item: 5Received item: 6Received item: 7Received item: 8Received item: 9PrintSubscriber is complete*/</span></code></pre><p>구독자 내 <code>Subscription</code>에서 <code>onSubscribe</code>메소드 에 전달 된 객체를 캡처하여 <code>Subscription</code> 나중에 해당 객체와 상호작용 할 수 있습니다.( <code>subscription.request(1)</code>호출)</p><p><code>onNext</code>메소드 내에서 게시자가 항목 처리를 완료하자마자 다른 항목을 수락 할 준비가 되었음을 게시자에게 알립니다.</p><p> <code>SubmissionPublisher</code>와  <code>PrintSubscriber</code>를 인스턴스화하고 후자를 전자에 구독한다. 구독이 설정되면 게시자에게 0에서 9까지의 값을 제출하고 구독자에게 값을 비동기 적으로 푸시합니다. 그런 다음 구독자는 값을 표준 출력하여 각 항목을 처리하고 다른 값을 받아 들일 준비가되었음을 구독에 알립니다. 그런 다음 비동기 전송이 완료 될 수 있도록 1 초 동안 주 스레드를 일시 중지합니다. <code>submit</code> 메소드가 제출 된 항목을 비동기 적으로 구독자에게 푸시하기 때문에 이는 매우 중요한 단계입니다. 따라서 비동기 작업이 완료 될 때까지 상당한 시간을 제공해야합니다. 마지막으로 게시자를 닫고 구독자에게 가입이 완료되었음을 알립니다.</p><p>프로세서를 도입하고 원래의 게시자와 구독자를이 프로세서와 연결할 수 있습니다. 수신 된 값을 10 씩 증가시키고 증가 된 값을 구독자에게 푸시 (push)하는 프로세서를 생성합니다.</p><p>각각의 푸시된 값은 10씩 증가하며, 프로세서에 의해 수신된 이벤트(오류 수신 또는 완료 등)는 가입자에게 전달되며, 결과적으로 <code>PlusTenProcessor</code>와 <code>PrintSubscriber</code> 에 대해 완료된 메시지가 표시된다.</p><pre class=" language-java"><code class="language-java"><span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">PlusTenProcessor</span> <span class="token keyword">extends</span> <span class="token class-name">SubmissionPublisher</span><span class="token operator">&lt;</span>Integer<span class="token operator">></span> <span class="token keyword">implements</span> <span class="token class-name">Subscriber</span><span class="token operator">&lt;</span>Integer<span class="token operator">></span> <span class="token punctuation">{</span>    <span class="token keyword">private</span> Subscription subscription<span class="token punctuation">;</span>    <span class="token annotation punctuation">@Override</span>    <span class="token keyword">public</span> <span class="token keyword">void</span> <span class="token function">onSubscribe</span><span class="token punctuation">(</span>Subscription subscription<span class="token punctuation">)</span> <span class="token punctuation">{</span>        <span class="token keyword">this</span><span class="token punctuation">.</span>subscription <span class="token operator">=</span> subscription<span class="token punctuation">;</span>        subscription<span class="token punctuation">.</span><span class="token function">request</span><span class="token punctuation">(</span><span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span>    <span class="token annotation punctuation">@Override</span>    <span class="token keyword">public</span> <span class="token keyword">void</span> <span class="token function">onNext</span><span class="token punctuation">(</span>Integer item<span class="token punctuation">)</span> <span class="token punctuation">{</span>        <span class="token function">submit</span><span class="token punctuation">(</span>item <span class="token operator">+</span> <span class="token number">10</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        subscription<span class="token punctuation">.</span><span class="token function">request</span><span class="token punctuation">(</span><span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span>    <span class="token annotation punctuation">@Override</span>    <span class="token keyword">public</span> <span class="token keyword">void</span> <span class="token function">onError</span><span class="token punctuation">(</span>Throwable error<span class="token punctuation">)</span> <span class="token punctuation">{</span>        error<span class="token punctuation">.</span><span class="token function">printStackTrace</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token function">closeExceptionally</span><span class="token punctuation">(</span>error<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span>    <span class="token annotation punctuation">@Override</span>    <span class="token keyword">public</span> <span class="token keyword">void</span> <span class="token function">onComplete</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>        System<span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span><span class="token string">"PlusTenProcessor completed"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token function">close</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span><span class="token punctuation">}</span><span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">SubmissionPublisherExample</span> <span class="token punctuation">{</span>    <span class="token keyword">public</span> <span class="token keyword">static</span> <span class="token keyword">void</span> <span class="token function">main</span><span class="token punctuation">(</span>String<span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span> args<span class="token punctuation">)</span> <span class="token keyword">throws</span> InterruptedException <span class="token punctuation">{</span>        SubmissionPublisher<span class="token operator">&lt;</span>Integer<span class="token operator">></span> publisher <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">SubmissionPublisher</span><span class="token operator">&lt;</span><span class="token operator">></span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        PlusTenProcessor processor <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">PlusTenProcessor</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        PrintSubscriber subscriber <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">PrintSubscriber</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        publisher<span class="token punctuation">.</span><span class="token function">subscribe</span><span class="token punctuation">(</span>processor<span class="token punctuation">)</span><span class="token punctuation">;</span>        processor<span class="token punctuation">.</span><span class="token function">subscribe</span><span class="token punctuation">(</span>subscriber<span class="token punctuation">)</span><span class="token punctuation">;</span>        System<span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span><span class="token string">"Submitting items..."</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">int</span> i <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span> i <span class="token operator">&lt;</span> <span class="token number">10</span><span class="token punctuation">;</span> i<span class="token operator">++</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>            publisher<span class="token punctuation">.</span><span class="token function">submit</span><span class="token punctuation">(</span>i<span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token punctuation">}</span>        Thread<span class="token punctuation">.</span><span class="token function">sleep</span><span class="token punctuation">(</span><span class="token number">1000</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        publisher<span class="token punctuation">.</span><span class="token function">close</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span><span class="token punctuation">}</span><span class="token comment" spellcheck="true">/*Submitting items...Received item: 10Received item: 11Received item: 12Received item: 13Received item: 14Received item: 15Received item: 16Received item: 17Received item: 18Received item: 19PlusTenProcessor completedPrintSubscriber is complete*/</span></code></pre><h2 id="Convenience-Factory-Methods-for-Collections"><a href="#Convenience-Factory-Methods-for-Collections" class="headerlink" title="Convenience Factory Methods for Collections"></a>Convenience Factory Methods for Collections</h2><p>불변 Collection 메소드가 생겼습니다.</p><p>예전에는 아래와 같이 불편하게 사용해야 했습니다.</p><pre class=" language-java"><code class="language-java">List<span class="token operator">&lt;</span>String<span class="token operator">></span> band <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">ArrayList</span><span class="token operator">&lt;</span><span class="token operator">></span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>band<span class="token punctuation">.</span><span class="token function">add</span><span class="token punctuation">(</span><span class="token string">"Bruce"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>band<span class="token punctuation">.</span><span class="token function">add</span><span class="token punctuation">(</span><span class="token string">"Steve"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>band<span class="token punctuation">.</span><span class="token function">add</span><span class="token punctuation">(</span><span class="token string">"Adrian"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>band<span class="token punctuation">.</span><span class="token function">add</span><span class="token punctuation">(</span><span class="token string">"Janick"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>band<span class="token punctuation">.</span><span class="token function">add</span><span class="token punctuation">(</span><span class="token string">"Nicko"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>band <span class="token operator">=</span> Collections<span class="token punctuation">.</span><span class="token function">unmodifiableList</span><span class="token punctuation">(</span>band<span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token comment" spellcheck="true">//stream</span>List<span class="token operator">&lt;</span>String<span class="token operator">></span> band <span class="token operator">=</span> Collections  <span class="token punctuation">.</span><span class="token function">unmodifiableList</span><span class="token punctuation">(</span>Stream<span class="token punctuation">.</span><span class="token function">of</span><span class="token punctuation">(</span><span class="token string">"Bruce"</span><span class="token punctuation">,</span><span class="token string">"Steve"</span><span class="token punctuation">,</span><span class="token string">"Adrian"</span><span class="token punctuation">,</span> <span class="token string">"Dave"</span><span class="token punctuation">,</span> <span class="token string">"Janick"</span><span class="token punctuation">,</span><span class="token string">"Nicko"</span><span class="token punctuation">)</span>    <span class="token punctuation">.</span><span class="token function">collect</span><span class="token punctuation">(</span><span class="token function">toList</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span></code></pre><p>불변의 Collection이란 생성한 Collection을 수정할 수 없는 것을 말합니다.</p><ul><li><code>java.util</code> 패키지는 <code>package-private ImmutableCollections</code> 클래스로 구성되어 있으며 불변 기능을 제공하는 클래스가 있습니다.</li><li>클래스의 인스턴스는 이미 존재하는 인터페이스의 정적 팩토리 메소드를 사용하여 만들어집니다.</li></ul><h3 id="List"><a href="#List" class="headerlink" title="List"></a>List</h3><p>불변의리스트에는 추상 기본 클래스  <code>AbstractImmutableList&lt;E&gt;</code> 와 4 개의 구현이 있습니다.</p><ul><li><code>List0&lt;E&gt;</code> </li><li><code>List1&lt;E&gt;</code> </li><li><code>List2&lt;E&gt;</code> </li><li><code>ListN&lt;E&gt;</code> </li></ul><p>이러한 각 유형은 작성하는 데 사용되는 요소의 수에 해당합니다. <code>java.util.List</code> 인터페이스에는 위의 구현을 사용하여 불변의 객체를 생성하는 12가지 정적 팩토리 메소드가 있습니다.</p><pre class=" language-java"><code class="language-java"><span class="token keyword">static</span> <span class="token operator">&lt;</span>E<span class="token operator">></span> List<span class="token operator">&lt;</span>E<span class="token operator">></span> <span class="token function">of</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token keyword">static</span> <span class="token operator">&lt;</span>E<span class="token operator">></span> List<span class="token operator">&lt;</span>E<span class="token operator">></span> <span class="token function">of</span><span class="token punctuation">(</span>E e1<span class="token punctuation">)</span><span class="token keyword">static</span> <span class="token operator">&lt;</span>E<span class="token operator">></span> List<span class="token operator">&lt;</span>E<span class="token operator">></span> <span class="token function">of</span><span class="token punctuation">(</span>E e1<span class="token punctuation">,</span> E e2<span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token keyword">static</span> <span class="token operator">&lt;</span>E<span class="token operator">></span> List<span class="token operator">&lt;</span>E<span class="token operator">></span> <span class="token function">of</span><span class="token punctuation">(</span>E e1<span class="token punctuation">,</span> E e2<span class="token punctuation">,</span> E e3<span class="token punctuation">,</span> E e4<span class="token punctuation">,</span> E e5<span class="token punctuation">,</span> E e6<span class="token punctuation">,</span> E e7<span class="token punctuation">,</span> E e8<span class="token punctuation">,</span> E e9<span class="token punctuation">,</span> E e10<span class="token punctuation">)</span><span class="token keyword">static</span> <span class="token operator">&lt;</span>E<span class="token operator">></span> List<span class="token operator">&lt;</span>E<span class="token operator">></span> <span class="token function">of</span><span class="token punctuation">(</span>E<span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span> elements<span class="token punctuation">)</span></code></pre><p>아래의 메소드를 사용하면 <code>UnsupportedOperationException</code>가 발생합니다.</p><pre class=" language-java"><code class="language-java"><span class="token keyword">boolean</span>  <span class="token function">add</span> <span class="token punctuation">(</span> E  e <span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token keyword">boolean</span>  <span class="token function">addAll</span> <span class="token punctuation">(</span> Collection <span class="token operator">&lt;</span><span class="token operator">?</span>  <span class="token keyword">extends</span>  <span class="token class-name">E</span> <span class="token operator">></span>  c <span class="token punctuation">)</span><span class="token punctuation">;</span>부울  <span class="token function">addAll</span> <span class="token punctuation">(</span> <span class="token keyword">int</span>  index <span class="token punctuation">,</span> Collection <span class="token operator">&lt;</span><span class="token operator">?</span>  <span class="token keyword">extends</span>  <span class="token class-name">E</span> <span class="token operator">></span>  c <span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token keyword">void</span>     <span class="token function">clear</span> <span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>부울  <span class="token function">remove</span> <span class="token punctuation">(</span> Object  o <span class="token punctuation">)</span><span class="token punctuation">;</span>부울  <span class="token function">removeAll</span> <span class="token punctuation">(</span> Collection <span class="token operator">&lt;</span><span class="token operator">?</span><span class="token operator">></span>  c <span class="token punctuation">)</span><span class="token punctuation">;</span>부울  <span class="token function">removeIf</span> <span class="token punctuation">(</span> 술어 <span class="token operator">&lt;</span><span class="token operator">?</span>  <span class="token keyword">super</span>  E <span class="token operator">></span>  필터 <span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token keyword">void</span>     <span class="token function">replaceAll</span> <span class="token punctuation">(</span> UnaryOperator <span class="token operator">&lt;</span> E <span class="token operator">></span>  연산자 <span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token keyword">boolean</span>  <span class="token function">retainAll</span> <span class="token punctuation">(</span> Collection <span class="token operator">&lt;</span><span class="token operator">?</span><span class="token operator">></span>  c <span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token keyword">void</span>     <span class="token function">sort</span> <span class="token punctuation">(</span> Comparator <span class="token operator">&lt;</span><span class="token operator">?</span>  <span class="token keyword">super</span>  E <span class="token operator">></span>  c <span class="token punctuation">)</span><span class="token punctuation">;</span></code></pre><p>내용을 불변하는것 외에도  <code>null</code> 값의 유효성도 체크합니다. 아래의 코드는 <code>NullPointerException</code>이 발생합니다.</p><pre class=" language-java"><code class="language-java">List<span class="token operator">&lt;</span>String<span class="token operator">></span> band <span class="token operator">=</span> List<span class="token punctuation">.</span><span class="token function">of</span><span class="token punctuation">(</span><span class="token string">"Bruce"</span><span class="token punctuation">,</span><span class="token string">"Steve"</span><span class="token punctuation">,</span><span class="token string">"Adrian"</span><span class="token punctuation">,</span> <span class="token string">"Dave"</span><span class="token punctuation">,</span> <span class="token string">"Janick"</span><span class="token punctuation">,</span> null<span class="token punctuation">)</span><span class="token punctuation">;</span></code></pre><p>아래는 불변 List를 만드는 예제입니다.</p><pre class=" language-java"><code class="language-java">List<span class="token operator">&lt;</span>String<span class="token operator">></span> band <span class="token operator">=</span> List<span class="token punctuation">.</span><span class="token function">of</span><span class="token punctuation">(</span><span class="token string">"Bruce"</span><span class="token punctuation">,</span><span class="token string">"Steve"</span><span class="token punctuation">,</span><span class="token string">"Adrian"</span><span class="token punctuation">,</span> <span class="token string">"Dave"</span><span class="token punctuation">,</span> <span class="token string">"Janick"</span><span class="token punctuation">,</span><span class="token string">"Nicko"</span><span class="token punctuation">)</span><span class="token punctuation">;</span></code></pre><h3 id="Set"><a href="#Set" class="headerlink" title="Set"></a>Set</h3><p><code>ist</code> 인터페이스와 비슷하게 구현되며. 추상 기본 클래스  <code>AbstractImmutableSet&lt;E&gt;</code> 와 네 가지 구현이 있습니다.</p><ul><li><code>Set0&lt;E&gt;</code> </li><li><code>Set1&lt;E&gt;</code> </li><li><code>Set2&lt;E&gt;</code> </li><li><code>SetN&lt;E&gt;</code> </li></ul><p><code></code>java.util.List` 인터페이스에는 위의 구현을 사용하여 불변의 객체를 생성하는 12가지 정적 팩토리 메소드가 있습니다.</p><p>내용을 불변하는것 외에도  <code>null</code> 값의 유효성도 체크합니다. 아래의 코드는 <code>NullPointerException</code>이 발생합니다.</p><pre class=" language-java"><code class="language-java">Set<span class="token operator">&lt;</span>String<span class="token operator">></span> band <span class="token operator">=</span> Set<span class="token punctuation">.</span><span class="token function">of</span><span class="token punctuation">(</span><span class="token string">"Bruce"</span><span class="token punctuation">,</span><span class="token string">"Steve"</span><span class="token punctuation">,</span><span class="token string">"Adrian"</span><span class="token punctuation">,</span> <span class="token string">"Dave"</span><span class="token punctuation">,</span> <span class="token string">"Janick"</span><span class="token punctuation">,</span> null<span class="token punctuation">)</span><span class="token punctuation">;</span></code></pre><p>List와 다른 점은 중복된 값을 넣으려고 하면 <code>IllegalArgumentException</code>이 발생합니다.</p><pre class=" language-java"><code class="language-java">Set<span class="token operator">&lt;</span>String<span class="token operator">></span> guitarists <span class="token operator">=</span> Set<span class="token punctuation">.</span><span class="token function">of</span><span class="token punctuation">(</span><span class="token string">"Adrian"</span><span class="token punctuation">,</span> <span class="token string">"Dave"</span><span class="token punctuation">,</span> <span class="token string">"Janick"</span><span class="token punctuation">,</span> <span class="token string">"Janick"</span><span class="token punctuation">)</span><span class="token punctuation">;</span></code></pre><p>아래는 불변 Set을 만드는 예제입니다.</p><pre class=" language-java"><code class="language-java">Set<span class="token operator">&lt;</span>String<span class="token operator">></span> band <span class="token operator">=</span> Set<span class="token punctuation">.</span><span class="token function">of</span><span class="token punctuation">(</span><span class="token string">"Bruce"</span><span class="token punctuation">,</span><span class="token string">"Steve"</span><span class="token punctuation">,</span><span class="token string">"Adrian"</span><span class="token punctuation">,</span> <span class="token string">"Dave"</span><span class="token punctuation">,</span> <span class="token string">"Janick"</span><span class="token punctuation">,</span><span class="token string">"Nicko"</span><span class="token punctuation">)</span><span class="token punctuation">;</span></code></pre><h3 id="Map"><a href="#Map" class="headerlink" title="Map"></a>Map</h3><p>불변의 객체를  <code>java.util.Map</code> 인터페이스의 static 팩토리 메소드를 사용하여 만들 수 있습니다. .</p><pre class=" language-java"><code class="language-java"><span class="token keyword">static</span> <span class="token operator">&lt;</span>K<span class="token punctuation">,</span> V<span class="token operator">></span> Entry<span class="token operator">&lt;</span>K<span class="token punctuation">,</span> V<span class="token operator">></span> <span class="token function">entry</span><span class="token punctuation">(</span>K k<span class="token punctuation">,</span> V v<span class="token punctuation">)</span></code></pre><p>불변의 <code>Map</code>에는 <code>AbstractImmutableMap&lt;K, V&gt;</code> 3 개의 구현을 가지는 추상 기본 클래스가 있습니다   .</p><ul><li><code>Map0&lt;K, V&gt;</code></li><li><code>Map1&lt;K, V&gt;</code></li><li><code>MapN&lt;K, V&gt;</code></li></ul><p><code>java.util.Map</code> 인터페이스 내부에는 다음과 같은 팩토리 메소드가  있습니다.</p><pre class=" language-java"><code class="language-java"><span class="token keyword">static</span> <span class="token operator">&lt;</span>K<span class="token punctuation">,</span> V<span class="token operator">></span> Map<span class="token operator">&lt;</span>K<span class="token punctuation">,</span> V<span class="token operator">></span> <span class="token function">of</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token keyword">static</span> <span class="token operator">&lt;</span>K<span class="token punctuation">,</span> V<span class="token operator">></span> Map<span class="token operator">&lt;</span>K<span class="token punctuation">,</span> V<span class="token operator">></span> <span class="token function">of</span><span class="token punctuation">(</span>K k1<span class="token punctuation">,</span> V v1<span class="token punctuation">)</span><span class="token keyword">static</span> <span class="token operator">&lt;</span>K<span class="token punctuation">,</span> V<span class="token operator">></span> Map<span class="token operator">&lt;</span>K<span class="token punctuation">,</span> V<span class="token operator">></span> <span class="token function">of</span><span class="token punctuation">(</span>K k1<span class="token punctuation">,</span> V v1<span class="token punctuation">,</span> K k2<span class="token punctuation">,</span> V v2<span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token keyword">static</span> <span class="token operator">&lt;</span>K<span class="token punctuation">,</span> V<span class="token operator">></span> Map<span class="token operator">&lt;</span>K<span class="token punctuation">,</span> V<span class="token operator">></span> <span class="token function">of</span><span class="token punctuation">(</span>K k1<span class="token punctuation">,</span> V v1<span class="token punctuation">,</span> K k2<span class="token punctuation">,</span> V v2<span class="token punctuation">,</span> K k3<span class="token punctuation">,</span> V v3<span class="token punctuation">,</span> K k4<span class="token punctuation">,</span> V v4<span class="token punctuation">,</span>                           K k5<span class="token punctuation">,</span> V v5<span class="token punctuation">,</span> K k6<span class="token punctuation">,</span> V v6<span class="token punctuation">,</span> K k7<span class="token punctuation">,</span> V v7<span class="token punctuation">,</span> K k8<span class="token punctuation">,</span> V v8<span class="token punctuation">,</span>                            K k9<span class="token punctuation">,</span> V v9<span class="token punctuation">,</span> K k10<span class="token punctuation">,</span> V v10<span class="token punctuation">)</span><span class="token keyword">static</span> <span class="token operator">&lt;</span>K<span class="token punctuation">,</span> V<span class="token operator">></span> Map<span class="token operator">&lt;</span>K<span class="token punctuation">,</span> V<span class="token operator">></span> <span class="token function">ofEntries</span><span class="token punctuation">(</span>Entry<span class="token operator">&lt;</span><span class="token operator">?</span> <span class="token keyword">extends</span> <span class="token class-name">K</span><span class="token punctuation">,</span> <span class="token operator">?</span> <span class="token keyword">extends</span> <span class="token class-name">V</span><span class="token operator">></span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span> entries<span class="token punctuation">)</span></code></pre><p><code>List</code>와 <code>Set</code>과는 다르게 최대 10개의 요소를 포함하는 불변 객체를 만들 수 있습니다.</p><p>아래의 메소드를 사용하면 <code>UnsupportedOperationException</code>가 발생합니다.</p><pre class=" language-java"><code class="language-java"><span class="token keyword">void</span> <span class="token function">clear</span><span class="token punctuation">(</span><span class="token punctuation">)</span>V <span class="token function">compute</span><span class="token punctuation">(</span>K key<span class="token punctuation">,</span> BiFunction<span class="token operator">&lt;</span><span class="token operator">?</span> <span class="token keyword">super</span> K<span class="token punctuation">,</span><span class="token operator">?</span> <span class="token keyword">super</span> V<span class="token punctuation">,</span><span class="token operator">?</span> <span class="token keyword">extends</span> <span class="token class-name">V</span><span class="token operator">></span> rf<span class="token punctuation">)</span>V <span class="token function">computeIfAbsent</span><span class="token punctuation">(</span>K key<span class="token punctuation">,</span> Function<span class="token operator">&lt;</span><span class="token operator">?</span> <span class="token keyword">super</span> K<span class="token punctuation">,</span><span class="token operator">?</span> <span class="token keyword">extends</span> <span class="token class-name">V</span><span class="token operator">></span> mf<span class="token punctuation">)</span>V <span class="token function">computeIfPresent</span><span class="token punctuation">(</span>K key<span class="token punctuation">,</span> BiFunction<span class="token operator">&lt;</span><span class="token operator">?</span> <span class="token keyword">super</span> K<span class="token punctuation">,</span><span class="token operator">?</span> <span class="token keyword">super</span> V<span class="token punctuation">,</span><span class="token operator">?</span> <span class="token keyword">extends</span> <span class="token class-name">V</span><span class="token operator">></span> rf<span class="token punctuation">)</span>V <span class="token function">merge</span><span class="token punctuation">(</span>K key<span class="token punctuation">,</span> V value<span class="token punctuation">,</span> BiFunction<span class="token operator">&lt;</span><span class="token operator">?</span> <span class="token keyword">super</span> V<span class="token punctuation">,</span><span class="token operator">?</span> <span class="token keyword">super</span> V<span class="token punctuation">,</span><span class="token operator">?</span> <span class="token keyword">extends</span> <span class="token class-name">V</span><span class="token operator">></span> rf<span class="token punctuation">)</span>V <span class="token function">put</span><span class="token punctuation">(</span>K key<span class="token punctuation">,</span> V value<span class="token punctuation">)</span><span class="token keyword">void</span> <span class="token function">putAll</span><span class="token punctuation">(</span>Map<span class="token operator">&lt;</span><span class="token operator">?</span> <span class="token keyword">extends</span> <span class="token class-name">K</span><span class="token punctuation">,</span><span class="token operator">?</span> <span class="token keyword">extends</span> <span class="token class-name">V</span><span class="token operator">></span> m<span class="token punctuation">)</span>V <span class="token function">putIfAbsent</span><span class="token punctuation">(</span>K key<span class="token punctuation">,</span> V value<span class="token punctuation">)</span>V <span class="token function">remove</span><span class="token punctuation">(</span>Object key<span class="token punctuation">)</span><span class="token keyword">boolean</span> <span class="token function">remove</span><span class="token punctuation">(</span>Object key<span class="token punctuation">,</span> Object value<span class="token punctuation">)</span>V <span class="token function">replace</span><span class="token punctuation">(</span>K key<span class="token punctuation">,</span> V value<span class="token punctuation">)</span><span class="token keyword">boolean</span> <span class="token function">replace</span><span class="token punctuation">(</span>K key<span class="token punctuation">,</span> V oldValue<span class="token punctuation">,</span> V newValue<span class="token punctuation">)</span><span class="token keyword">void</span> <span class="token function">replaceAll</span><span class="token punctuation">(</span>BiFunction<span class="token operator">&lt;</span><span class="token operator">?</span> <span class="token keyword">super</span> K<span class="token punctuation">,</span><span class="token operator">?</span> <span class="token keyword">super</span> V<span class="token punctuation">,</span><span class="token operator">?</span> <span class="token keyword">extends</span> <span class="token class-name">V</span><span class="token operator">></span> f<span class="token punctuation">)</span></code></pre><p>불변의 <code>Map</code>을 만드는 것과 상관 없이 Key,Value또는 전체 요소가 null인 경우에는 인스턴스화 할 수 없습니다. 아래의 예제들은 <code>NullPointer</code>를 던지는 코드입니다.</p><pre class=" language-java"><code class="language-java">Map<span class="token operator">&lt;</span>String<span class="token punctuation">,</span> Long<span class="token operator">></span> age <span class="token operator">=</span> Map<span class="token punctuation">.</span><span class="token function">of</span><span class="token punctuation">(</span>null<span class="token punctuation">,</span> 59L<span class="token punctuation">,</span> <span class="token string">"Steve"</span><span class="token punctuation">,</span> 61L<span class="token punctuation">)</span><span class="token punctuation">;</span>Map<span class="token operator">&lt;</span>String<span class="token punctuation">,</span> Long<span class="token operator">></span> age <span class="token operator">=</span> Map<span class="token punctuation">.</span><span class="token function">of</span><span class="token punctuation">(</span><span class="token string">"Bruce"</span><span class="token punctuation">,</span> null<span class="token punctuation">,</span> <span class="token string">"Steve"</span><span class="token punctuation">,</span> 61L<span class="token punctuation">)</span><span class="token punctuation">;</span>Map<span class="token operator">&lt;</span>String<span class="token punctuation">,</span> Long<span class="token operator">></span> age <span class="token operator">=</span> Map<span class="token punctuation">.</span><span class="token function">ofEntries</span><span class="token punctuation">(</span>Map<span class="token punctuation">.</span><span class="token function">entry</span><span class="token punctuation">(</span><span class="token string">"Bruce"</span><span class="token punctuation">,</span> 59L<span class="token punctuation">)</span><span class="token punctuation">,</span> null<span class="token punctuation">)</span><span class="token punctuation">;</span></code></pre><p>중복값을 가지는 Map을 생성하면 <code>IllegalArgumentException</code>가 발생합니다.</p><pre class=" language-java"><code class="language-java">Map<span class="token operator">&lt;</span>String<span class="token punctuation">,</span> Long<span class="token operator">></span> age <span class="token operator">=</span> Map<span class="token punctuation">.</span><span class="token function">of</span><span class="token punctuation">(</span><span class="token string">"Bruce"</span><span class="token punctuation">,</span> 59L<span class="token punctuation">,</span> <span class="token string">"Bruce"</span><span class="token punctuation">,</span> 59L<span class="token punctuation">)</span><span class="token punctuation">;</span>Map<span class="token operator">&lt;</span>String<span class="token punctuation">,</span> Long<span class="token operator">></span> age <span class="token operator">=</span> Map<span class="token punctuation">.</span><span class="token function">ofEntries</span><span class="token punctuation">(</span>Map<span class="token punctuation">.</span><span class="token function">entry</span><span class="token punctuation">(</span><span class="token string">"Bruce"</span><span class="token punctuation">,</span> 59L<span class="token punctuation">)</span><span class="token punctuation">,</span>                                      Map<span class="token punctuation">.</span><span class="token function">entry</span><span class="token punctuation">(</span><span class="token string">"Bruce"</span><span class="token punctuation">,</span> 59L<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span></code></pre><p>아래는 불변 Map을 만드는 예제입니다.</p><pre class=" language-java"><code class="language-java">Map<span class="token operator">&lt;</span>String<span class="token punctuation">,</span> Long<span class="token operator">></span> age <span class="token operator">=</span> Map<span class="token punctuation">.</span><span class="token function">of</span><span class="token punctuation">(</span><span class="token string">"Bruce"</span><span class="token punctuation">,</span> 59L<span class="token punctuation">,</span> <span class="token string">"Steve"</span><span class="token punctuation">,</span> 61L<span class="token punctuation">,</span> <span class="token string">"Dave"</span><span class="token punctuation">,</span> 60L<span class="token punctuation">,</span>                               <span class="token string">"Adrian"</span><span class="token punctuation">,</span> 60L<span class="token punctuation">,</span> <span class="token string">"Janick"</span><span class="token punctuation">,</span> 60L<span class="token punctuation">,</span> <span class="token string">"Nicko"</span><span class="token punctuation">,</span> 65L<span class="token punctuation">)</span><span class="token punctuation">;</span>Map<span class="token operator">&lt;</span>String<span class="token punctuation">,</span> Long<span class="token operator">></span> age <span class="token operator">=</span> Map<span class="token punctuation">.</span><span class="token function">ofEntries</span><span class="token punctuation">(</span>Map<span class="token punctuation">.</span><span class="token function">entry</span><span class="token punctuation">(</span><span class="token string">"Bruce"</span><span class="token punctuation">,</span> 59L<span class="token punctuation">)</span><span class="token punctuation">,</span>                                      Map<span class="token punctuation">.</span><span class="token function">entry</span><span class="token punctuation">(</span><span class="token string">"Steve"</span><span class="token punctuation">,</span> 61L<span class="token punctuation">)</span><span class="token punctuation">,</span>                                      Map<span class="token punctuation">.</span><span class="token function">entry</span><span class="token punctuation">(</span><span class="token string">"Dave"</span><span class="token punctuation">,</span> 60L<span class="token punctuation">)</span><span class="token punctuation">,</span>                                      Map<span class="token punctuation">.</span><span class="token function">entry</span><span class="token punctuation">(</span><span class="token string">"Adrian"</span><span class="token punctuation">,</span> 60L<span class="token punctuation">)</span><span class="token punctuation">,</span>                                      Map<span class="token punctuation">.</span><span class="token function">entry</span><span class="token punctuation">(</span><span class="token string">"Janick"</span><span class="token punctuation">,</span> 60L<span class="token punctuation">)</span><span class="token punctuation">,</span>                                      Map<span class="token punctuation">.</span><span class="token function">entry</span><span class="token punctuation">(</span><span class="token string">"Nicko"</span><span class="token punctuation">,</span> 65L<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span></code></pre><h3 id="결론"><a href="#결론" class="headerlink" title="결론"></a>결론</h3><p>편리하게 불변의 객체를 만들 수 있고 Null과 중복 삽입을 사전에 방지할 수 있는 유용한 기능입니다.</p><h2 id="Reactive-Streams"><a href="#Reactive-Streams" class="headerlink" title="Reactive Streams"></a>Reactive Streams</h2><p>Java 9 에서 Reactive Streams API가 추가되었습니다.</p><ul><li>Reactive Streams 추가<ul><li>publish-subscribe 프레임 워크를 지원하는 인터페이스</li></ul></li><li>reactive stream API <ul><li>java.util.concurrent.Flow</li><li>java.util.concurrent.Flow.Publisher</li><li>java.util.concurrent.Flow.Subscription</li><li>java.util.concurrent.Flow.Subscriber</li><li>java.util.concurrent.Flow.Processor</li></ul></li></ul><p>리액티브 프로그래밍이란 무엇일까요?<br>많은 응용 프로그램에서 데이터는 거의 실시간으로 처리됩니다. 대부분의 경우  데이터가 있을 때를  미리 알 수 없습니다. 이러한 비동기식 데이터 처리를 용이하게하기 위해  능률적인 방법을 사용해야합니다.</p><p>Flow API (및 Reactive Streams API)는 Iterator 및 Observer 패턴의 아이디어를 조합 한 것으로 볼 수 있습니다.</p><p>자세한 내용은 <a href="https://ahea.wordpress.com/2017/02/02/iterable%ec%99%80-observable%ec%9d%98-%ea%b0%9c%eb%85%90/" target="_blank" rel="noopener">여기서</a> 확인할 수 있습니다.</p><p><img src="/images/java9/flow.png" alt=""></p><p>Reactive Streams 인터페이스의 표준 Java 소스는 java.util.concurrent.Flow 클래스에 있으며 Flow클래스 내에 정적 인터페이스로 제공됩니다 . JavaDoc이 제거되면 Flow클래스는 다음과 같이 정의됩니다.<br>Observer패턴에서 문제가 있다는 부분이 onError와 onComplete로 해결됩니다.에러가 난다면 onError, 다 끝났다면 onComplete가 호출됩니다.<br>리 액티브 스트림은 (1) 게시자, (2) 구독자, (3) 구독 및 (4) 프로세서의 네 가지 기본 엔터티로 구성됩니다.</p><h3 id="게시자-Publishers-구독자-Subscriber"><a href="#게시자-Publishers-구독자-Subscriber" class="headerlink" title="게시자(Publishers), 구독자(Subscriber)"></a>게시자(Publishers), 구독자(Subscriber)</h3><p><img src="/images/java9/ReactiveStreams_1.png" alt=""></p><p>게시자, 구독자 및 구독(Publishers, Subscribers, and Subscriptions) 의 구조에 대해 알아보겠습니다.<br>Reactive Programming 모델에는 게시자와 구독자가 있습니다. 게시자는 구독자가 비동기 적으로 구독하는 데이터 스트림을 게시합니다.<br>게시자와 구독자 간의 양방향 연결을 <strong>구독</strong>이라고합니다.<br>구독자가 게시자를 구독하면 게시자는 구독을 구독자에게 알리고 구독자가 구독에 대한 참조를 저장할 수있게합니다. 이 통지 프로세스가 완료되면 구독자는 게시자에게 항목을 받을 준비가 되었음을 알릴 수 있습니다</p><p><img src="/images/java9/subscriber.png" alt=""></p><p>그중에서 게시자와 구독자에 대한 예제를 통해 간단히 살펴보겠습니다.<br>onSubscribe는 최초 1번만 호출되는 메소드onNext는 기존 Observer에서 update와 같은 역활<br>Java 버전에는 게시자 구현이 포함되어 SubmissionPublisher있습니다. 이 SubmissionPublisher클래스는 submit(T item)메서드를 사용하여 구독자에게 푸시 할 항목을 허용하는 단순한 게시자 역할을합니다 . 항목이 submit 메서드에 제출 되면 다음과 같이 구독자에게 비동기 적으로 푸시됩니다.<br>구독이 설정되면 값 0을 9게시자에게 제출 하고 구독자에게 값을 비동기 적으로 푸시합니다. 그런 다음 구독자는 값을 표준 출력하고 각 항목을 처리하고 다른 값을 받아 들일 준비가되었음을 구독에 알립니다. 그런 다음 비동기 전송이 완료 될 수 있도록 1 초 동안 주 스레드를 일시 중지합니다. 이 submit 메서드는 제출 된 항목을 구독자에게 푸시합니다.<br>아래 그림과 같이 출력되는것을 확인할 수 있습니다.</p><p><img src="/images/java9/subscriber2.png" alt=""></p><h3 id="프로세서-Processor"><a href="#프로세서-Processor" class="headerlink" title="프로세서(Processor)"></a><strong>프로세서(Processor)</strong></h3><p><img src="/images/java9/ReactiveStreams_3.png" alt=""></p><p>엔터티가 게시자와 구독자 인 경우 이를 프로세서 라고합니다 . 프로세서는 일반적으로 다른 게시자와 구독자 (둘 중 하나가 다른 프로세서 일 수 있음) 간의 중개자 역할을하여 데이터 스트림에서 일부 변형을 수행합니다.<br>예를 들어 구독자로 전달하기 전에 일부 조건과 일치하는 항목을 필터링하는 프로세서를 만들 수 있습니다. 프로세서의 시각적 표현은 그림과 같습니다.</p><p><img src="/images/java9/processer.png" alt=""></p><p><img src="/images/java9/processer1.png" alt=""></p><p>프로세서를 추가하는 예제입니다.프로세서는 구독자로 전달하기 전에 항목을 필터링할 수 있다고 말씀 드렸습니다.소스를 보시면 onNext메소드에서 넘겨온 item필드에 대해 10씩 증가하였습니다.<br>프로세서를 추가하는 방법은 프로세서 객체를 생성 후 구독자를 추가합니다.</p><p><img src="/images/java9/processer2.png" alt="img"></p><p>10씩 증가되서 출력된 부분을 확인하실 수 있으며 프로세서가 먼저 종료 된것을 확인 할 수 있습니다.</p><h2 id="Project-Jigsaw"><a href="#Project-Jigsaw" class="headerlink" title="Project Jigsaw"></a><strong>Project Jigsaw</strong></h2><p><img src="/images/java9/module.png" alt=""></p><p>Java9에서 크게 달라진점 중 하나인 모듈 시스템으로 자신만의 모듈을 만들수 있습니다</p><p>Java 플랫폼의 모듈화와 일반 모듈 시스템의 도입 인 Project Jigsaw는 Java 9에 포함되었습니다. java9에서 적용된 모듈에 대해 알아보겠습니다.모듈화는 구성 요소 간의 느슨한 커플 링 구성 요소 간의 종속성을 명확히하고강력한 캡슐화를 사용한 숨겨진 구현을 하는 것을달성하는 데 도움이되는 설계 원칙입니다. </p><p><img src="/images/java9/module_JAVA8.png" alt=""></p><p><img src="/images/java9/module_JAVA9.png" alt=""></p><p>Java Home 폴더에 bin, jre, lib 등의 디렉토리를 볼 수 있습니다. JDK 9에는 JRE가 포함되어 있지 않습니다.  JDK 9에서는 JRE가 별도의 배포 폴더로 분리됩니다. JDK 9 소프트웨어에는 “jmods”라는 새 폴더가 있습니다.  Java 9 모듈 집합을 포함합니다. JDK 9에서는 rt.jar이없고 Tools.jar이 없습니다.</p><h3 id="Module-System이-필요한-이유"><a href="#Module-System이-필요한-이유" class="headerlink" title="Module System이 필요한 이유"></a><strong>Module System이 필요한 이유</strong></h3><p>왜 모듈성이 필요한가? </p><ul><li>작은 장치가 불필요하게 전체 JDK를 실행하지 않도록합니다.</li><li>작은 컴퓨터 디바이스에서 경량화하여 효과적으로 사용해야합니다. </li><li>캡슐화시 결함을 제거합니다. Java 9에서는 기본적으로 모든 패키지는 모듈 비공개이기 때문에 public 선언으로 module-info.java로 반출되지 않으면 더 이상 볼 수 없습니다. 의존성 (컴파일 시간과 런타임 모두)을 검사합니다. 리플렉션을 사용해도 런타임 때 액세스 할 수 없습니다. </li></ul><p>모듈화는 언어 레벨에서 모듈간의 의존성을 알 수 있으니 애플리케이션이 사용하는 모듈만 모아서 런타임 환경(이미지)를 만들 수 있습니다.필요한 모듈만으로 경량화된 이미지를 만들기 위함입니다</p><h3 id="Module화-된-JDK"><a href="#Module화-된-JDK" class="headerlink" title="Module화 된 JDK"></a><strong>Module화 된 JDK</strong></h3><p>모듈화 된 JDK를 구조를 살펴보겠습니다.그래프 하단에 java.base가 있습니다. 생성하는 모든 모듈 은 java.lang.Object 의 암시적인 확장과 유사하게 선언 여부에 관계없이 java.base를 읽습니다<br>JDK의 모듈화는 사용하려는 Java Runtime의 모듈을 지정할 수 있음을 의미합니다.</p><h2 id="Private-Interface-Method"><a href="#Private-Interface-Method" class="headerlink" title="Private Interface Method"></a><strong>Private Interface Method</strong></h2><p><img src="/images/java9/private-method.png" alt=""></p><p>JAVA8 에서는 특정 기능을 처리하는 내부method 일뿐인데도 외부에 공개되는 public method 로 만들어야 하는 단점을 가지고 있었습니다그러한 요구 사항과 interface를 구현하는 다른 interface 또는 class가 해당 method에 액세스하거나 상속 할수 있는것을 원하지 않는 요구사항이 있다.Java9 Private Interface Method 에서는 <strong>interface 에 private method / private static method라는 새로운 기능을 제공</strong>하여 문제를 해결한다. 이제 중복 코드를 피하고 interface에 대한 캡슐화를 유지 할 수 있다.</p><h2 id="try-with-resource-향상"><a href="#try-with-resource-향상" class="headerlink" title="try-with-resource 향상"></a><strong>try-with-resource 향상</strong></h2><p><img src="/images/java9/try1.png" alt=""></p><p><img src="/images/java9/try2.png" alt=""></p><p>기존의 java7 부터 제공된 try-with-resource 구문이 불편함이 많았습니다.Try-With-Resources 외부에서 선언 된 리소스를 사용할 수 없습니다.(JAVA7,8)final or effectively final이 적용되어 참조 변수를 구문에 바로 사용할 수 있게 되었습니다.</p><h2 id="Improve-Diamond-Operator"><a href="#Improve-Diamond-Operator" class="headerlink" title="Improve Diamond Operator"></a><strong>Improve Diamond Operator</strong></h2><p>JAVA 7 <img src="/images/java9/diamond1.png" alt=""></p><p>JAVA 9 <img src="/images/java9/diamond2.png" alt=""> </p><p>Java7 에는 코드를 보다 읽기 쉽게 만드는데 도움되는 “&lt;&gt;”(다이아몬드 연산자) Diamond Operator 라는 새로운 기능이 있었지만 <strong>익명 클래스(Anonymous Inner Class)에는 제한적</strong>이었다.<br><strong>이제는 익명 클래스에서  Diamond Operator 를 사용할수 있습니다.</strong></p><h2 id="Stream-Improvements"><a href="#Stream-Improvements" class="headerlink" title="Stream Improvements"></a><strong>Stream Improvements</strong></h2><p>Java 8에는 개발자가 일련의 객체에서 집계 연산을 수행하는 데 도움이되는 Streams가 도입되었습니다. Java 9 에서는  <strong>4가지</strong> 새로운 추가 메소드를 사용하여 Stream 에서 반복에 대한 제어를 못함에 어려운 부분이 많았던 부분을 해소했습니다.<br>기본적으로 predicate functional interface를 변수로 제공하고 있습니다.</p><h3 id="takewhile"><a href="#takewhile" class="headerlink" title="takewhile"></a>takewhile</h3><p><img src="/images/java9/takewhile.png" alt=""></p><p>takewhile은 false를 리턴 할 때까지 모든 값을 취합니다.출력된것을 보시면 빈값이 있기 전인 abc가 출력된것을 확인할 수 있습니다.</p><h3 id="dropwhile"><a href="#dropwhile" class="headerlink" title="dropwhile"></a>dropwhile</h3><p><img src="/images/java9/dropwhile.png" alt=""></p><p>dropWhile 메소드는  true를 리턴 할 때까지 시작시 모든 값을 버립니다. 지정된 조건과 일치하는 요소를 삭제 한 후에 이 스트림의 나머지 요소로 구성된 스트림을 리턴합니다.</p><h3 id="iterate"><a href="#iterate" class="headerlink" title="iterate"></a>iterate</h3><p><img src="/images/java9/iterate.png" alt=""></p><p>iterate매개 변수로 hasNext 조건자를 갖습니다. iterate 메소드는 이제 hasNext 조건자에서 false를 반환하면 루프를 중지시킵니다. 2부터 10보다 작은 수 까지 2씩 증가 시키는 예제를 만들었습니다. 2,4,6,8이 출력된것을 확인할 수 있습니다.</p><h3 id="ofNullable"><a href="#ofNullable" class="headerlink" title="ofNullable"></a>ofNullable</h3><p><img src="/images/java9/ofNullable.png" alt=""></p><p>NullPointerException을 방지하고 스트림에 대한 null 검사를 방지하기 위해 ofNullable 메서드가 도입되었습니다. 이 메소드는 단일 요소가 포함 된 순차적 스트림을 리턴하고, 그렇지 않으면 null이 아닌 경우 빈 스트림을 리턴합니다.<br>출력을 보면 값이 존재 할때는 1이 없을때는 0이 출력된것을 보실수 있습니다.</p><h2 id="Optional-class-Stream-Implementation"><a href="#Optional-class-Stream-Implementation" class="headerlink" title="Optional class Stream Implementation"></a><strong>Optional class Stream Implementation</strong></h2><p>때때로 우리는 Optional이 비어 있을 때 Optional을 반환하는 다른 액션을 실행하기를 원합니다 .  Java9에서는 Optional 클래스에 대해 세 가지 유용한 메소드를 추가하였습니다. </p><h3 id="of"><a href="#of" class="headerlink" title="of()"></a>of()</h3><p><img src="/images/java9/of.png" alt=""></p><p>of() 메소드는 orElseGet()나 orElse()와 달리 Optional 객체를 리턴하고 싶을 때 사용합니다.</p><h3 id="ifPresentOrElse"><a href="#ifPresentOrElse" class="headerlink" title="ifPresentOrElse()"></a>ifPresentOrElse()</h3><p><img src="/images/java9/ifPresentOrElse.png" alt=""></p><p>기존의 ifPresent() 메서드는 Optional 객체가 값을 담고 있을 때 처리할 때 사용했습니다. ifPresentOrElse() 메서드는 Optional 객체가 비어있을 경우 처리할 내용까지 정의할 수 있습니다.</p><h3 id="stream"><a href="#stream" class="headerlink" title="stream()"></a>stream()</h3><p><img src="/images/java9/stream.png" alt=""></p><p>Stream() 메소드는 Optional 객체를 Stream 객체로 변환하기 위해서 사용합니다.비어있는 Optonal 객체는 제외하고 이름들을 List 객체로 변환하는 코드입니다.</p><h2 id="Local-Variable-Type-Inference-JDK10"><a href="#Local-Variable-Type-Inference-JDK10" class="headerlink" title="Local-Variable Type Inference(JDK10)"></a><strong>Local-Variable Type Inference</strong>(JDK10)</h2><p>자바 9까지는 로컬 변수의 타입을 명시 적으로 언급하고 그것을 초기화하는 데 사용 된 이니셜 라이저와 호환되는지 확인해야했습니다.</p><p><img src="/images/java9/var.png" alt=""></p><p>자바10에서는로컬변수를 선언할때 타입추론을 이용하여 명시적으로 타입선언 없이도 변수를 선언할수 있게 되었습니다.<br>이 기능은 코드를 줄이는 데 도움이 될거같습니다.</p><h3 id="컴파일-오류"><a href="#컴파일-오류" class="headerlink" title="컴파일 오류"></a><strong>컴파일 오류</strong></h3><p><img src="/images/java9/varCompile.png" alt=""></p><p>변수의 타입은 컴파일시에 추론되며 나중에 변경할 수 없습니다.<br>멤버 변수, 메서드 매개 변수 형식 등에는 사용할 수 없습니다.<br>앞에서 언급했듯이, var 는 이니셜 라이저 없이null로 초기화하면 에러가 발생합니자람다 식은 명시 적 대상 유형을 필요로하므로 var을 사용할 수 없습니다. 배열 이니셜 라이저도 마찬가지입니다.</p><p>이 기능은 이니셜 라이저가있는 로컬 변수에서만 사용할 수 있습니다. </p><h3 id="잘-사용-하기"><a href="#잘-사용-하기" class="headerlink" title="잘 사용 하기"></a>잘 사용 하기</h3><p>var를 합법적으로 사용될 수있는 상황이 있지만 그렇게 하는 것이 좋지 않을 수 있는 경우가 있습니다<br>예를 들어, 코드가 읽기 어렵게 될 수있는 상황이 있습니다.</p><p><img src="/images/java9/var1.png" alt=""></p><p>여기서는 var를 합법적으로 사용하더라도 코드를 읽을 수 없게 만드는 메소드 호출에 의해 반환되는 유형을 이해하기 어렵게 됩니다.</p><p><img src="/images/java9/var2.png" alt=""></p><p>Java 7에서 소개 된 다이아몬드 연산자와 함께 사용하면 Object로 타입으로 반환됩니다. 원하는 타입의 유형으로 선언하는것이 좋습니다.</p><h2 id="참고자료"><a href="#참고자료" class="headerlink" title="참고자료"></a>참고자료</h2><ul><li><a href="http://www.publickey1.jp/2018/java101112b.gif" target="_blank" rel="noopener">http://www.publickey1.jp/2018/java101112b.gif</a></li><li><a href="https://pbs.twimg.com/media/DOGTWsrXcAA_7H8?format=jpg&amp;name=small" target="_blank" rel="noopener">https://pbs.twimg.com/media/DOGTWsrXcAA_7H8?format=jpg&amp;name=small</a></li><li><a href="https://openjdk.java.net/projects/jdk9/" target="_blank" rel="noopener">https://openjdk.java.net/projects/jdk9/</a></li><li><a href="https://dzone.com/articles/an-introduction-to-http2-support-in-java-9" target="_blank" rel="noopener">https://dzone.com/articles/an-introduction-to-http2-support-in-java-9</a></li><li><a href="https://dzone.com/articles/reactive-streams-in-java-9" target="_blank" rel="noopener">https://dzone.com/articles/reactive-streams-in-java-9</a></li><li><a href="https://www.journaldev.com/20723/java-9-reactive-streams" target="_blank" rel="noopener">https://www.journaldev.com/20723/java-9-reactive-streams</a></li><li><a href="https://openjdk.java.net/projects/jigsaw/spec/sotms/" target="_blank" rel="noopener">https://openjdk.java.net/projects/jigsaw/spec/sotms/</a></li><li><a href="https://dzone.com/articles/java-9-modularity-jigsaw" target="_blank" rel="noopener">https://dzone.com/articles/java-9-modularity-jigsaw</a></li><li><a href="https://howtoprogram.xyz/2017/10/19/java-9-http-2-client-api-example/" target="_blank" rel="noopener">https://howtoprogram.xyz/2017/10/19/java-9-http-2-client-api-example/</a></li><li><a href="https://howtodoinjava.com/java9/java9-private-interface-methods/" target="_blank" rel="noopener">https://howtodoinjava.com/java9/java9-private-interface-methods/</a></li><li><a href="https://twitter.com/java/status/928185028714160128/photo/1?ref_src=twsrc^tfw|twcamp^tweetembed|twterm^928185028714160128&amp;ref_url=https%3A%2F%2Ffuturecreator.github.io%2F2018%2F09%2F29%2Fjava-11-released%2F" target="_blank" rel="noopener">https://twitter.com/java/status/928185028714160128/photo/1?ref_src=twsrc%5Etfw%7Ctwcamp%5Etweetembed%7Ctwterm%5E928185028714160128&amp;ref_url=https%3A%2F%2Ffuturecreator.github.io%2F2018%2F09%2F29%2Fjava-11-released%2F</a></li><li><a href="https://www.journaldev.com/13106/java-9-moduleshttps://blog.codecentric.de/en/2015/11/first-steps-with-java9-jigsaw-part-1/" target="_blank" rel="noopener">https://www.journaldev.com/13106/java-9-moduleshttps://blog.codecentric.de/en/2015/11/first-steps-with-java9-jigsaw-part-1/</a></li><li><a href="https://devahea.github.io/2017/02/02/iterable-ec-99-80-observable-ec-9d-98-ea-b0-9c-eb-85-90/">https://devahea.github.io/2017/02/02/iterable-ec-99-80-observable-ec-9d-98-ea-b0-9c-eb-85-90/</a></li></ul>]]></content>
      
      
      
        <tags>
            
            <tag> java </tag>
            
            <tag> java9 </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>MQ와 amqp 프로토콜 원리에 대하여</title>
      <link href="/2019/04/22/amqp-%ED%94%84%EB%A1%9C%ED%86%A0%EC%BD%9C-%EC%9B%90%EB%A6%AC/"/>
      <url>/2019/04/22/amqp-%ED%94%84%EB%A1%9C%ED%86%A0%EC%BD%9C-%EC%9B%90%EB%A6%AC/</url>
      
        <content type="html"><![CDATA[<p>프로젝트를 하면서 rabbitmq, activemq 등 뒤에 MQ라고 붙은 단어들을 많이 들었다.</p><p>메시지 큐를 알아보기 전에 어디에서 쓰이는지 먼저 알아보자.</p><p>일단 카카오 메시징 서버 직군에서 지원 자격중에 MQ에 대한 경험이 들어가 있다.</p><p><img src="/images\amqp\1.png" alt=""></p><p><img src="/images\amqp\2.png" alt=""></p><p>엄청난 트레픽을 받는 네이버 웹툰에서도 웹 서비스 인프라 이해 쪽에</p><p><code>Message Queue</code>에 이해를 원하는 자격 요건도 볼 수 있다.</p><p><img src="/images\amqp\3.png" alt=""></p><p>두 기업에서 MQ에 대한 이해를 요구하는 사례만 봐도 Mq에 대한 이해는 선택이 아닌 필수로 이다.</p><p>기존 어떤 문제 때문에 MQ라는 개념이 도입되어야 하는지와</p><p>나아가 AMQP에 프로토콜의 이해와 Rabbit의 적용되는 원리 까지 알아보도록 하자.   </p><h3 id="rabbitmq가-필요한-이유"><a href="#rabbitmq가-필요한-이유" class="headerlink" title="rabbitmq가 필요한 이유"></a>rabbitmq가 필요한 이유<br></h3><p>기존 상태의 문제점 </p><ul><li>애플리케이션과 강하게 결합되어 있으면 db서버가 응답할 때 까지 기다려야 한다.</li><li>db 장애시 애플리케이션에도 장애가 발생한다. </li></ul><p><img src="/images\amqp\5.png" alt=""></p><p> mq 를 이용하면 애플리케이션의 의존성을 제거 할 수 있다. </p><ul><li>느슨하게 결합된 설계</li><li>애플리케이션 아키텍처는 더 이상 데이터 베이스 쓰기 성능에 영향을 받지 않는다.</li></ul><p><img src="/images\amqp\6.png" alt=""></p><ul><li>느슨하게 결합 구조의 애플리캐이션은 rabbitmq에 메시지를 발행한다.</li><li>구독하고 있는 소비자에게 메세지를 전달한다. </li><li>소비자가 처리해야할 양이 많아지면 소비자 애플리케이션의 처리량을 제어하거나 중지한다. </li></ul><ul><li>메세지를 발행하는 애플리케이션은 변동 없이 이전과 같은 방식으로 데이터를 발행한다. </li><li>rabbitmq는 소비자를 추가해서 메세지를 전달한다. </li><li>새로 추가한 소비자에게 메시지를 발행하는 애플리케이션을 수정 할 필요가 없다.</li></ul><p><img src="/images\amqp\7.png" alt=""></p>]]></content>
      
      
      <categories>
          
          <category> WEB </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Message Queue </tag>
            
            <tag> AMQP </tag>
            
            <tag> RabbitMQ </tag>
            
            <tag> MQ </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>Oracle And Index Principle</title>
      <link href="/2019/04/22/Oracle-And-Index-Principle/"/>
      <url>/2019/04/22/Oracle-And-Index-Principle/</url>
      
        <content type="html"><![CDATA[<h1 id="개발자도-알아야-할-Oracle의-원리"><a href="#개발자도-알아야-할-Oracle의-원리" class="headerlink" title="개발자도 알아야 할 Oracle의 원리"></a>개발자도 알아야 할 Oracle의 원리</h1><p>오라클의 쿼리가 느린경우 어떻게 해야 할까요???</p><p><img src="https://encrypted-tbn0.gstatic.com/images?q=tbn:ANd9GcQCTXyFwB278QdJCmLQIrbWYLPIZtMBa7txO4Txa2ao6P6YJUuh" alt="execution plan"></p><p>개발자는 실행계획을 통해 옵티마이저가 어떻게 동작하는지 확인합니다</p><p>상황에 따라 다르겠지만 Table Full Scan을 Index Scan으로 바꿔주면 훨신 빠른 결과를 만들어 낼수 있습니다</p><p>힌트를 사용하는 방법도 있겠죠</p><p>튜닝은 개발자에게 참 어려운 일입니다</p><p>대체 인덱스는 정확히 언제 걸어야 하고 힌트는 어떻게 걸어야 하는걸까요?</p><p>이번 포스팅에서는 오라클에서 테이블이 어떻게 구성되는지부터 인덱스와 힌트를 사용하면 내부적으로는 어떻게 진행되는지를 알아보려고 합니다</p><hr><h3 id="앞으로-다뤄질-내용"><a href="#앞으로-다뤄질-내용" class="headerlink" title="앞으로 다뤄질 내용"></a>앞으로 다뤄질 내용</h3><ul><li>스키마와 테이블<ul><li>테이블의 구성을 이해하고 데이터가 저장되는 방법을 이해한다</li></ul></li></ul><p><img src="https://docs.oracle.com/cd/E11882_01/server.112/e40540/img/cncpt284.gif" alt="table architecture"></p><ul><li>FullScan과 IndexScan(인덱스의 종류와 동작원리)<ul><li>인덱스의 종류</li><li>B-tree</li><li>Hash</li></ul></li></ul><p><img src="https://docs.oracle.com/cd/E11882_01/server.112/e40540/img/cncpt244.gif" alt="btree"></p><ul><li><p>나쁜 힌트 만들기    </p><ul><li>힌트의 종류</li><li>잘못사용하는 예시들</li></ul></li><li><p>인덱스 없이도 할 수 있는 오라클 튜닝</p><ul><li>컬럼 순서만으로도 빨라지는 마법 </li><li>최악의 정렬     </li></ul></li></ul>]]></content>
      
      
      
        <tags>
            
            <tag> oracle </tag>
            
            <tag> database </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>if(Spring AOP == AspectJ) → { Spring AOP에 대해 }</title>
      <link href="/2019/04/22/AOP%EC%9D%98-%EB%A7%88%EB%B2%95/"/>
      <url>/2019/04/22/AOP%EC%9D%98-%EB%A7%88%EB%B2%95/</url>
      
        <content type="html"><![CDATA[<p>스프링에서도 AOP를 제공하고 있습니다.</p><p>그게 바로 Spring AOP입니다. Spring AOP는 AspectJ의 어노테이션 방식으로 AOP를 구현할 수 있도록 구현방식을 제공하고 있습니다.</p><p>하지만, 이러한 AspectJ의 어노테이션의 AOP 구현방식 때문인지는 몰라도 개발자들이 “Spring AOP와 AspectJ는 같은 거 아니었어?” 라는 오해를 하고 있습니다.</p><p>Spring AOP와 AspectJ의 차이에 대해 명확히 인지하고 스프링에서 AOP 사용하는 것이 매우 중요합니다.</p>]]></content>
      
      
      <categories>
          
          <category> Programming </category>
          
      </categories>
      
      
        <tags>
            
            <tag> AOP </tag>
            
            <tag> Spring AOP </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>Spring WebFlux는 어떻게 적은 리소스로 많은 트래픽을 감당할까?</title>
      <link href="/2019/04/21/Spring-WebFlux%EB%8A%94-%EC%96%B4%EB%96%BB%EA%B2%8C-%EC%A0%81%EC%9D%80-%EB%A6%AC%EC%86%8C%EC%8A%A4%EB%A1%9C-%EB%A7%8E%EC%9D%80-%ED%8A%B8%EB%9E%98%ED%94%BD%EC%9D%84-%EA%B0%90%EB%8B%B9%ED%95%A0%EA%B9%8C/"/>
      <url>/2019/04/21/Spring-WebFlux%EB%8A%94-%EC%96%B4%EB%96%BB%EA%B2%8C-%EC%A0%81%EC%9D%80-%EB%A6%AC%EC%86%8C%EC%8A%A4%EB%A1%9C-%EB%A7%8E%EC%9D%80-%ED%8A%B8%EB%9E%98%ED%94%BD%EC%9D%84-%EA%B0%90%EB%8B%B9%ED%95%A0%EA%B9%8C/</url>
      
        <content type="html"><![CDATA[<h1 id="Spring-WebFlux는-어떻게-적은-리소스로-많은-트래픽을-감당할까"><a href="#Spring-WebFlux는-어떻게-적은-리소스로-많은-트래픽을-감당할까" class="headerlink" title="Spring WebFlux는 어떻게 적은 리소스로 많은 트래픽을 감당할까?"></a>Spring WebFlux는 어떻게 적은 리소스로 많은 트래픽을 감당할까?</h1><p><img src="https://3.bp.blogspot.com/-3i759KJap_U/We6baQQFc2I/AAAAAAAAfTs/0G7gLgD2BWsmVbPluFFoeGhViOafX1QqgCLcBGAs/s1600/Boot1VsBoot2.png" alt="Webflux Performance"></p><p>위 그림은 <a href="https://dzone.com/articles/raw-performance-numbers-spring-boot-2-webflux-vs-s" target="_blank" rel="noopener">DZone</a> 게시글 중 하나인 Spring WebFlux를 이용한 Boot2와 Spring MVC를 이용한 Boot1을 비교한 그래프이다.</p><p>해당 그래프에서는 두 가지 특징을 볼 수 있다.<br>첫번째로는 유저가 적을 때에는 성능에 별반 차이가 없다. 두 번째로는 유저가 늘어나면 늘어날수록 극명한 성능 차이를 보여주고 있다. 어떻게 이런 차이가 일어날 수 있을까?</p><p>본글은 아래의 구성을 가지고 있다.</p><ol><li>I/O</li><li>Event-Driven</li><li>Spring Framework</li></ol><p>먼저, 1과 2를 통해서 원리를 알아본 다음 3에서 이를 접목시켜서 위의 그래프가 나올수 있는 이유를 설명할 것이다.</p><h2 id="I-O"><a href="#I-O" class="headerlink" title="I / O"></a>I / O</h2><p><strong>Why was Spring WebFlux created?</strong></p><blockquote><p>Part of the answer is the need for a non-blocking web stack to handle concurrency with a small number of threads and scale with fewer hardware resources. – Spring Document</p></blockquote><p>핵심만 말하자면 non-blocking을 통해서 적은 수의 리소스로 동시성을 다룬다는 것이다. I/O의 원리부터 시작해서 non-blocking에 대해서도 이해해보도록 하자.</p><p><img src="https://eunhyejung.github.io/assets/contents/content02.PNG" alt="IO">사용자가 I/O 요청을 할 때 CPU가 I/O Controller에 요청을 하고 I/O Controller가 파일을 다 가져오면 그것을 Memory에 적재시키고 CPU에게 완료되었다고 알려준다. 즉 큰 그림은 CPU -&gt; I/O Controller -&gt; CPU의 형태이다. </p><p>핵심은 CPU가 I/O를 직접 가져오는 것이 아니라, 작은 CPU라고 불리는 I/O Controller가 수행한다는 이야기이다. 좀 더 나아가면 작업을 단순히 위임시키고 작업이 완료되는 동안에는 다른 일을 수행할 수 있다는 말이다. 이러한 예처럼 I/O를 처리하는데 몇 가지 방법이 있다. </p><h3 id="Blocking-I-O"><a href="#Blocking-I-O" class="headerlink" title="Blocking I/O"></a>Blocking I/O</h3><p><img src="https://img1.daumcdn.net/thumb/R1280x0/?scode=mtistory&amp;fname=http%3A%2F%2Fcfile9.uf.tistory.com%2Fimage%2F991CE83359A87B6D342482" alt="Blocking IO">가장 기본적인 I/O 모델이며 여러분들이 Spring MVC와 RDBMS를 사용하고 있으면 대부분 이 모델을 사용하고 있을 것으로 예상된다.</p><p>Application에서 I/O 요청을 한 후 완료되기 전까지는 Application이 Block이 되어 다른 작업을 수행할 수 없다. 이는 해당 자원이 효율적으로 사용되지 못하고 있음을 의미한다.</p><p>그러나 생각을 해보면 여러분들의 Application들은 Blocking 방식임에도 불구하고 마치 Block이 안된듯이 동작하는 것처럼 보인다. 이것은 여러분들이 Single Thread를 기반으로 하는 것이 아닌 Multi Thread를 기반으로 동작하기 때문이다. Block 되는 순간 다른 Thread가 동작함으로써 Block의 문제를 해소하였다. 그러나 Thread 간의 전환(Context Switching)에 드는 비용이 존재하므로 여러 개의 I/O를 처리하기 위해 여러 개의 Thread를 사용하는 것은 비효율적으로 보인다.</p><h3 id="Synchronous-Non-Blocking-I-O"><a href="#Synchronous-Non-Blocking-I-O" class="headerlink" title="Synchronous Non-Blocking I/O"></a>Synchronous Non-Blocking I/O</h3><p><img src="https://img1.daumcdn.net/thumb/R1280x0/?scode=mtistory&amp;fname=http%3A%2F%2Fcfile10.uf.tistory.com%2Fimage%2F99245C3359A87B9533B7DA" alt="Synchronous Non Blocking IO"><br>Application에서 I/O를 요청 후 바로 return되어 다른 작업을 수행하다가 특정 시간에 데이터가 준비가 다되었는지 상태를 확인한다. 데이터의 준비가 끝날 때까지 틈틈이 확인을 하다가 완료가 되었으면 종료된다.</p><p>여기서 주기적으로 체크하는 방식을 <strong>폴링(Polling)</strong> 이라고 한다. 그러나 이러한 방식은 작업이 완료되기 전까지 주기적으로 호출하기 때문에 불필요하게 자원을 사용하게 된다.</p><h3 id="Asynchronous-Non-blocking-I-O"><a href="#Asynchronous-Non-blocking-I-O" class="headerlink" title="Asynchronous Non-blocking I/O"></a>Asynchronous Non-blocking I/O</h3><p><img src="https://img1.daumcdn.net/thumb/R1280x0/?scode=mtistory&amp;fname=http%3A%2F%2Fcfile10.uf.tistory.com%2Fimage%2F99D8873359A87C3D1001BD" alt="Async Non Blocking IO"><br>I/O 요청을 한 후 Non-Blocking I/O와 마찬가지고 즉시 리턴된다. 허나, 데이터 준비가 완료되면 이벤트가 발생하여 알려주거나, 미리 등록해놓은 callback을 통해서 이후 작업이 진행된다.</p><p>이전 두 I/O의 문제였던 Blocking이나 Polling이 없기 때문에 자원을 보다 더 효율적으로 사용할 수 있다.<br>(이후로는 편의상 Non-Blocking I/O라고 하겠다.)</p><hr><p><a href="https://github.com/viviennes7/io-example/blob/master/src/test/java/com/ms/ioexample/io/IOTest.java" target="_blank" rel="noopener">Java 코드</a>를 통해서 이를 이해해보자.</p><h3 id="Blocking-I-O-1"><a href="#Blocking-I-O-1" class="headerlink" title="Blocking I/O"></a>Blocking I/O</h3><pre class=" language-java"><code class="language-java"><span class="token annotation punctuation">@Test</span><span class="token keyword">public</span> <span class="token keyword">void</span> <span class="token function">blocking</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>    <span class="token keyword">final</span> RestTemplate restTemplate <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">RestTemplate</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token keyword">final</span> StopWatch stopWatch <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">StopWatch</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    stopWatch<span class="token punctuation">.</span><span class="token function">start</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">int</span> i <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span> i <span class="token operator">&lt;</span> <span class="token number">3</span><span class="token punctuation">;</span> i<span class="token operator">++</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>        <span class="token keyword">final</span> ResponseEntity<span class="token operator">&lt;</span>String<span class="token operator">></span> response <span class="token operator">=</span>                restTemplate<span class="token punctuation">.</span><span class="token function">exchange</span><span class="token punctuation">(</span>THREE_SECOND_URL<span class="token punctuation">,</span> HttpMethod<span class="token punctuation">.</span>GET<span class="token punctuation">,</span> HttpEntity<span class="token punctuation">.</span>EMPTY<span class="token punctuation">,</span> String<span class="token punctuation">.</span><span class="token keyword">class</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token function">assertThat</span><span class="token punctuation">(</span>response<span class="token punctuation">.</span><span class="token function">getBody</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">contains</span><span class="token punctuation">(</span><span class="token string">"success"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span>    stopWatch<span class="token punctuation">.</span><span class="token function">stop</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    System<span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span>stopWatch<span class="token punctuation">.</span><span class="token function">getTotalTimeSeconds</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token punctuation">}</span></code></pre><p>Spring의 HTTP 요청 라이브러리인 <code>RestTemplate</code>을 사용하여 3초가 걸리는 API를 3번 호출하였다. 결과는 여러분도 알다시피 9.xx초가 나온다. 이유는 I/O가 요청 중일 때에는 아무 작업도 할 수 없기 때문이다.</p><h3 id="Non-Blocking-I-O"><a href="#Non-Blocking-I-O" class="headerlink" title="Non Blocking I/O"></a>Non Blocking I/O</h3><pre class=" language-java"><code class="language-java"><span class="token annotation punctuation">@Test</span><span class="token keyword">public</span> <span class="token keyword">void</span> <span class="token function">nonBlocking3</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token keyword">throws</span> InterruptedException <span class="token punctuation">{</span>    <span class="token keyword">final</span> StopWatch stopWatch <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">StopWatch</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    stopWatch<span class="token punctuation">.</span><span class="token function">start</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">int</span> i <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span> i <span class="token operator">&lt;</span> LOOP_COUNT<span class="token punctuation">;</span> i<span class="token operator">++</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>        <span class="token keyword">this</span><span class="token punctuation">.</span>webClient                <span class="token punctuation">.</span><span class="token function">get</span><span class="token punctuation">(</span><span class="token punctuation">)</span>                <span class="token punctuation">.</span><span class="token function">uri</span><span class="token punctuation">(</span>THREE_SECOND_URL<span class="token punctuation">)</span>                <span class="token punctuation">.</span><span class="token function">retrieve</span><span class="token punctuation">(</span><span class="token punctuation">)</span>                <span class="token punctuation">.</span><span class="token function">bodyToMono</span><span class="token punctuation">(</span>String<span class="token punctuation">.</span><span class="token keyword">class</span><span class="token punctuation">)</span>                <span class="token punctuation">.</span><span class="token function">subscribe</span><span class="token punctuation">(</span>it <span class="token operator">-</span><span class="token operator">></span> <span class="token punctuation">{</span>                    count<span class="token punctuation">.</span><span class="token function">countDown</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>                    System<span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span>it<span class="token punctuation">)</span><span class="token punctuation">;</span>                <span class="token punctuation">}</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span>    count<span class="token punctuation">.</span><span class="token function">await</span><span class="token punctuation">(</span><span class="token number">10</span><span class="token punctuation">,</span> TimeUnit<span class="token punctuation">.</span>SECONDS<span class="token punctuation">)</span><span class="token punctuation">;</span>    stopWatch<span class="token punctuation">.</span><span class="token function">stop</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    System<span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span>stopWatch<span class="token punctuation">.</span><span class="token function">getTotalTimeSeconds</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token punctuation">}</span></code></pre><p>WebFlux에서 제공하는 <code>WebClient</code>를 사용해서 위와 동일하게 3초가 걸리는 API를 호출하였다. for문 안의 변수인 <code>LOOP_COUNT</code>는 100으로 코드상에서 설정되어있다. 3초 걸리는 API를 100번 호출한다 하더라도 3.xx초 밖에 걸리지 않는다. 더 나아가서 <code>LOOP_COUNT</code>를 1000으로 변경하더라도 필자의 컴퓨터에서는 4.xx초 밖에 걸리지 않는다. Blocking I/O와 비교해봤을 때 정말 효율적이라고 볼 수 있다. </p><p>만약, Blocking을 위처럼 많은 요청을 동시에 처리하려면 그 만큼의 Thread이 생성되어야 한다. 그러나 이렇게 처리한다 해도 Context Swiching에 의한 오버헤드가 존재할 것이다.</p><h2 id="Event-Driven"><a href="#Event-Driven" class="headerlink" title="Event-Driven"></a>Event-Driven</h2><p>시장 조사 기관 가트너는 비즈니스 업계가 주목해야 할 2018 10대 전략기술 트렌드를 발표했고, Event-Driven가 포함되어 있다. 또한 Event-Driven을 토대로 많은 프레임워크와 라이브러리가 발전하고 있다. Spring WebFlux, Node.js, Vert.x 등이 그에 따른 예이다. 우리가 자주 접하는 기술들에 어떻게 스며들어 접목이 되었는지에 대해서 살펴보자.</p><p>Event-Driven Programming은 프로그램 실행 흐름이 이벤트(ex : 마우스 클릭, 키 누르기 또는 다른 프로그램의 메시지와 같은 사용자 작업)에 의해 결정되는 프로그래밍 패러다임이다. Event가 발생할 때 이를 감지하고 적합한 이벤트 핸들러를 사용하여 이벤트를 처리하도록 설계됐다. 순차적으로 진행되는 과거의 프로그래밍 방식과는 달리 유저에 의해 종잡을 수 없이 진행되는 GUI(Graphical User Interface)가 발전됨에 따라 Event-Driven 방식은 더욱더 많이 쓰이게 되었다. </p><p>대표적으로 우리 자주 접할 수 있는 방식은 아래와 같은 Click Event이다. </p><p><img src="http://derickbailey.com/wp-content/uploads/2015/09/edit-click.jpeg" alt="Click Event"></p><p>아래는 Java를 이용하여 Click Event를 구현한 예이다.</p><pre class=" language-java"><code class="language-java">JButton button <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">JButton</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>button<span class="token punctuation">.</span><span class="token function">addActionListener</span><span class="token punctuation">(</span><span class="token keyword">new</span> <span class="token class-name">ActionListener</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>    <span class="token annotation punctuation">@Override</span>    <span class="token keyword">public</span> <span class="token keyword">void</span> <span class="token function">actionPerformed</span><span class="token punctuation">(</span>ActionEvent e<span class="token punctuation">)</span> <span class="token punctuation">{</span>        System<span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span><span class="token string">"clicked"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span><span class="token punctuation">}</span><span class="token punctuation">)</span><span class="token punctuation">;</span></code></pre><p>물론 Lambda Expression 사용하면 아래처럼 간결하게 표현이 가능하다.</p><pre class=" language-java"><code class="language-java">JButton button <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">JButton</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>button<span class="token punctuation">.</span><span class="token function">addActionListener</span><span class="token punctuation">(</span>e <span class="token operator">-</span><span class="token operator">></span> System<span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span><span class="token string">"clicked"</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span></code></pre><p>우리는 Java 이외의 타 언어에서도 자연스럽게 <code>Listener</code>에 등록하여 Event를 구현하고 있다. 그런데 Button은 어떻게 유저에 의해 Click이 되었는지 <strong>인지</strong>할 수 있을까? 단순히 <code>Listener</code>에 등록하기만 하면 자동적으로 인지할까? </p><p>그렇지 않다. </p><p>과거로 돌아가 C언어로 키보드 Event를 핸들링하는 코드를 작성해보자.</p><pre class=" language-c"><code class="language-c"><span class="token keyword">int</span> <span class="token function">main</span><span class="token punctuation">(</span><span class="token keyword">void</span><span class="token punctuation">)</span><span class="token punctuation">{</span>    <span class="token keyword">char</span> key<span class="token punctuation">;</span>    <span class="token keyword">while</span><span class="token punctuation">(</span><span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">{</span>        key <span class="token operator">=</span> <span class="token function">getch</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>      <span class="token comment" spellcheck="true">// (1) </span>        <span class="token keyword">switch</span> <span class="token punctuation">(</span>key<span class="token punctuation">)</span> <span class="token punctuation">{</span>      <span class="token comment" spellcheck="true">// (2)</span>            <span class="token keyword">case</span> <span class="token number">1</span> <span class="token punctuation">:</span> 실행문<span class="token punctuation">;</span> <span class="token keyword">break</span><span class="token punctuation">;</span>            <span class="token keyword">case</span> <span class="token number">2</span> <span class="token punctuation">:</span> 실행문<span class="token punctuation">;</span> <span class="token keyword">break</span><span class="token punctuation">;</span>            <span class="token keyword">case</span> <span class="token number">3</span> <span class="token punctuation">:</span> 실행문<span class="token punctuation">;</span> <span class="token keyword">break</span><span class="token punctuation">;</span>            <span class="token keyword">case</span> <span class="token number">4</span> <span class="token punctuation">:</span> 실행문<span class="token punctuation">;</span> <span class="token keyword">break</span><span class="token punctuation">;</span>            <span class="token keyword">default</span> <span class="token punctuation">:</span> 실행문<span class="token punctuation">;</span> <span class="token keyword">break</span><span class="token punctuation">;</span>        <span class="token punctuation">}</span>    <span class="token punctuation">}</span>    <span class="token keyword">return</span> <span class="token number">0</span><span class="token punctuation">;</span><span class="token punctuation">}</span></code></pre><p>위 코드는 두 가지 경우로 되어있다.<br>(1) 무한루프를 돌면서 사용자에 의해 Key가 눌러지는 것을 감지한다.<br>(2) 감지된 값을 토대로 해야 할 일을 알맞은 곳에서 처리한다.</p><p>이를 일반화시켜 말하면 다음과 같다.<br>Event Loop가 돌면서 Event를 감지한 뒤 Event Handler 또는 Event Listener에게 보내서 작업을 처리한다.</p><p>Java Swing에서는 내부적으로 어떻게 Event를 처리할까?<br><img src="https://images.techhive.com/images/idge/imported/article/jvw/2003/06/jw-0606-swingworker1-100156726-orig.gif" alt="Swing"></p><p>위의 c언어로 작성한 코드와 거의 동일하지 않은가? 단지 Event Queue만 추가되었을 뿐이다. 그러나 코드는 한편 간결해졌다. </p><pre class=" language-java"><code class="language-java">JButton button <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">JButton</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>button<span class="token punctuation">.</span><span class="token function">addActionListener</span><span class="token punctuation">(</span>e <span class="token operator">-</span><span class="token operator">></span> System<span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span><span class="token string">"clicked"</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span></code></pre><p>일일이 Event를 제어했던 과거와는 달리 요즘은 이를 단순히 Listener에 행위만 등록해주면 간편하게 Event를 제어할 수 있다. 이는 Event Handle만이 관심의 대상이고 이에 집중할 수 있게 한다. 달리 말하면 Evevt Loop를 돌면서 요청을 감지하고 적합한 Handler에 위임해주는 부수적인 부분은 언어 레벨에서 처리를 해준다는 말이다.</p><p>이를 일반화하면 아래와 같은 이미지를 그릴 수 있다.<br><img src="https://deepakpol.files.wordpress.com/2015/09/event-loop.png" alt="Event-Driven"><br>Event-Driven이라는 키워드가 언급되면 위의 이미지를 기억에서 꺼내면 된다.</p><p>그리고 이러한 Event 처리는 Server에도 적합하다. 왜냐하면 HTTP Request라는 <strong>Event</strong>가 발생하기 때문이다. 그래서 Node.js, Spring WebFlux, Vert.x 등은 Event-Driven 형태로 Architecture가 구현되어있다.</p><h2 id="Spring-Framework"><a href="#Spring-Framework" class="headerlink" title="Spring Framework"></a>Spring Framework</h2><p><img src="https://spring.io/img/homepage/diagram-boot-reactor.svg" alt="Spring Model"><br>위 그림처럼 Spring은 Reactive Stack과 Servlet Stack 두 가지 형태를 제공한다. 또한 Reactive Stack은 non-blocking I/O를 이용해서 많은 양의 동시성 연결을 다룰 수 있다고 한다. 과거로 돌아가서 Servlet Stack의 문제점을 파악하고 이를 어떻게 Reactive Stack으로 해결했는지 알아보자.</p><h3 id="Spring-MVC"><a href="#Spring-MVC" class="headerlink" title="Spring MVC"></a>Spring MVC</h3><p><img src="https://img1.daumcdn.net/thumb/R1280x0/?scode=mtistory2&amp;fname=https%3A%2F%2Fk.kakaocdn.net%2Fdn%2Fp5S5V%2Fbtqwg3zeAQP%2FtNjcoOvjL3LBOIRPa7Z61k%2Fimg.png" alt="Thread Pool Model"><br>위 그림처럼 유저들로부터 HTTP 요청이 들어올 때 요청들은 Queue를 통하게 된다. Thread pool이 수용할 수 있는 수(thread pool size)의 요청까지만 동시적으로 작업이 처리되고 만약 넘게 된다면 큐에서 대기하게 된다. 즉 하나의 요청은 하나의 Thread를 요구한다. (one request per thread model)</p><p>Thread pool은 다음과 같다. Thread를 생성하는 비용이 크기 때문에 미리 생성하여 재사용함으로써 효율적으로 사용한다. 그렇다고 과도하게 많은 Thread를 생성하는 것이 아니라 서버 성능에 맞게 Thread의 최대 수치를 제한시킨다. 참고로 tomcat default thread size는 200이다. </p><p>그런데 만약 대량의 트래픽이 들어와 thread pool size를 지속적으로 초과하게 된다면 어떻게 될까?</p><p><img src="https://onacloud.co.za/wp-content/uploads/2016/07/queue-480x270.png" alt="Queue"><br>설정해놓은 thread pool size를 넘게 되면 위 그림처럼 작업이 처리될 때까지 Queue에서 계속해서 기다려야 한다. 그래서 전체의 대기시간이 늘어난다. 이런 현상을 <strong>Thread pool hell</strong>이라고 한다.</p><p>아래 사진은 Linkedin의 Thread Pool Hell 현상에 대한 그래프이다. Thread pool이 감당할 수 있는 요청수를 넘는 순간부터는 평소보다 수배나 많은 지연시간을 보여준다.<br><img src="http://image.slidesharecdn.com/theplayframeworkatlinkedin-final-130604033451-phpapp01/95/the-play-framework-at-linkedin-8-638.jpg" alt="Thread Pool Hell"><br>Thread pool이 감당할 수 있을 때까진 빠른 처리속도를 보이지만, 넘는 순간부터는 지연시간이 급격하게 늘어난다.</p><p>하나의 작업이 늦게 처리되는 부분에 대해서도 우린 고민해 볼 필요가 있다. 독자분들이 만든 코드가 보통 왜 느려지는가? 특수한 경우를 제외하면 DB, Network 등의 I/O가 일어나는 부분에서 아마 시간을 많이 소비했을 것이다. </p><p>설명했듯이 I/O 작업은 CPU가 관여하지 않는다. I/O Controller가 데이터를 읽어오고 이를 전달받을 뿐이다. 위에서 I/O를 처리하는 3가지 방식을 소개했는데 가장 효율이 좋은 방법은 마지막에 설명한 Asynchronous Non-blocking I/O이라고 하였다. Blocking 방식은 I/O Controller가 데이터를 읽는 동안 CPU가 아무 일도 할 수가 없고, Non-Blokcing방식은 polling 때문에 불필요하게 CPU를 소비한다고 했다. </p><p>Spring에서도 Non-blocking I/O를 이용해서 효율적으로 작업을 처리할 수 있는 방법을 제공한다. 그 수단이 WebFlux이다.</p><h3 id="Spring-WebFlux"><a href="#Spring-WebFlux" class="headerlink" title="Spring WebFlux"></a>Spring WebFlux</h3><p><img src="https://workwiththebest.intraway.com/wp-content/uploads/sites/4/2018/01/TRM-10-FINAL.png" alt="Webflux Event Driven"><br>위는 전반적인 WebFlux의 구조이다. 사용자들에 의해 요청이 들어오면 Event Loop를 통해서 작업이 처리가 된다. one request per thread model과의 차이점은 다수의 요청을 적은 Thread로도 커버할 수 있다.  worker thread default size는 서버의 core 개수로 설정이 되어있다. 즉 서버의 core가 4개라면 worker thread는 4개라는 말이며 이 적은 Thread를 통해서도 traffic을 감당할 수 있다. 위에서 하나의 Thread로 3초가 걸리는 API 1000개를 호출했음에도 4초밖에 안 걸렸다는 걸 상기시키면 이해에 도움이 될 것이다. 또한 비슷한 Architecture를 가진 node.js가 이미 증명을 하고 있다.</p><p>이렇듯 Non Blocking 방식을 활용하면 좀 더 효율적으로 I/O를 제어할 수 있고 성능에도 좋은 영향을 미친다. 특히나 유행하는 MSA에서는 수많은 Microservice가 거미줄처럼 서로를 네트워크를 통해서 호출하고 있다. 즉 많은 수의 Network I/O가 발생할 텐데 이를 Non Blocking I/O를 통해 좀 더 성능을 끌어올릴 수 있다.  </p><p>그러나 물론 제한된 점이 있다. WebFlux로 성능을 최대치로 끌어올리려면 모든 I/O 작업이 Non Blocking 기반으로 동작해야 된다. Blocking이 되는 곳이 있다면 안 하느니만 못한 상황이 되어버린다.<br>예를 들어 멀티코어로 가정을 해보자. 그럼 처리할 수 있는 Thread는 2개인데 Blocking이 걸리는 API를 열명 이서 동시에 호출한다면 결국엔 Spring MVC처럼 8명이 I/O 작업이 끝날 때까지 기다려야 하는 구조가 되어버리기 때문이다.</p><blockquote><p>What if you do need to use a blocking library? Both Reactor and RxJava provide the publishOn operator to continue processing on a different thread. That means there is an easy escape hatch. Keep in mind, however, that blocking APIs are not a good fit for this concurrency model. - Spring Document</p></blockquote><p>대안으로 <code>publicOn()</code>을 사용하라고 하지만 마지막 문장에서 Blocking은 이 모델에 적합하지 않다고 한다.</p><p>Java 진영에는 아쉽게도 DB connection을 non-blokcing으로 지원하는 라이브러리가 널리 보급되어 잘 사용되지는 않고 있다. 다만 <a href="https://github.com/r2dbc/r2dbc-postgresql" target="_blank" rel="noopener">R2DBC</a>처럼 개발이 진행 중인 라이브러리, 최근에 release된 <a href="https://github.com/jasync-sql/jasync-sql" target="_blank" rel="noopener">jasync sql</a> 등이 있으며, MongoDB, Redis 등의 NoSQL은 지원중이다. (피드백 주신 정상혁님 감사합니다.)<br>또한 소수의 Thread에 의해서 수많은 요청을 처리하고, 순서대로 작업이 처리되는 것이 아니라 Event에 기반하여 실타래가 엉킨 것처럼 작업이 처리되기 때문에 트래킹 하기에 힘이 들다는 문제가 있다.</p><p>그렇다면 <strong>성능이 좋으니 무조건 WebFlux를 사용해야 할까?</strong><br>지금까지 필자의 글에 혹했다면 위의 질문처럼 잘못된 생각을 할 수도 있다.<br><img src="https://3.bp.blogspot.com/-3i759KJap_U/We6baQQFc2I/AAAAAAAAfTs/0G7gLgD2BWsmVbPluFFoeGhViOafX1QqgCLcBGAs/s1600/Boot1VsBoot2.png" alt="Webflux Performance"><br>위 그림은 Spring MVC나 Spring WebFlux 둘 다 성능이 동일한 구간이 있다. 서버의 성능이 좋으면 좋아질수록 해당 구간은 더 늘어날 것이다. 그렇기에 만약 여러분의 환경이 해당 구간이라면 굳이 사용할 필요가 없다. 또한 <a href="https://docs.spring.io/spring/docs/current/spring-framework-reference/web-reactive.html#webflux-framework-choice" target="_blank" rel="noopener">Spring Document</a>에서는 동기 방식이 코드 작성, 이해, 디버깅하기 더 쉽다고 한다. 이 말은 즉 높은 생산성을 가진다는 말과 같은 것으로 보인다. 그렇기에 이해타산을 잘 따져서 선택해야 할 필요가 있다.</p><p>그리고 우리는 이제 왜 성능이 동일한 구간이 생기는 지를 알 수 있다. 저 구간은 바로 Thread Pool이 감당할 수 있을 정도의 요청이었기에 비동기적으로 잘 수행하다가 이후에는 Queue에 쌓여 점점 성능이 느려졌던 것이다.</p><p>‘Spring WebFlux는 어떻게 적은 리소스로 많은 트래픽을 감당할까?’란 궁금증을 시작으로 여기까지 왔다. 이에 대한 답은 I/O를 Non Blockkng을 이용하여 잘 사용하는 것과 Request를 Event-Driven을 통해서 효율적으로 처리하기 때문에 가능하다.</p><p>참고 자료</p><ul><li><a href="https://github.com/viviennes7/io-example" target="_blank" rel="noopener">Blocking / Non Blocking example Github</a></li><li><a href="https://docs.spring.io/spring/docs/current/spring-framework-reference/web-reactive.html#webflux-reactive-spring-web" target="_blank" rel="noopener">Web on Reactive Stack</a></li><li><a href="https://spring.io/" target="_blank" rel="noopener">Spring.IO</a></li><li><a href="https://dzone.com/articles/raw-performance-numbers-spring-boot-2-webflux-vs-s" target="_blank" rel="noopener">Dzone WebFlux Benchmarking</a></li><li><a href="https://eunhyejung.github.io/os/2018/06/29/operatingsystem-study02.html" target="_blank" rel="noopener">컴퓨터 시스템 동작원리</a></li><li><a href="http://www.techsuda.com/archives/10174" target="_blank" rel="noopener">가트너 10대 기술 트렌드</a></li><li><a href="https://news.samsung.com/kr/%EC%9A%94%EC%A6%98-%EC%A0%9C%EC%9D%BC-%ED%95%AB%ED%95%98%EB%8B%A4%EB%8A%94-%EC%9D%B4%EB%B2%A4%ED%8A%B8-%EB%93%9C%EB%A6%AC%EB%B8%90-%EB%88%84%EA%B5%AC%EB%83%90-%EB%84%8C" target="_blank" rel="noopener">요즘 제일 ‘핫’하다는 이벤트-드리븐… 누구냐, 넌! | SAMSUNG NEWSROOM</a></li><li><p><a href="https://deepakpol.wordpress.com/2015/09/29/event-driven-and-reactive-architecture/" target="_blank" rel="noopener">Event Driven and Reactive Architecture ‒ Deepak Pol’s Blog </a></p></li><li><p><a href="http://wiki.sys4u.co.kr/pages/viewpage.action?pageId=7767390" target="_blank" rel="noopener">Blocking, Non-Blocking / Synchronous, Asynchronous</a></p></li><li><a href="https://asfirstalways.tistory.com/348" target="_blank" rel="noopener">blocking, non-blocking and Async</a></li><li><a href="https://brainbackdoor.tistory.com/26" target="_blank" rel="noopener">blocking vs non-blocking / synchronous vs asynchronous </a></li><li><a href="https://www.javaworld.com/article/2073477/customize-swingworker-to-improve-swing-guis.html" target="_blank" rel="noopener">Java Swing Architecture</a></li><li><a href="https://www.slideshare.net/arawnkr/reactive-web-servlet-async-nonblocking-io-73838876" target="_blank" rel="noopener">Reactive Web - Servlet &amp; Async, Non-blocking I/O </a></li><li><a href="https://workwiththebest.intraway.com/white-paper/Testing-Reactive-Microservices-With-Spring-Webflux/" target="_blank" rel="noopener">Testing Reactive Microservices With Spring</a></li><li><p><a href="https://spring.io/blog/2019/04/12/going-reactive-with-spring-coroutines-and-kotlin-flow" target="_blank" rel="noopener">Going Reactive with Spring, Coroutines and Kotlin Flow</a></p></li><li><p><a href="https://news.samsung.com/kr/%EC%9A%94%EC%A6%98-%EC%A0%9C%EC%9D%BC-%ED%95%AB%ED%95%98%EB%8B%A4%EB%8A%94-%EC%9D%B4%EB%B2%A4%ED%8A%B8-%EB%93%9C%EB%A6%AC%EB%B8%90-%EB%88%84%EA%B5%AC%EB%83%90-%EB%84%8C" target="_blank" rel="noopener">요즘 제일 ‘핫’하다는 이벤트-드리븐… 누구냐, 넌! | SAMSUNG NEWSROOM</a></p></li><li><a href="https://deepakpol.wordpress.com/2015/09/29/event-driven-and-reactive-architecture/" target="_blank" rel="noopener">Event Driven and Reactive Architecture – Deepak Pol’s Blog</a></li><li><a href="https://dbse-teaching.github.io/isee2018-SOverS/2018/05/25/System-Design.html" target="_blank" rel="noopener">Observer Pattern</a></li><li><a href="https://asfirstalways.tistory.com/348" target="_blank" rel="noopener">blocking, non-blocking and Async</a></li><li><a href="https://brainbackdoor.tistory.com/26" target="_blank" rel="noopener">blocking vs non-blocking / synchronous vs asynchronous</a></li><li><a href="http://wiki.sys4u.co.kr/pages/viewpage.action?pageId=7767390" target="_blank" rel="noopener">http://wiki.sys4u.co.kr/pages/viewpage.action?pageId=7767390</a> </li><li><a href="https://www.slideshare.net/arawnkr/reactive-web-servlet-async-nonblocking-io-73838876" target="_blank" rel="noopener">Reactive Web - Servlet &amp; Async, Non-blocking I/O</a></li><li><a href="https://workwiththebest.intraway.com/white-paper/Testing-Reactive-Microservices-With-Spring-Webflux/" target="_blank" rel="noopener">Testing Reactive Microservices With Spring-Webflux - Work with the Best</a></li><li><a href="https://spring.io/blog/2019/04/12/going-reactive-with-spring-coroutines-and-kotlin-flow" target="_blank" rel="noopener">Going Reactive with Spring, Coroutines and Kotlin Flow</a></li></ul>]]></content>
      
      
      <categories>
          
          <category> spring </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Spring WebFlux </tag>
            
            <tag> Event Driven </tag>
            
            <tag> Reactive Programming </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>Java8 빨대 사용법.</title>
      <link href="/2019/04/20/Java8NStream/"/>
      <url>/2019/04/20/Java8NStream/</url>
      
        <content type="html"><![CDATA[<h2 id="Java-와-Stream-API"><a href="#Java-와-Stream-API" class="headerlink" title="Java 와 Stream API"></a>Java 와 Stream API</h2><p><img src="/images/stream0/java8.PNG" alt="Alt text"><br>Java8 에서 추가된 기능 중 하나인 Stream 은 왜 나오게 된 것 일까요?<br>Stream을 이용하는 간단한 예제를 보겠습니다.</p><pre class=" language-java"><code class="language-java"><span class="token keyword">for</span><span class="token punctuation">(</span><span class="token keyword">int</span> i <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span> i<span class="token operator">&lt;</span><span class="token number">100</span><span class="token punctuation">;</span> i<span class="token operator">++</span><span class="token operator">></span><span class="token punctuation">)</span><span class="token punctuation">{</span>    System<span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span>i<span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token punctuation">}</span></code></pre><p>이 코드를 stream 을 이용하면 다음과 같이 바뀝니다.</p><pre class=" language-java"><code class="language-java">IntStream<span class="token punctuation">.</span><span class="token function">range</span><span class="token punctuation">(</span><span class="token number">0</span><span class="token punctuation">,</span> <span class="token number">100</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">forEach</span><span class="token punctuation">(</span>System<span class="token punctuation">.</span>out<span class="token operator">:</span><span class="token operator">:</span>println<span class="token punctuation">)</span><span class="token punctuation">;</span></code></pre><p>한줄로 위의 For문이 변경 되었습니다. Stream을 사용 하니깐 코드도 짧아지고 너무 좋네요.<br>그렇다면, 성능적으로는 어떨까요?<br><img src="/images/stream0/streamPerformence.PNG" alt="https://blog.codefx.org/java/stream-performance/"><br>성능에 대해서는 구글링을 해보면 stream 을 사용하는 것이 성능적으로 더 떨어 진다는 결과가 많이 나왔습니다.<br>그렇다면, stream은 성능적으로 떨어지는데 왜 사용 하는 것일까요?</p><h2 id="Spring-과-Stream"><a href="#Spring-과-Stream" class="headerlink" title="Spring 과 Stream"></a>Spring 과 Stream</h2><p>Spring Data 에서는 다음과 같은 코드를 작성합니다.</p><pre class=" language-java"><code class="language-java"><span class="token annotation punctuation">@Query</span><span class="token punctuation">(</span><span class="token string">"select u from User u"</span><span class="token punctuation">)</span>Stream<span class="token operator">&lt;</span>User<span class="token operator">></span> <span class="token function">findAllByCustomQueryAndStream</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>Stream<span class="token operator">&lt;</span>User<span class="token operator">></span> <span class="token function">readAllByFirstnameNotNull</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token annotation punctuation">@Query</span><span class="token punctuation">(</span><span class="token string">"select u from User u"</span><span class="token punctuation">)</span>Stream<span class="token operator">&lt;</span>User<span class="token operator">></span> <span class="token function">streamAllPaged</span><span class="token punctuation">(</span>Pageable pageable<span class="token punctuation">)</span><span class="token punctuation">;</span></code></pre><p>스프링 프레임워크에서는 느린 Stream을 사용하고 있군요!</p><p>Stream은 대체 무엇이고 언제 어떻게 사용해야 하는것일까요?</p><p>Stream에 대해 알아보고 위와 같은 궁금증을 함께 해결해보겠습니다</p><h3 id="앞으로-다루어질-내용"><a href="#앞으로-다루어질-내용" class="headerlink" title="앞으로 다루어질 내용"></a>앞으로 다루어질 내용</h3><ul><li>stream 이란<ul><li>Sequence of elements</li><li>Source</li><li>Aggregate operations</li></ul></li><li>stream의 특징<ul><li>pipelining</li><li>internal iteration</li></ul></li><li>Parallel stream 을 통한 병렬처리</li><li>Spring 에서 Stream 사용하기</li></ul>]]></content>
      
      
      
        <tags>
            
            <tag> java </tag>
            
            <tag> java8 </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>Docker ABC</title>
      <link href="/2019/04/14/Docker-ABC/"/>
      <url>/2019/04/14/Docker-ABC/</url>
      
        <content type="html"><![CDATA[<h1 id="Docker-ABC"><a href="#Docker-ABC" class="headerlink" title="Docker ABC"></a>Docker ABC</h1><h2 id="Docker"><a href="#Docker" class="headerlink" title="Docker"></a>Docker</h2><p>컨테이너 기반의 오픈소스 가상화 플랫폼이다.<br>Solomon Hykes가 2013년 pycon에서 발표하면서 알려졌고, 2013년 3월 오픈소스로 릴리즈되었다.<br>최초에는 LXC를 이용하여 리눅스 컨테이너에 종속되었는데, 2014년 3월 v0.9에서 기본 실행 환경을 libcontainer로 대체하며 LXC를 버렸다.<br>당시 회사명은 dotCloud였는데 docker가 인기를 끌면서 2013년 10월 아예 회사이름을 Docker로 변경했다. </p><h3 id="Container"><a href="#Container" class="headerlink" title="Container"></a>Container</h3><p>시스템의 나머지 부분과 격리된 하나 이상의 프로세스 세트이다. OS 커널은 공유하며, 컨테이너 간에 격리하기 위해 런타임에 필요한 코드/설정/의존성 라이브러리 등 모든 것을 포함해서 패키징한다.</p><p><img src="https://www.redhat.com/cms/managed-files/what-is-a-container.png" alt=""></p><h3 id="Virtual-Machine"><a href="#Virtual-Machine" class="headerlink" title="Virtual Machine"></a>Virtual Machine</h3><p>하이퍼 바이저를 통해 격리된 하드웨어를 제공받아, 그 위에 OS/설정/코드/의존성 라이브러리 등 모든 것을 포함한다. </p><p><img src="https://www.ionos.com/digitalguide/fileadmin/DigitalGuide/Screenshots_2018/EN-virtual-machine.png" alt=""></p><h3 id="Container-vs-Virtual-Machine"><a href="#Container-vs-Virtual-Machine" class="headerlink" title="Container vs Virtual Machine"></a>Container vs Virtual Machine</h3><table><thead><tr><th><img src="https://www.docker.com/sites/default/files/d8/2018-11/docker-containerized-appliction-blue-border_2.png" alt=""></th><th><img src="https://www.docker.com/sites/default/files/d8/2018-11/container-vm-whatcontainer_2.png" alt=""></th></tr></thead><tbody><tr><td></td></tr></tbody></table><p>컨테이너와 VM은 유사하게 ‘리소스 격리 및 할당’이라는 이점을 갖지만, 컨테이너가 하드웨어가 아닌 운영 체제를 가상화하기 때문에 기능이 다르게 작동한다.</p><ul><li>Container<ul><li>OS 가상화 (OS를 공유)<ul><li>OS를 공유함으로써 컨테이너는 OS 풀버전을 포함하지 않아도 되기 때문에 디스크를 적게 사용하게 된다.</li><li>OS를 공유함으로써 OS 실행에 필요한 기본 메모리를 사용하지 않는다.</li><li>OS를 공유함으로써 컨테이너는 OS 를 부팅할 필요가 없기 때문에 시작/종료가 빠르다.</li><li>OS를 공유함으로써 각 컨테이너는 OS 종속성이 생긴다.</li></ul></li><li>이미지를 레이어단위로 관리<ul><li>공통 레이어를 공유함으로써 디스크를 적게 사용하게 된다.</li><li>app 배포시 기존 레이어에 증분 배포하기 때문에 빠르다.</li></ul></li></ul></li><li>Virtual Machine<ul><li>Hardware 가상화 (Hardware를 공유)<ul><li>Hardware 위에 OS 설치를 위해 OS 풀버전을 포함해야 하기 때문에 디스크를 많이 사용하게 된다.</li><li>OS가 기본적으로 CPU/Memory와 같은 자원을 일정량 필요로 하기 때문에 자원 손실이 있다.</li><li>Hardware 만을 공유하기 때문에 각 VM는 서로 다른 OS를 구축할 수 있다.</li><li>VM 단위 배포시 OS 부팅부터 시작하기 때문에 속도가 느릴 수 있다.</li></ul></li></ul></li></ul><h2 id="How"><a href="#How" class="headerlink" title="How?"></a>How?</h2><h3 id="cgroups-Control-groups"><a href="#cgroups-Control-groups" class="headerlink" title="cgroups (Control groups)"></a>cgroups (Control groups)</h3><p>프로세스들의 자원의 사용(CPU, 메모리, 디스크 입출력, 네트워크 등)을 제한하고 격리시키는 리눅스 커널 기능.<br><img src="https://jaxenter.com/wp-content/uploads/2018/01/java-in-containers-9.png" alt=""></p><h3 id="namespaces"><a href="#namespaces" class="headerlink" title="namespaces"></a>namespaces</h3><p>쉽게 생각하면 cgroups가 quantity라면 namespaces는 quality 개념이다.</p><blockquote><p>이 섹션에서는 리눅스 커널의 기능은 다루지 않을 예정입니다.</p></blockquote><p>앞으로 다루어질 내용</p><ul><li>Why? (왜 Docker를 사용하는가?)</li><li>Docker network</li><li>Docker image</li><li>Dockerfile</li></ul><p><a href="https://serverfault.com/questions/755607/why-do-we-use-a-os-base-image-with-docker-if-containers-have-no-guest-os" target="_blank" rel="noopener">Why do we use a OS Base Image with Docker if containers have no Guest OS?</a></p><p><a href="http://www.floydhilton.com/docker/2017/03/31/Docker-ContainerHost-vs-ContainerOS-Linux-Windows.html" target="_blank" rel="noopener">Understanding Docker “Container Host” vs. “Container OS” for Linux and Windows Containers</a></p>]]></content>
      
      
      <categories>
          
          <category> infra </category>
          
      </categories>
      
      
        <tags>
            
            <tag> docker </tag>
            
            <tag> container </tag>
            
            <tag> linux </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>Headless Browser란?</title>
      <link href="/2019/04/13/Headless-Browser%EB%9E%80/"/>
      <url>/2019/04/13/Headless-Browser%EB%9E%80/</url>
      
        <content type="html"><![CDATA[<h2 id="Headless-Browser란"><a href="#Headless-Browser란" class="headerlink" title="Headless Browser란?"></a>Headless Browser란?</h2><p>위키피디아에서 발췌 했습니다.</p><blockquote><p>A headless browser is a web browser without a graphical user interface.</p></blockquote><p>말 그대로 GUI환경이 아닌 브라우저를 뜻 합니다.</p><p><code>CLI(Command Line Interface)</code>에서 동작하는걸 뜻하며, 프로그래밍하기에 용이 해집니다.</p><p>2000년대 까지만 하더라도 Javascript는 Web Page에서 동적으로 보이기 위해 사용 되어졌지만 Web의 성장함으로써 Frontend진영에서 Javascript Framework가 생기고, 이를 활용하여 개발한 SPA(Single Page Application)이 활발하게 되었습니다.</p><p><img src="https://user-images.githubusercontent.com/6037055/56088632-a0bcc100-5ebf-11e9-9ed2-db36b58c6a35.png" alt="react-angular-vue"></p><p>SPA이전엔 HTTP Client(Jsoup, OKHttp)를 활용하여 Web Scraping(또는 Crawling)가능 해졌지만 Javascript를 실행해야지만 Scraping이 가능 해졌습니다.</p><p>Headless Browser의 등장으로 복잡한 인증 및 Javascript 실행으로 인해 실제 사람이 접속 하듯이 Scraping 할 수 있게 되었습니다.</p><h2 id="Http-Client와-Headless-Browser"><a href="#Http-Client와-Headless-Browser" class="headerlink" title="Http Client와 Headless Browser"></a>Http Client와 Headless Browser</h2><p>HTTP Client는 URL입력과 동시에 Html Content를 바로 불러와 속도가 빠릅니다. 그에 비해 <code>Headless Browser는 백그라운드상에서 실제 Browser가 돌기에 상대적으로 속도가 느립</code>니다. 그래도 <code>SPA접근</code>과 <code>복잡한 인증</code>을 <code>쉽게 해결</code> 가능 한데요.<br>Javascript 구동 여부는 Airbnb 페이지에서 확인 해보겠습니다.</p><p>CLI환경에서 에서 둘의 차이점을 확인 할 수 있습니다.</p><pre class=" language-bash"><code class="language-bash"><span class="token comment" spellcheck="true"># curl HttpClient로 에어비앤비 Scraping</span>curl https://www.airbnb.co.kr <span class="token operator">></span> curl-Airbnb.html</code></pre><p><img src="https://user-images.githubusercontent.com/6037055/56453086-2e445900-6377-11e9-8727-dccd79463cf2.png" alt="javascript-NoJavascript"></p><pre class=" language-bash"><code class="language-bash"><span class="token comment" spellcheck="true"># Chrome 헤드리스 모드로 에어비앤비 Scraping</span>chrome --headless --dump-dom --virtual-time-budget<span class="token operator">=</span>3000 https://www.airbnb.co.kr <span class="token operator">></span> headless-Airbnb.html</code></pre><p><img src="https://user-images.githubusercontent.com/6037055/56453083-297fa500-6377-11e9-9765-361264370b7f.png" alt="javascript-Javascript"></p><pre class=" language-bash"><code class="language-bash"><span class="token function">ls</span> -lh-rw-r--r--    1 a1004024  staff   241K Apr 13 21:50 httpclient-Airbnb.html-rw-r--r--    1 a1004024  staff   327K Apr 13 21:50 headless-Airbnb.html</code></pre><p>두개 파일의 용량을 보면 <code>HTTP Client 결과는 241K</code>이며 <code>Headless Browser의 결과는 327K</code> 였습니다.</p><p>두개의 파일을 비교 해도 가져올수 있는 데이터를 확인 할 수있었습니다.</p><table><thead><tr><th>Client</th><th>속도</th><th>인증처리</th><th>Jascript실행여부</th><th>종류</th></tr></thead><tbody><tr><td>Http Client</td><td>빠름</td><td>어려움</td><td>X</td><td>curl, wget, 그외 라이브러리들</td></tr><tr><td>Headless Browser</td><td>느림</td><td>쉬움</td><td>O</td><td>Puppeteer, Selenium, PhantomJS 등</td></tr></tbody></table><blockquote><p>Http Client를 사용가능한곳은 Http Client가 더 나은 선택 일 수 있습니다.</p></blockquote><h2 id="Headless-Browser를-통해-인증과-Scraping-네이버-카페"><a href="#Headless-Browser를-통해-인증과-Scraping-네이버-카페" class="headerlink" title="Headless Browser를 통해 인증과 Scraping(네이버 카페)"></a>Headless Browser를 통해 인증과 Scraping(네이버 카페)</h2><p>개인적으로 좋아하는 Node.js 기반 Headless Browser인 <a href="https://pptr.dev" target="_blank" rel="noopener">Puppeteer</a>를 활용한 예제를 구성 하였습니다. </p><p>실제 네이버 카페를 개설 한 후 비공개 카페의 글을 Scraping 하는 예제 입니다.</p><p>이 에제는 총 5단계의 거쳐 스크래핑을 할 예정 입니다.</p><ol><li>Headless Browser 실행</li><li>네이버 로그인</li><li>네이버 카페 게시판 접근</li><li>게시판의 게시글들의 URL 추출</li><li>추출된 게시글의 내용 추출</li></ol><p>샘플에 사용된 네이버 카페 게시판<br><img src="https://user-images.githubusercontent.com/6037055/56089853-63166300-5ed4-11e9-80c6-3ec21da2e842.png" alt="스크린샷 2019-04-14 오후 4 42 23"></p><p>Scraping 해올 게시글<br><img src="https://user-images.githubusercontent.com/6037055/56089871-95c05b80-5ed4-11e9-973b-0b5f4388b90f.png" alt="noname"></p><h3 id="1-Headless-Browser-실행"><a href="#1-Headless-Browser-실행" class="headerlink" title="1. Headless Browser 실행"></a>1. Headless Browser 실행</h3><p>npm에서 <code>puppeteer</code> 패키지를 다운 받습니다.</p><pre class=" language-bash"><code class="language-bash"><span class="token function">npm</span> i puppeteer</code></pre><p>다운 받은 패키지를 Node.js 애플리케이션 개발에 불러옵니다.</p><pre class=" language-javascript"><code class="language-javascript"><span class="token comment" spellcheck="true">// src/naver-cafe.js 파일에 작성</span><span class="token keyword">const</span> puppeteer <span class="token operator">=</span> <span class="token function">require</span><span class="token punctuation">(</span><span class="token string">'puppeteer'</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token punctuation">(</span><span class="token keyword">async</span> <span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">=</span><span class="token operator">></span> <span class="token punctuation">{</span>    <span class="token keyword">const</span> browser <span class="token operator">=</span> <span class="token keyword">await</span> puppeteer<span class="token punctuation">.</span><span class="token function">launch</span><span class="token punctuation">(</span><span class="token punctuation">{</span>headless<span class="token punctuation">:</span> <span class="token boolean">false</span><span class="token punctuation">}</span><span class="token punctuation">)</span>    <span class="token keyword">const</span> page <span class="token operator">=</span> <span class="token keyword">await</span> browser<span class="token punctuation">.</span><span class="token function">newPage</span><span class="token punctuation">(</span><span class="token punctuation">)</span>    <span class="token comment" spellcheck="true">// 2, 3, 4, 5 내용 채울 예정</span>    <span class="token keyword">await</span> browser<span class="token punctuation">.</span><span class="token function">close</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">}</span><span class="token punctuation">)</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span></code></pre><h3 id="2-네이버-로그인"><a href="#2-네이버-로그인" class="headerlink" title="2. 네이버 로그인"></a>2. 네이버 로그인</h3><p>jQuery를 사용할때 쓰던 <code>CSS Selector</code>를 통해 <code>Element에 접근</code>을 하여 원하는 작업을 진행 합니다.</p><pre class=" language-javascript"><code class="language-javascript">    <span class="token comment" spellcheck="true">// 네이버 로그인 페이지 접근</span>    <span class="token keyword">await</span> page<span class="token punctuation">.</span><span class="token function">goto</span><span class="token punctuation">(</span><span class="token string">'https://nid.naver.com/nidlogin.login?svctype=262144&amp;url=http://m.naver.com/aside/'</span><span class="token punctuation">)</span>    <span class="token comment" spellcheck="true">// 네이버 로그인</span>    <span class="token keyword">await</span> page<span class="token punctuation">.</span><span class="token function">type</span><span class="token punctuation">(</span><span class="token string">'#id'</span><span class="token punctuation">,</span> <span class="token string">'네이버 아이디'</span><span class="token punctuation">,</span> <span class="token punctuation">{</span>delay<span class="token punctuation">:</span> <span class="token number">100</span><span class="token punctuation">}</span><span class="token punctuation">)</span>    <span class="token keyword">await</span> page<span class="token punctuation">.</span><span class="token function">type</span><span class="token punctuation">(</span><span class="token string">'#pw'</span><span class="token punctuation">,</span> <span class="token string">'네이버 비밀번호'</span><span class="token punctuation">,</span> <span class="token punctuation">{</span>delay<span class="token punctuation">:</span> <span class="token number">100</span><span class="token punctuation">}</span><span class="token punctuation">)</span>    <span class="token keyword">await</span> page<span class="token punctuation">.</span><span class="token function">click</span><span class="token punctuation">(</span><span class="token string">'[type="submit"]'</span><span class="token punctuation">)</span>    <span class="token keyword">await</span> page<span class="token punctuation">.</span><span class="token function">waitForNavigation</span><span class="token punctuation">(</span><span class="token punctuation">)</span></code></pre><h3 id="3-네이버-카페-게시판-접근"><a href="#3-네이버-카페-게시판-접근" class="headerlink" title="3. 네이버 카페 게시판 접근"></a>3. 네이버 카페 게시판 접근</h3><p>Scraping을 하고 싶은 네이버 게시판의 URL로 이동 합니다.</p><pre class=" language-javascript"><code class="language-javascript">    <span class="token keyword">await</span> page<span class="token punctuation">.</span><span class="token function">goto</span><span class="token punctuation">(</span><span class="token string">'https://m.cafe.naver.com/ArticleList.nhn?search.clubid=29734529&amp;search.menuid=1&amp;search.boardtype=L'</span><span class="token punctuation">)</span></code></pre><h3 id="4-게시판의-게시글들의-URL-추출"><a href="#4-게시판의-게시글들의-URL-추출" class="headerlink" title="4. 게시판의 게시글들의 URL 추출"></a>4. 게시판의 게시글들의 URL 추출</h3><p><code>Chrome devtools</code>를 이용하여 Scraping 대상을 분석 하고 코드로 작성 하여야 합니다.<br><code>Puppeteer</code>에서 제공하는 <code>Page</code>클래스의 <code>evaluate</code>함수를 이용하면 <code>Chrome devtools console</code>에서 작업하는거와 동일하게 작업이 가능 해집니다.</p><pre class=" language-javascript"><code class="language-javascript">    <span class="token comment" spellcheck="true">// 자유게시판 글 Scraping</span>    <span class="token keyword">const</span> articles <span class="token operator">=</span> <span class="token keyword">await</span> page<span class="token punctuation">.</span><span class="token function">evaluate</span><span class="token punctuation">(</span>args <span class="token operator">=</span><span class="token operator">></span> <span class="token punctuation">{</span>        <span class="token keyword">const</span> articles <span class="token operator">=</span> <span class="token punctuation">[</span><span class="token punctuation">]</span>        document<span class="token punctuation">.</span><span class="token function">querySelectorAll</span><span class="token punctuation">(</span><span class="token string">'#articleListArea > ul li'</span><span class="token punctuation">)</span>            <span class="token punctuation">.</span><span class="token function">forEach</span><span class="token punctuation">(</span><span class="token punctuation">(</span>v<span class="token punctuation">,</span> i<span class="token punctuation">)</span> <span class="token operator">=</span><span class="token operator">></span> <span class="token punctuation">{</span>                <span class="token keyword">const</span> article <span class="token operator">=</span> <span class="token punctuation">{</span><span class="token punctuation">}</span>                article<span class="token punctuation">.</span>title <span class="token operator">=</span> v<span class="token punctuation">.</span><span class="token function">querySelector</span><span class="token punctuation">(</span><span class="token string">'.tit'</span><span class="token punctuation">)</span><span class="token punctuation">.</span>innerText                article<span class="token punctuation">.</span>nick <span class="token operator">=</span> v<span class="token punctuation">.</span><span class="token function">querySelector</span><span class="token punctuation">(</span><span class="token string">'.nick'</span><span class="token punctuation">)</span><span class="token punctuation">.</span>innerText                article<span class="token punctuation">.</span>href <span class="token operator">=</span> v<span class="token punctuation">.</span><span class="token function">querySelector</span><span class="token punctuation">(</span><span class="token string">'a._articleListItem'</span><span class="token punctuation">)</span><span class="token punctuation">.</span>href                articles<span class="token punctuation">.</span><span class="token function">push</span><span class="token punctuation">(</span>article<span class="token punctuation">)</span>            <span class="token punctuation">}</span><span class="token punctuation">)</span>        <span class="token keyword">return</span> articles    <span class="token punctuation">}</span><span class="token punctuation">)</span>    <span class="token comment" spellcheck="true">// 자유게시판 글들 확인</span>    console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span>articles<span class="token punctuation">)</span></code></pre><p>위의 작업을 실행한 결과 입니다.</p><pre class=" language-javascript"><code class="language-javascript"><span class="token punctuation">[</span> <span class="token punctuation">{</span> title<span class="token punctuation">:</span> <span class="token string">'게시글2 입니다.'</span><span class="token punctuation">,</span>    nick<span class="token punctuation">:</span> <span class="token string">'페가수스'</span><span class="token punctuation">,</span>    href<span class="token punctuation">:</span>     <span class="token string">'https://m.cafe.naver.com/ArticleRead.nhn?clubid=29734529&amp;articleid=3&amp;page=1&amp;boardtype=L&amp;menuid=1'</span> <span class="token punctuation">}</span><span class="token punctuation">,</span>  <span class="token punctuation">{</span> title<span class="token punctuation">:</span> <span class="token string">'게시글 1 입니다.'</span><span class="token punctuation">,</span>    nick<span class="token punctuation">:</span> <span class="token string">'페가수스'</span><span class="token punctuation">,</span>    href<span class="token punctuation">:</span>     <span class="token string">'https://m.cafe.naver.com/ArticleRead.nhn?clubid=29734529&amp;articleid=2&amp;page=1&amp;boardtype=L&amp;menuid=1'</span> <span class="token punctuation">}</span> <span class="token punctuation">]</span></code></pre><h3 id="5-추출된-게시글의-내용-추출"><a href="#5-추출된-게시글의-내용-추출" class="headerlink" title="5. 추출된 게시글의 내용 추출"></a>5. 추출된 게시글의 내용 추출</h3><p>추출된 각 게시글의 URL에 방문하여 게시글의 내용을 Scraping 합니다.</p><pre class=" language-javascript"><code class="language-javascript">    <span class="token keyword">const</span> articlePage <span class="token operator">=</span> <span class="token keyword">await</span> browser<span class="token punctuation">.</span><span class="token function">newPage</span><span class="token punctuation">(</span><span class="token punctuation">)</span>    <span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">let</span> article <span class="token keyword">of</span> articles<span class="token punctuation">)</span> <span class="token punctuation">{</span>        <span class="token keyword">await</span> articlePage<span class="token punctuation">.</span><span class="token function">goto</span><span class="token punctuation">(</span>article<span class="token punctuation">.</span>href<span class="token punctuation">)</span>        <span class="token keyword">const</span> content <span class="token operator">=</span> <span class="token keyword">await</span> articlePage<span class="token punctuation">.</span><span class="token function">$eval</span><span class="token punctuation">(</span><span class="token string">'#postContent'</span><span class="token punctuation">,</span> element <span class="token operator">=</span><span class="token operator">></span> element<span class="token punctuation">.</span>innerText<span class="token punctuation">)</span>        article<span class="token punctuation">.</span>content <span class="token operator">=</span> content<span class="token punctuation">;</span>    <span class="token punctuation">}</span>    <span class="token comment" spellcheck="true">// 자유게시판 글들을 내용까지 채움</span>    console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span>articles<span class="token punctuation">)</span></code></pre><p>브라우저의 새탭을 열어 아까 가져온 게시글 URL에 차례대로 방문하여 내용을 Scraping 해옵니다.</p><pre class=" language-javascript"><code class="language-javascript"><span class="token punctuation">[</span> <span class="token punctuation">{</span> title<span class="token punctuation">:</span> <span class="token string">'게시글2 입니다.'</span><span class="token punctuation">,</span>    nick<span class="token punctuation">:</span> <span class="token string">'페가수스'</span><span class="token punctuation">,</span>    href<span class="token punctuation">:</span>     <span class="token string">'https://m.cafe.naver.com/ArticleRead.nhn?clubid=29734529&amp;articleid=3&amp;page=1&amp;boardtype=L&amp;menuid=1'</span><span class="token punctuation">,</span>    content<span class="token punctuation">:</span> <span class="token string">'게시글2 입니다.\n\nABCDEFGHIJKLMNOPQRSTUVWXYZ'</span> <span class="token punctuation">}</span><span class="token punctuation">,</span>  <span class="token punctuation">{</span> title<span class="token punctuation">:</span> <span class="token string">'게시글 1 입니다.'</span><span class="token punctuation">,</span>    nick<span class="token punctuation">:</span> <span class="token string">'페가수스'</span><span class="token punctuation">,</span>    href<span class="token punctuation">:</span>     <span class="token string">'https://m.cafe.naver.com/ArticleRead.nhn?clubid=29734529&amp;articleid=2&amp;page=1&amp;boardtype=L&amp;menuid=1'</span><span class="token punctuation">,</span>    content<span class="token punctuation">:</span> <span class="token string">'게시글1의 내용입니다. \n\n가나다라마바사아자차카타파하'</span> <span class="token punctuation">}</span> <span class="token punctuation">]</span></code></pre><h2 id="마무리"><a href="#마무리" class="headerlink" title="마무리"></a>마무리</h2><p>Headless Browser란 Http Client에 비해 Javascript를 구동하여 추가 데이터를 가져 온다고 이해 하시면 좋습니다.</p><p>Node.js기반 Headless Browser인 Puppeteer를 사용한 네이버 카페 Scrping하였고, 이를 활용하면 네이버 로그인 인증도 쉽게 할 수 있고, 게시글을 사람이 직접 가져오는 방법처럼 예제를 구성 하였습니다.</p><p>소개한 예제는 Github에 공유 하겠습니다.<br>다음 순서엔 다른 Headless Browser와의 비교를 소개 하겠습니다.<br><a href="https://github.com/kji6252/study-puppeteer" target="_blank" rel="noopener">https://github.com/kji6252/study-puppeteer</a><br><a href="https://pptr.dev" target="_blank" rel="noopener">https://pptr.dev</a></p>]]></content>
      
      
      <categories>
          
          <category> WEB </category>
          
      </categories>
      
      
        <tags>
            
            <tag> HeadlessBrowser </tag>
            
            <tag> Chrome </tag>
            
            <tag> headless </tag>
            
            <tag> javascript </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>너는 사람이냐? 봇이냐?(Headless Browser)</title>
      <link href="/2019/04/13/%EB%84%88%EB%8A%94-%EC%82%AC%EB%9E%8C%EC%9D%B4%EB%83%90-%EB%B4%87%EC%9D%B4%EB%83%90-Headless-Browser/"/>
      <url>/2019/04/13/%EB%84%88%EB%8A%94-%EC%82%AC%EB%9E%8C%EC%9D%B4%EB%83%90-%EB%B4%87%EC%9D%B4%EB%83%90-Headless-Browser/</url>
      
        <content type="html"><![CDATA[<p><img src="https://user-images.githubusercontent.com/6037055/56078088-da89bb00-5e1e-11e9-80f9-2f139d96e9a6.png" alt="image"><br>Web을 통해 다양한 정보를 소비하며 쉽게 접근 할 수 있는 환경에 살고있습니다.<br>이 다양한 정보를 가지고 애플리케이션을 만들어 사용하고 싶은데 <code>Open API</code>를 제공하지 않아 곤란해 하는 경우가 많고 제대로 제공하지 않는 경우도 부지기수 입니다. </p><p><img src="https://user-images.githubusercontent.com/6037055/56088150-d78dd980-5eb5-11e9-9570-2ac8b5a3987e.png" alt="구글 뉴스 헤드라인"></p><pre class=" language-bash"><code class="language-bash"><span class="token comment" spellcheck="true"># 구글 뉴스 스크래핑</span>curl https://news.google.com/?tab<span class="token operator">=</span>wn<span class="token operator">&amp;</span>hl<span class="token operator">=</span>ko<span class="token operator">&amp;</span>gl<span class="token operator">=</span>KR<span class="token operator">&amp;</span>ceid<span class="token operator">=</span>KR:ko <span class="token operator">></span> google_news.html</code></pre><pre class=" language-html"><code class="language-html"># google_news.html 파일 내용중 일부<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>h3</span> <span class="token attr-name">class</span><span class="token attr-value"><span class="token punctuation">=</span><span class="token punctuation">"</span>ipQwMb ekueJc RD0gLb<span class="token punctuation">"</span></span><span class="token punctuation">></span></span>    <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>a</span> <span class="token attr-name">href</span><span class="token attr-value"><span class="token punctuation">=</span><span class="token punctuation">"</span>./articles/CAIiEBTOk3KYcU6RvQ0CfhFY0VUqGQgEKhAIACoHCAow2t-aCDDArqABMNST5AU?hl<span class="token punctuation">=</span>ko&amp;amp;gl<span class="token punctuation">=</span>KR&amp;amp;ceid<span class="token punctuation">=</span>KR%3Ako<span class="token punctuation">"</span></span> <span class="token attr-name">class</span><span class="token attr-value"><span class="token punctuation">=</span><span class="token punctuation">"</span>DY5T1d<span class="token punctuation">"</span></span> <span class="token punctuation">></span></span>        부산 변호사 58명 이미선 후보자 임명해야    <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>a</span><span class="token punctuation">></span></span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>h3</span><span class="token punctuation">></span></span></code></pre><p>그래서 사용하던것이 <code>HTTP Client</code>를 사용하여 Scraping을 하고 원하는 데이터를 처리하여 사용하고 있습니다.</p><p><img src="https://user-images.githubusercontent.com/6037055/56453083-297fa500-6377-11e9-9765-361264370b7f.png" alt="javascript-Javascript"><br>Web Trend의 고도화가 진행됨과 동시에 Web 개발에도 엄청난 발전이 있었는데요. <code>SPA(Single Page Application)</code>이라는 형식의 개발이 유행을 타면서 부터 많은 Site들이 SPA방식으로 제공 하고 있습니다. </p><p><img src="https://user-images.githubusercontent.com/6037055/56453086-2e445900-6377-11e9-8727-dccd79463cf2.png" alt="javascript-NoJavascript"><br>문제는 HTTP Client로 SPA에 접근할때 Javascript를 실행 하지 못해 원하는 데이터를 가져올수 없는 상황이 생깁니다.<br>그리고 로그인을 해야만 접근 가능한 Site에 로그인 인증을 어떻게 처리해야 할지 막막한 상황에도 부딫힐 수도 있고 HTTP Client로는 한계가 있어 제대로 Scraping 하기 힘들어 집니다. </p><p><img src="https://user-images.githubusercontent.com/6037055/56453226-305be700-637a-11e9-8142-068e4040e871.png" alt="HeadlessBrowser"><br>그래서 나오게 된게 <code>Headless Browser</code>이며, 실제 사람인지 봇인지 분간이 안될정도로 Headless Browser를 통해 접속하는 방식으로 Scraping을 할 수 있게 되었습니다.</p><p>Headless Browser란 무엇이며 HTTP Client와는 어떤 차이점이 있는지 Headless Browser종류와 성능에 대해 알아 볼것입니다.  </p><blockquote><p>이 섹션에서는 검색 엔진 봇은 다루지 않을 예정 입니다.</p></blockquote><p>앞으로 다루어질 내용</p><ul><li>Headless Browser란?</li><li>Puppeteer VS Selenium VS PhantomJS VS HttpClient</li><li>Headless Browser 활용 예제</li></ul>]]></content>
      
      
      <categories>
          
          <category> WEB </category>
          
      </categories>
      
      
        <tags>
            
            <tag> HeadlessBrowser </tag>
            
            <tag> Chrome </tag>
            
            <tag> headless </tag>
            
            <tag> javascript </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>MS도 오픈소스 합니다</title>
      <link href="/2018/11/08/ms-eb-8f-84-ec-98-a4-ed-94-88-ec-86-8c-ec-8a-a4-ed-95-a9-eb-8b-88-eb-8b-a4/"/>
      <url>/2018/11/08/ms-eb-8f-84-ec-98-a4-ed-94-88-ec-86-8c-ec-8a-a4-ed-95-a9-eb-8b-88-eb-8b-a4/</url>
      
        <content type="html"><![CDATA[<h1 id="Microsoft의-Github인수"><a href="#Microsoft의-Github인수" class="headerlink" title="Microsoft의 Github인수"></a>Microsoft의 Github인수</h1><p>2018년 6월 5일 Github이 Microsoft에 인수되었습니다. 약 75억 달러, 우리나라 돈으로 약 8조원에 가까운 어마어마한 금액인데요. 이 뉴스가 터지자 sns에서는 다양한 반응이 있었습니다. 흥미로웠던건 Google도 아닌 하필 Microsoft가 인수를 해서 왜 Github을 망하게 하려고 하나… 라는 부정적인 반응이 많았습니다. 많은 개발자들이 Gitlab이나 bitburket으로 망명을 하는 github이탈자들이 생기기 시작했습니다 gitlab같은 경우 github에서 gitlab으로 마이그레이션하는 동영상을 공개하며 아주 발빠르게 행동하고 있습니다 <a href="https://www.youtube.com/watch?v=VYOXuOg9tQI" target="_blank" rel="noopener">Migrating from GitHub to GitLab - YouTube</a> 깃헙에서 비트버킷으로 옮기는 10가지 이유 <a href="https://blog.bitbucket.org/2018/06/04/10-reasons-teams-switching-github-bitbucket-microsoft-acquisition/" target="_blank" rel="noopener">10 reasons why teams are switching from GitHub to Bitbucket after Microsoft acquisition | Bitbucket Blog</a> 대체 사람들은 무엇때문에 이렇게 Microsoft를 부정적인 시각으로 보는것일까요?? 이번 포스팅을 통해 조금이나마 오해를 풀고 Microsoft가 software 시장에서 펼친 긍정적인 부분을 살펴보려고 합니다</p><h1 id="Microsoft의-역사와-수익모델"><a href="#Microsoft의-역사와-수익모델" class="headerlink" title="Microsoft의 역사와 수익모델"></a>Microsoft의 역사와 수익모델</h1><p>Microsoft의 최고의 소프트웨어는 window라고 이야기해도 무방할정도로 컴퓨터의 역사에 있어 가장 중요한 역활을 한 것은 사실입니다. 가정용 컴퓨터의 역사에 있어 애플2와 같은 제품도 중요한 역활을 했지만 애플2는 너무 비쌌습니다. 이에 반해 IBM 의 호환 OS가 된 MS-DOS는 신의 한수가 된 라이센스 정책으로 인해 시장을 장악할 수 있었습니다. MS-DOS는 GUI OS인 윈도우9x에 중요한 기반이 되었고 NT기반으로 넘어오면서 xp나 7 그리고 현재의 10까지 오게 되었습니다. 여기까지 진행되면서 사실상 MS-window는 pc시장에서 90%에 가까운 독점시장을 구축했고 OS에 들어가는 간단한 소프트웨어 만으로도 자체 독점시장을 만들어내는 힘을 가지게 되었습니다(대표적으로 Internet Explorer 브라우저 독점 <a href="http://www.ddaily.co.kr/news/article.html?no=46033" target="_blank" rel="noopener">EU, MS 익스플로러 독점 시정 명령</a>) 독점에 가장 큰 영향을 준 소프트웨어는 MS-Office입니다. Ms-office는 산업, 교육 등등 다양한 분야에서 사용되는 소프트웨어로 대표적으로 사용되는 word, excel, powerpoint가 있습니다. [!<a href="http://www.mobizen.pe.kr/attach/1/1244683640.gif\]" target="_blank" rel="noopener">http://www.mobizen.pe.kr/attach/1/1244683640.gif\]</a>(ms의 수익모델) Microsoft는 sw이외에도 서버군으로도 유명합니다 대표적으로 윈도우 서버는 리눅스와 대표적으로 사용되는 서버os입니다. 윈도우 서버의 장점은 기본적으로 os를 많이 개발한 경험이 있는 microsoft의 수많은 노하우와 경험이 축적되어 있고 개인용pc의 90%가 윈도우이기 때문에 이와 함께 하는 데 있어 호환성을 무시할수 없습니다. 또 우리가 개발을 하는데 있어 기본적으로 제공되야 할것이 개발 툴인데요. Microsoft에서 가장 유명한 개발도구는 visual studio가 되겠습니다. 저는 visual studio6부터 사용을 해봤는데요. Basic, c++와 같은 대표적인 언어를 지원했으며 j++과 같이 자바를 지원하기도 했지만 sun과의 상표권 문제로 현재는 판매하지 않습니다. 현재는 2017버전까지 나와 윈도우 프로그래밍 뿐만 아니라 모바일이나 클라우드 개발까지도 쉽게 할수 있도록 지원하고 있습니다. Microsoft의 개발툴 중에 개인적으로 가장 좋았던 부분은 MSDN인데요. MSDN만 봐도 개발을 할수 있다고 할정도 방대하고 레퍼런스가 아주 잘 되어 있었던 경험이 있습니다. 여기까지는 개발자라면 MS는 찌르는것마다 잘되는 기업으로 인식할수 있지만 망한케이스가 더 많습니다. 이제부터는 망한 케이스를 몇가지 보도록 하겠습니다. 삼성전자에는 바다라는 슬픈 모바일 OS가 있습니다. 바다를 개발하려다 바다로 떠내려간다는 이야기가 있을정도로 처참한 이야기인데요. 이러한 바다보다도 점유율이 떨어지는 OS가 있습니다. 바로 윈도우 모바일인데요. 개인적으로 글쓴이의 인생에서 가장 후회되는게 있다면 바로 모바일 과도기 시절 ios도 아니고 android도 아닌 바로 윈도우 모바일에 걸고 공부를 했었다는점이 후회가 되네요.. 사실 2009년 말부터는 모바일이 시장을 변화시키고 있는 시점이기도 했습니다. 다양한 대기업에서 모바일 시장을 잡는데에 있어 플랫폼을 잡아야 한다고 생각을 했고 구글은 android, 애플의 ios, ms의 window mobile.. 이 세 기업이 모바일 시장을 주도하고 있었습니다. 그 외에도 webOS라고 해서 hp가 밀던것이 있었고 삼성에서는 바다와 타이젠을 현재까지 진행했습니다. 이때까지만 해도 모바일이라는 엄청난 시장에서 ms가 처참하게 발릴?것이라고는 생각하지 못했습니다. 윈도우는 기존에 모바일 시장이 이렇게 성장하기 전부터 임베디드 디바이스에 들어갈 윈도우ce나 포켓pc같은 pda를 위한 os를 가지고 있었습니다. 그렇기 때문에 훨신 기존 모바일 시장을 잘 알고 있었고 그렇기에 가장 선두에 올라갈 것이라고 개인적으로 생각하고 있었습니다. 윈도우 모바일은 개발자에게 아주 큰 메리트가 있었습니다. 기존 닷넷개발자나 vb개발자들이 쉽게 넘어올수 있도록 호환이 잘 되었으며 윈도우 사용자 경험을 그대로 모바일로 옮겨 놨기 때문에 쉽게 사용자가 적응할 수 있을거라고 생각했습니다. 하지만 이것은 반대효과가 났습니다. 기존에 pc window의 사용성은 모바일에 맞지 않았고 실버라이트와 같은 개발 환경은 개발자들에게 메리트를 주지 못하게 되었습니다. 이러한 상태에서 시장은 애플과 구글에게 점유됬고 제조사들은 ms의 os를 선택하지 않게 되면서 개발자들이 넘어오지 않는 이슈가 발생했습니다 (이는 바다, webOS와 같은 다른 플랫폼도 가지고 있던 이슈였습니다) MS는 하드웨어시장에서 윈도우 모바일의 점유를 늘리위해 노키아를 인수하는 선택을 하게 되었는데 이는 구글이 모토롤라를 인수하면서 발생한 효과를 MS도 누려보겠다는 전략으로 진행되게 되었습니다. 인수 금액은 약 54억 4,000만 유로(7조 8,310억 원)에 달하며, 노키아 휴대폰 사업부 인원 약 2만 5,000명은 모두 MS 소속이 되었습니다. 하지만 중국시장의 성장과 안드로이드의 급성장으로 인해 사실상 2015년 ms는 모바일 시장을 포기하게 됩니다. 이는 ms가 노키아 인수를 하면서 최소 9조5천억의 적자를 봤으며, MS의 스마트폰 OS 시장점유율은 2.7%에 그쳤다. 구글(79%)·애플(17.7%)에 한참 못 미치는 실적이 났는데. 단말기 시장에서도 삼성전자·애플이 합계 40% 이상을 차지하고 있고 MS의 점유율은 2.6%에 머무르는 처참한 성적이 ms의 모바일 시정 철수에 한몫을 했습니다. 물론 실패는 했지만 남긴것도 있습니다. Metro UI라고 하는 스타일UI는 현재 윈도우10에 적용되어 있으며 윈도우의 태블릿 시장에 좋은 경험이 되고 있습니다. 윈도우 모바일의 기능들은 대부분 윈도우10에 흡수되었으며 윈도우가 비록 모바일 시장에서는 철수 했지만 랩탑/태블릿 시장에서 좋은 성과를 거두고 있기에 이번에는 좀 달라질수 있나 기대해볼수 있습니다(사고 싶습니다 서피스북~) MS의 수익은 대부분 윈도우 기반 소프트웨어로 이뤄져 있었습니다. 구글의 성장은 MS가 온라인 시장으로 나와야 하는 큰 이유중 하나가 되었으며 특히 진입이 늦었던 ms는 기존 자사가 가지고 있던 MSN이라는 포털을 활용했습니다. MSN은 윈도우의 window live messanger 와 hotmail이라는 대표적인 기능을 가지고 있는 포탈인데 국내에서는 다음과 제휴한적도 있고 중앙일보랑도 뭘 한적이 있긴 하지만 사실상 국내시장에서 msn은 망했다 라고 해도 무방할정도로 공룡 두마리가 독식하고 있고, 해외에서도 부진을 면치 못하고 있습니다. 이때 msn의 검색 서비스를 bing으로 바꾸면서 개편을 노렸는데요. 2017년 야후의 서비스중단과 같은 포털 시장의 큰 변화에도 msn은 그나마 버티고는 있는 상황입니다. 아무래도 ms는 구글을 목표로 개발했기 때문에 구글보다 더 좋다 라는 식으로 홍보도 열심히 하고 있지만 적어도 개발자들끼리 모르는게 있을때 표현을 구글링을 한다고 하지 빙을 한다고는 하지 않는데 다 이유가 있지 않나 싶습니다. 그래도 야후재팬이 있는 일본을 제외한 나머지 시장에서는 2위를 간신히 유지하고 있긴 합니다. ms브라우저의 기본 검색엔진이기도 하고, 맥OS와 시리의 기본 검색엔진이기도 합니다. 하지만 애플같은 경우 2017년 10월부터는 구글로 기본검색 엔진을 교체했기 때문에 상당히 영향을 주지 않았을까 생각합니다. 사실 점유율의 통계가 문제가 되는것은 과거 네이트온을 키면 네이트가 뜨면서 점유율을 늘리는 구조나, 이스트소프트의 제품을 설치하며 zum을 검색엔진으로 바꿔주는 방식으로 점유율을 가져가는 것과 마찬가지였기 때문에 엔진 자체의 기능이나 성능을 비교하는것이 맞겠지만 검색 엔진 이전에 포탈로서 점유율을 많이 가져가고 있지 못하기 때문에 현재는 많이 힘든게 사실입니다. <a href="http://news.einfomax.co.kr/news/articleView.html?idxno=3445399" target="_blank" rel="noopener">구글은 어떻게 검색시장 점유율 90%를 장악하게 됐나 - 연합인포맥스</a> 모바일시장의 실패와 시장의 변화, 그리고 시장에 맞춰 변화하지 못한 결과는 MS의 큰 위기로 돌아왔습니다. 아이폰 이후 찾아온 모바일 시장에서 MS의 소프트웨어는 변화하지 못했고 PC시장은 침체되었습니다. 뒤늦게 MS는 모바일과 태블릿 시장에 변화에 뛰어들었지만, apple과 google이 주는 사용자 경험에 사용자들은 적응되어버렸습니다. 윈도우 vista, 윈도우8의 실패가 컸으며, ‘독점’ 하고 있었던 오피스 시장은 google docs나 iwork가 무료전환에 모바일까지 지원하면서 계속 도전을 받고 있습니다. 또한 독점 시장과 관련하여 받은 소송전쟁은 OS끼워팔기와 같은 부정적이미지로 비춰져 기업 이미지에 큰 타격을 입게 됩니다. 2012년 ms의 주식이 26달러까지 내려가며 성장하는 모습을 보여주지 못했고 스티븐 잡스 이후에도 승승장구하던 애플의 팀쿡과 달리 빌게이츠 이후의 스티븐 발머는 고전을 면치 못하고 사임하게 됩니다. 그리고 등장하는 인물이 사티아 나델라 입니다. 사티아 나델라는 sun에 있다가 1992년 ms로 옮겨와 클라우드/엔터프라이즈 그룹을 이끌며 컴퓨팅 플랫폼, 개발자 도구, 그리고 클라우드 서비스에 대한 업무를 맡았었습니다. 사티아 나델라는 OS에 의존하던 사업모델을 클라우드 모델로 전환하면서 MS을 개편했는데요. 현재 2018년도 기준으로 5년정도의 기간동안 MS는 많은 변화가 일어났습니다. MS의 부정적인 이미지를 가지고 있는 개발자라면 바로 나델라가 오기 이전의 MS를 떠올리기 때문인데요. MS의 패키지 소프트웨어 말고 오픈소스도 많이 하고 있다는 것을 많은 개발자들이 인정해주지 않는 느낌을 많이 받았습니다. MS가 하고 있는 오픈소스들을 살펴 보면서 MS를 보는 시각을 조금은 바꾸고 오해도 푸는 기회가 되었으면 좋겠습니다.</p><h1 id="MS의-대표적인-오픈소스들"><a href="#MS의-대표적인-오픈소스들" class="headerlink" title="MS의 대표적인 오픈소스들"></a>MS의 대표적인 오픈소스들</h1><h2 id="VsCode"><a href="#VsCode" class="headerlink" title="VsCode"></a>VsCode</h2><p>VsCode는 윈도우, Mac, 리눅스에서 동작 가능한 code editor입니다. Electron기반에 모나코라는 ms오픈소스가 합쳐저 만들어졌습니다. <a href="https://insights.stackoverflow.com/survey/2018/" target="_blank" rel="noopener">Stack Overflow Developer Survey 2018</a> 아직 vscode를 사용하지 않는 개발자들은 ms가 만든 오픈소스 에디터일뿐 이라고 치부할수 있겠지만 stack overflow에서 조사한 결과에 따르면 Most Popular Development Environments부분에서 34.9%로 1등을 차지할정도 핫한 툴입니다. 처음에는 웹 기반에 간단한 스크립트 수정을 위한 목적으로 나왔지만 다양한 플러그인들이 나오면서 IDE수준으로 사용할수 있을만큼 성장하였습니다. 자바 개발자로서 vscode를 이용하여 spring개발도 진행할 수 있습니다 <a href="https://code.visualstudio.com/docs/java/java-spring-boot" target="_blank" rel="noopener">Spring Boot support in VS Code</a> 2017년 projects with the most contributors에서 15k로 1등을 할정도로 급성장한 vscode는 크로스플랫폼 개발자에게 큰 메리트를 줄것입니다 <a href="https://octoverse.github.com/" target="_blank" rel="noopener">GitHub Octoverse 2017 | Highlights from the last twelve months</a></p><h2 id="DotNet"><a href="#DotNet" class="headerlink" title="DotNet"></a>DotNet</h2><p>닷넷이 오픈소스라는 사실을 많은 개발자들이 모르고 있습니다. 2014년 11월 MS는 닷넷 코어를 오픈소스로 공개했습니다. 닷넷의 오픈소스 전환은 닷넷이 윈도우를 벗어나 크로스 플랫폼으로 전환하려는 의도와 다양한 생태계 구축을 목표로 하는데 큰 의미가 있습니다. 사실 자바라는 언어가 가지는 효과가 바로 이것인데 윈도우로 개발하고 리눅스로 배포하는 크로스플랫폼의 효과와 다양한 오픈소스들로 이루어진 생태계는 자바가 웹같은 시장에서 큰 자리를 차지하는 이유중 하나로 꼽을 수 있는데요. 그에 반해 닷넷은 윈도우개발자라고 치부될정도로 좁았습니다. 그런데 오픈소스 전환은 리눅스, 맥에서 닷넷을 사용할수 있게 되면서 닷넷의 사용범위가 늘어나는 효과를 누릴수 있게 되었습니다. 더이상 mono나 Xamarin같은 비효율적?인 구조를 가져갈 필요가 없게 되는 것입니다. <a href="http://hijuworld.tistory.com/8" target="_blank" rel="noopener">공돌창고 :: .NET Framework, .NET Core, Xamarin 차이와 공통점</a> 하지만 명확하게 알고가야 하는 개념이 닷넷 프레임워크와 닷넷코어 그리고 쟈마린의 차이입니다 닷넷 코어는 위에 설명과 마찬가지로 크로스 플랫폼을 위해 나온것이라면 닷넷 프레임워크는 윈도우에 특화되어 개발한다고 보시면 될거 같습니다 쟈마린은 모바일 환경에 맞춰 나온 것으로 알면 됩니다 전반적으로 모두 .Net Standard Library 2.0을 지원합니다 이 3개는 standard library 2.0을 지원한다 라는 것을 제외하면 동작하는 프레임워크 모듈이 다릅니다 <a href="https://docs.microsoft.com/ko-kr/dotnet/standard/choosing-core-framework-server" target="_blank" rel="noopener">서버 앱에 대해 .NET Core와 .NET Framework 중에 선택 | Microsoft Docs</a></p><h2 id="Chakra"><a href="#Chakra" class="headerlink" title="Chakra"></a>Chakra</h2><p>Apple에 webkit이 있고 google에 chromium이 있다면 MS에는 Chakra라는 엔진이 있습니다. chakra는 2015년 말에 오픈소스로 공개되었는데요. MS의 브라우저 엣지에 사용되고 있습니다. 차크라 코어는 독립적으로 동작할 수 있는 자바스크립트 가상머신으로서 파서, 인터프리터, 컴파일러 등 자바스크립트를 실행하는 데 필요한 요소는 모두 포함하고 있는데요. 뒤에 나올 타입스크립트의 발전에 따라 표준이 변화하고 브라우저 엔진이 중요한 역활을 하게 될것인데 이때 ms도 이와 함께 브라우저 엔진의 기술을 확보하고 있습니다. chakra로 개발되는 다양한 소프트웨어들은 엣지 브라우저에서 동작시키면서 생태계를 확보하려는 전략도 있는데요. 이렇게 chakra기반으로 개발되는 소프트웨어가 증가하면서 엣지 브라우저의 호환성을 늘리면서 사용자들의 만족도를 확보하려고 합니다. 가장 대표적인 것은 Node.js에서도 chakra엔진을 선택하여 개발을 진행할수 있는데요. 이는 개발자에게 다양한 엔진을 선택할 수 있는 기회를 부여하고 확보하는데 큰 역활을 하고 있습니다</p><h1 id="Java와-웹시장에-미친-영향"><a href="#Java와-웹시장에-미친-영향" class="headerlink" title="Java와 웹시장에 미친 영향"></a>Java와 웹시장에 미친 영향</h1><p>MS가 오픈소스를 하고 있긴 하구나~ 라는것을 대표적인것을 통해 봤지만 내가 개발하는거랑은 전혀 연관이 없다 라고 생각하실 수도 있을거 같습니다. (이 포스팅은 자바 개발자를 위한 포스팅) 우리가 실질적으로 느낄수 있는 영향을 준 MS의 오픈소스는 무엇이 있을까요?</p><h2 id="ReactiveExtension"><a href="#ReactiveExtension" class="headerlink" title="ReactiveExtension"></a>ReactiveExtension</h2><p>아해에서는 2017년 공개세미나에서 제가 ReactiveStream에 대해 발표한 적이 있습니다 <a href="https://ahea.wordpress.com/2017/02/03/reactive-history/" target="_blank" rel="noopener">Reactive History – Ahea Team Study Blog</a> 물론 Reactive에 대한 개념은 MS랑은 별개이지만 자바에서 Reactive라고 하면 표준인 Reactive Streams와 RxJava를 대표적이라고 이야기 할 수 있을거 같습니다. 특히 이번 스프링 5에서는 Reactive를 이용한 개발 방법이 새롭게 제공되면서 관심이 더 많아졌고 넷플릭스의 사례로 본 RxJava와 조금더 발전된 RxAndroid같은 ReactiveExtension은 아주 유명하죠. 이때 ReactiveExtension(줄여서 rx)는 Microsoft에서 공개한 오픈소스 프로젝트입니다. 처음 rx는 오픈소스는 아니였으나 Eric Meijer라는 개발자가 rx.net, rx.js, rx++을 최초로 공개하였고 Netflix의 Jafar Husain이 넷플릭스의 구조를 변경하기 위해 rxJava를 만들면서 java진영에서도 reactive한 개발을 적용하기 쉬워졌습니다. 최근에는 java9에서는 Reactive Stream이라는 표준이 정의되어 interface가 제공되게 되었습니다.</p><h2 id="Azure와-Spring"><a href="#Azure와-Spring" class="headerlink" title="Azure와 Spring"></a>Azure와 Spring</h2><p>사실 Azure는 오픈소스는 아니지만 MS에서 Java개발자를 위해 무난히 애쓰고 있는 것을 좀 알리고자 추가하게 되었습니다. 사실 Azure는 java개발자들에게는 크게 친하지 않은 클라우드 플랫폼입니다. 오히려 aws나 google쪽이랑 친하실거 같은데요. 사실 azure도 굉장히 많이 사용되는 클라우드 플랫폼입니다. <a href="https://www.zdnet.com/article/cloud-providers-ranking-2018-how-aws-microsoft-google-cloud-platform-ibm-cloud-oracle-alibaba-stack/" target="_blank" rel="noopener">Top cloud providers 2018: How AWS, Microsoft, Google Cloud Platform, IBM Cloud, Oracle, Alibaba stack up | ZDNet</a> 조사에 따르면 aws는 2017년 분기별 영업수익이 $20.4 billion인데에 비해 MS는 $21.2 billion으로서 aws보다 앞서고 있으며 Enterprise public cloud시장에서 aws를 ms가 2위로 쫒아가면서 빠르게 쫒아가고 있습니다 (ms의 클라우드 시장에는 office365도 포함이 되어 있습니다) azure 초기부터 웹시장을 장악하고 있던 java플랫폼을 흡수하고 싶어 했는데요. 2010년도 초반에 개인적으로 azure플랫폼 세미나를 간적이 있는데 닷넷만큼이나 지원을 활발하게 하고있던것이 java였습니다. <a href="https://azure.microsoft.com/ko-kr/develop/java/" target="_blank" rel="noopener">https://azure.microsoft.com/ko-kr/develop/java/</a> 애저 홈페이지에 자바 탭을 들어가보면 알수 있는데요. 톰캣, 오라클과 같은 다양한 기술스택을 손쉽게 선택할수 있고(aws보다 쉬운건 더 쉬운거 같습니다) intellij나 이클립스 또는 cli까지도 지원하면서 자세하게 가이드를 제공해주고 있습니다 또 마지막으로 Spring boot를 손쉽게 배포할수 있고 Docker나 Kubernetes를 azure cluster에 쉽게 배포하는법까지도 가이드가 쉽게 제공되기 때문에 한번쯤은 cloud를 적용하려 할때 고려정도? 해보시면 좋을거 같습니다 (꽤 쉽습니다) <a href="https://docs.microsoft.com/ko-kr/java/azure/intellij/azure-toolkit-for-intellij-publish-spring-boot-docker-app?view=azure-java-stable" target="_blank" rel="noopener">IntelliJ용 Azure 도구 키트를 사용하여 Spring Boot 앱을 Docker 컨테이너로 게시 | Microsoft Docs</a></p><h2 id="TypeScript"><a href="#TypeScript" class="headerlink" title="TypeScript"></a>TypeScript</h2><p>타입스크립트는 최근 엄청 다양하게 온갓군데에서 사용하고 있습니다. 저같은 경우 최근에는 앵귤러에서 사용했고 node.js나 react, vue.js와 같은 핫한 기술에는 다 적용되고있다고 봐도 무관합니다. 이러한 typescript는 Microsoft에서 2012년도에 발표한 언어입니다(소프트웨어 대기업들 언어 하나정도는 가지고 있죠??) 타입스크립트는 ES6를 지키고 있기 때문에 호환도 좋고 스크립트 오픈소스중에 가장 잘나가고 있는 녀석인거 같습니다. 타입스크립트를 기반으로 한 라이브러리/프레임워크/앱들을 나열해보겠습니다 몇가지나 알고 있는지 체크해보시길 바랍니다 Vscode Angular Ionic React Node Express Babel Asp.net core WeChat nest Web pack Native script 상당히 많이 알고 계시고 또 사용도 하고 계시다면 여러분은 Microsoft의 오픈소스를 활용하고 계신겁니다</p><h1 id="MS가-인수한-기업들"><a href="#MS가-인수한-기업들" class="headerlink" title="MS가 인수한 기업들"></a>MS가 인수한 기업들</h1><p>글쎄요. MS가 여러분의 소프트웨어 개발에 있어 얼마만큼 영향을 주고 있는지는 모르겠습니다. 적어도 윈도우는 쓰시겠죠~ 이번에는 다시 Github의 인수 얘기로 돌아와서 MS가 과거 기업을 인수한 사례들을 살펴보려고합니다. 사실 해외에서는 기업을 인수하는것이 자주 있는 일입니다. 구글이 안드로이드를 만든게 아니라 인수를 했고, 페이스북은 인스타그램, 오큘러스,왓츠앱과 같은 기업을 인수하면서 자사 서비스를 강화했죠. MS도 마찬가지입니다 위에 노키아를 인수한 사례도 있었는데요 몇가지 다른 사례를 보겠습니다</p><h2 id="링크드인"><a href="#링크드인" class="headerlink" title="링크드인"></a>링크드인</h2><p>링크드인은 4억 명이 넘는 사용자를 확보한 세계 최대의 비즈니스 SNS기업입니다. 저같은 경우 저의 개발 프로필을 올리면 헤드헌터나 기업에서 연락이 오고 했는데요. MS는 2016년 링크드인을 62억달러(30조 5천억원)에 인수하게 됩니다. 마이크로소프트와 링크드인의 인수합병은 계약 체결 뒤 마무리까지 6개월이 걸렸다고 하는데요. 유럽연합(EU)이 마이크로소프트가 반독점을 할 수 있다는 이유로 링크트인의 인수를 반대했기 때문이랍니다. 마이크로소프트는 향후 5년 동안 링크드인을 MS오피스, 클라우드컴퓨팅 서비스에 연결하지 않는다는 조건으로 유럽연합의 승인을 받았다고 하네요. MS의 링크드인 인수는 MS에서 인수한 기업중 최대 금액입니다. MS는 왜 링크드인을 인수했을까요? MS는 기업 시장에 집중하는 추세입니다. 기존에 MS proejct나 MS office같은 제품을 가지고 있었고 기업형 sns인 야머, 클라우드 보안업체인 아달롬, 인터넷 전화인 스카이프 인수한것을 보면서 기업의 협업, 생산성 강화를 목표로 하고 있는것을 알수 있습니다. office만 보더라도 단순 문서도구가 아닌 클라우드화를 통해 협업을 강화하려고 하고 있습니다. 이때 링크드인의 합류는 효과를 배로 만들수 있는데요. 기업형 sns인 링크드인은 기업시장을 키우고 있는 MS에게 아주 매력적인 서비스입니다. 과거 노키아 인수 사례를 보면 MS의 제품을 sales하기 위한 인수가 있었다면 링크드인은 그 서비스를 통해 MS의 제품의 영향력을 강화시키는데 큰 목표를 두고 있기에 좋은 성과가 나오지 않을까 생각이 듭니다. 오늘 저녁 집에 가서 링크드인 프로필을 작성해보시는건 어떤가요?</p><h2 id="Docker"><a href="#Docker" class="headerlink" title="Docker"></a>Docker</h2><p>사실 도커는 인수는 되지 않았고 시도만 있었던 뉴스입니다. 2016년도에 있었던 뉴스인데요. MS가 도커를 40억달러에 인수하려고 했다는 뉴스에 경악을 할 개발자들이 있을지도 모르겠습니다. 도커를 간략하게 설명하면 컨테이너가상화 기술을 이용하여 어플리케이션을 생성, 관리하는 기술입니다. MS는 azure를 이용한 리눅스 가상머신을 이용하여 도커를 쓸수 있도록 지원해 왔는데요. MS의 도커 인수 뉴스는 MS가 지금 하려고 하는 방향이 무엇인가를 단면적으로 보여주는 예가 되지 않나 생각됩니다.</p><h2 id="cycle-computing"><a href="#cycle-computing" class="headerlink" title="cycle computing"></a>cycle computing</h2><p>사이클 컴퓨팅은 클라우드 오케스트레이션 솔루션 업체로서 2017년 하반기에 인수되었습니다. 사이클 클라우드 라는 서비스 개발사로 클라우드 오케스트레이션, 프로비저닝, 데이터 관리 등의 기능을 제공하고 있습니다. 사이클 컴퓨팅은 aws가 대규모 클라우드 기반 슈퍼컴퓨터를 구현하는 것을 지원했을정도로 기술력이 있는 회사입니다. 당시 구현한 5만 1,000코어 슈퍼컴퓨터는 1시간 사용 요금이 5,000달러였다고 합니다 5만 1000 코어요… 이때를 기점으로 아마존, 마이크로소프트, 구글은 사이클 컴퓨팅의 클라우드 오케스트레이션 소프트웨어를 도입했다고 합니다. 이번 인수로 인해 사이클 컴퓨팅은 애저 클라우드 서비스를 중점적으로 지원할것이며 장기적으로는 사이클 컴퓨팅이 애저로 흡수되어 질것으로 보입니다. 이번 인수로 인해 aws나 google보다 한수 높은 기술력을 확보했다는 평가를 받고 있습니다.</p><h1 id="Github으로-본-미래"><a href="#Github으로-본-미래" class="headerlink" title="Github으로 본 미래"></a>Github으로 본 미래</h1><p>MS가 인수한 사례들을 몇개 봤습니다. 많은 부분이 클라우드에 집중되고 있는것을 볼 수 있습니다. 그리고 독점적인 시장을 가진 회사에서 탈바꿈하고 있는 과정입니다. 특히 사티아 나델라가 CEO로 오면서 모든 비즈니스가 클라우드화 되가고 있는 과정입니다. 나델라가 오고 변화한 MS는 2015년 4분기 Microsoft의 매출액의 20%를 Azure로 냈으며, 2017년 3분기는 Azure가 152억달러의 매출을 기록하며 92%의 성장을 이루어냈습니다. 더이상 MS가 오피스 팔아먹고 OS팔아먹는 회사는 아니다 라는것이 조금은 기록으로 나오고 있는거 같습니다. 사실 MS입장에서는 수익으로만 봤을때는 쨉이 되지 않는 것이 Github의 수익은 매년 1억1천억달러정도 밖에 되지 않기 때문에 크게 메리트 있는 부분은 아닙니다. 그렇기 때문에 github인수로 유료화가 되니 딴곳으로 도망가자~ 이런 생각은 너무 앞서간게 아닌가 생각이 드네요 그렇다고 MS가 이번에 개발자들을 위해 크게 한턱 쏩니다 라고 Github을 사들인건 아닐겁니다. MS는 오픈소스를 돕는 비영리단체는 아니니까요.. MS의 오픈소스와 기업인수를 보면 클라우드에 집중하는 것을 볼수 있습니다. 이번 github의 인수도 마찬가지고요. 앞으로 MS의 비즈니스모델이 클라우드로 이동되는 것을 볼수 있지 않을까요. Java 개발자로서 MS와 크게 친하진 않지만 MS는 Java개발자를 위해 많은 일을 하고 있었군요(MS도 많은 일을 하고 나도 많은 일을 하고…) 이번 칼럼을 통해 조금이나마 긍정적인 생각을 가지게 되었으면 좋겠습니다 감사합니다</p>]]></content>
      
      
      <categories>
          
          <category> news </category>
          
      </categories>
      
      
        <tags>
            
            <tag> microsoft </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>Lego scrum-진행편</title>
      <link href="/2018/11/08/lego-scrum-ec-a7-84-ed-96-89-ed-8e-b8/"/>
      <url>/2018/11/08/lego-scrum-ec-a7-84-ed-96-89-ed-8e-b8/</url>
      
        <content type="html"><![CDATA[<h1 id="Lego-Scrum-Game-진행편"><a href="#Lego-Scrum-Game-진행편" class="headerlink" title="Lego Scrum Game(진행편)"></a>Lego Scrum Game(진행편)</h1><p>#Lego #scrum 지난 어떻게 행사를 준비하게 되었는지 <code>기획편</code>이 포스팅되었습니다 이번 <code>진행편</code>에서는 2018년 6월 9일에 진행한 아해 행사를 통해 진행된 Scrum Game행사의 내용을 공유하고 진행하면서 있었던 내용과 느낌을 회고하려고 합니다</p><hr><p>이번 아해 스크럼 게임은 선릉에 위치한 소프트웨어 마에스트로 센터에서 진행되었습니다 아해 팀원중에 마에스트로 출신이신 분이 계셔서 좋은 기회로 이곳에서 진행하게 되었어요 <img src="http://www.plays-in-business.com/wp-content/uploads/2015/09/lego-scrum-city-2.jpg" alt="마에스트로센터"> 장소를 제공해주신 소프트웨어 마에스트로와 행사날 레고 가지고 뭐하나 봐주시기도 하고 시끄러웠을텐데 마에스트로 9기 연수생님들께 감사드립니다 장소도 매우 넓으며 책상을 저희 맘대로 옮기면서 할수 있어서 좋았던거 같습니다 행사는 다음과 같은 순서로 진행하였습니다</p><ol><li><p>스크럼이 무엇인지 보고</p></li><li><p>팀구성 후 게임한판 하고</p></li><li><p>스크럼 게임 하고</p></li><li><p>게임 후에 다시한번 스크럼이 무엇인지</p></li><li><p>사진찍고 퇴장</p></li></ol><h2 id="스크럼이-무엇인지-보고"><a href="#스크럼이-무엇인지-보고" class="headerlink" title="스크럼이 무엇인지 보고"></a>스크럼이 무엇인지 보고</h2><p>시작은 스크럼이란 무엇인가 아주 간단하게 알아보는 시간을 가졌습니다 스크럼을 설명하기 위해서는 우선 애자일이 무엇인가를 알아야 합니다 애자일 소프트웨어 개발 선언을 통해 기존 워터풀과의 차이를 설명하였습니다 Lego Scrum Game에서는 물론 스크럼 프로세스를 익혀보는 이유도 있지만 팀원간에 커뮤니케이션의 중요성을 강조하고 그 스킬을 익히는 목표도 있습니다</p><h2 id="팀구성-후-게임한판-하고"><a href="#팀구성-후-게임한판-하고" class="headerlink" title="팀구성 후 게임한판 하고"></a>팀구성 후 게임한판 하고</h2><p>팀구성은 Scrum Game에서 중요한 요소중에 하나입니다 팀 구성은 한팀당 4-6명이 적당합니다 총 팀은 5-7팀 (20-25명)이 적당합니다 lego4scrum에서도 그렇게 권장하고 있습니다 저희는 4명 + 지각자(?) 1분씩 해서 4팀이 구성이 되었습니다 팀이 구성되었으면 처음 본 팀원끼리 서로를 파악하고 친해지기 위해 저희는 스파게티 탑 쌓기 게임을 진행했습니다 <img src="https://raw.githubusercontent.com/devload/devload.github.io/master/assert/image/ahea_lego_scrum2/2.jpg" alt="스파게티탑쌓기1"> <img src="https://raw.githubusercontent.com/devload/devload.github.io/master/assert/image/ahea_lego_scrum2/3.jpg" alt="스파게티탑쌓기2"> 룰은 이렇습니다 5분동안 마시멜로우(1봉지)와 스파게티면(30개)을 이용해서 가장 높이 탑을 쌓는 팀이 이기는 게임입니다 <img src="https://raw.githubusercontent.com/devload/devload.github.io/master/assert/image/ahea_lego_scrum2/3.jpg" alt="스파게티탑쌓기3"> <img src="https://raw.githubusercontent.com/devload/devload.github.io/master/assert/image/ahea_lego_scrum2/4.jpg" alt="스파게티탑쌓기4"> 4분 30초까지는 높게 쌓던 팀이 종료 시간이 다되가면서 탑이 무너지는 안타까운(?) 사고도 있었습니다 사실 이게임은 마시멜로우를 자꾸 만지면 녹아 내려 건물이 무너지고 높게 쌓을수록 스파게티면이 버티지 못하고 부러지는 문제가 있습니다 서로 호흡하면서 높게 쌓는게 포인트입니다 스파게티 탑쌓기를 통해 커뮤니케이션 능력을 서로 확인한 후 그 사람을 스크럼마스터로 뽑았습니다 스크럼마스터는 스프린트가 진행되는 동안 계획과 회고를 진행하고 스프린트동안 팀을 리딩하는 역할을 하게 됩니다 이때 스크럼마스터는 독단적이고 고집이 쎈 독재자가 되서는 안됩니다 이렇게 팀이 구성되고 게임을 한판 했습니다</p><h2 id="스크럼-게임-하고"><a href="#스크럼-게임-하고" class="headerlink" title="스크럼 게임 하고"></a>스크럼 게임 하고</h2><p>본격적인 레고 가지고 노는 시간이 시작되었습니다</p><blockquote><p><em>목표 : 도시만들기</em> 안녕하세요 고객입니다 제가 땅이 좀 있는데 이 땅에 도시를 건설하려고 합니다 여러분은 이제 제가 요구하는 건물들을 지어주세요</p></blockquote><p>우리는 도시를 만들어야 합니다 고객이 무엇을 요구하는지 몇가지 것들을 보겠습니다</p><ul><li>강을 건널 수 있는 다리를 건설하세요</li><li>1층 집을 건설하세요</li><li>2층 집을 건설하세요</li><li>버스 정류장을 건설하세요</li><li>교회를 건설하세요</li></ul><p>이 요구사항 이외에도 많은 종류의 요구사항들이 있습니다</p><h3 id="시작전"><a href="#시작전" class="headerlink" title="시작전"></a>시작전</h3><p>시작 전 단계에서는 저희가 만들어드린 요구사항을 전달해드렸습니다 <img src="https://raw.githubusercontent.com/devload/devload.github.io/master/assert/image/ahea_lego_scrum2/6.jpg" alt="지도 그리기"> 다들 요구사항을 받고서 무엇이 있나 확인하시고 계십니다 또 어떻게 만들어야 하나 벌써부터 회의가 시작되죠 시작전 해야 할 일은 스크럼 보드와 지도를 그리는 일입니다 <img src="https://raw.githubusercontent.com/devload/devload.github.io/master/assert/image/ahea_lego_scrum2/10.jpg" alt="지도 그리기"> <img src="https://raw.githubusercontent.com/devload/devload.github.io/master/assert/image/ahea_lego_scrum2/11.jpg" alt="스크럼보드"> <img src="https://raw.githubusercontent.com/devload/devload.github.io/master/assert/image/ahea_lego_scrum2/9.jpg" alt="지도 그리기"></p><h3 id="게임"><a href="#게임" class="headerlink" title="게임"></a>게임</h3><p>게임은 총 3번의 스프린트로 진행이 되는데요 스프린트는 시작전에 계획을 세우고 스프린트를 진행 후 회고 시간을 가지게 됩니다 팀은 스프린트 시작전 이번 스프린트에서 어떤 건물을 진행할까 <code>계획</code>을 세웁니다(시간 3분) 이때 <code>플래닝 포커</code>를 통해 의견을 취합해야 합니다 시간이 많이 없기 때문에 빠른 의사소통이 중요합니다 <em>플래닝포커에 많은 시간을 쏟도록 스크럼마스터에게 요구했습니다</em> 이때 <code>플래닝 포커</code>가 무엇인지 참가자들에게 잘 설명해야 했습니다 플래닝 포커의 룰은 간단합니다 백로그를 보고 얼마나 걸릴거 같은지 고민 한 후 카드를 함께 공개합니다 그러면 서로 다른 의견으로 갈린다면 다양한 카드 숫자가 나오게 되겠죠 그럼 서로 의견을 교환하며 비슷한 숫자가 나올때까지 플래닝포커를 진행합니다 <a href="https://www.youtube.com/watch?v=0FbnCWWg_NY&amp;t=169s" target="_blank" rel="noopener">Agile in Practice: Planning Poker - YouTube</a> 저희는 scrum time이라는 앱을 통해 진행하였습니다 시작전 플래닝 포커 연습을 했는데요</p><blockquote><p>맥주를 요구르트병에 판다면 개당 얼마일까요?</p></blockquote><p>다양한 의견들이 나왔는데 맥주는 어떤 메이커인지, 요구르트 병의 사이즈는 얼만하지와 같은 요구사항을 명확하게 하기 위한 토론이 주로 이루어졌습니다</p><blockquote><p>QnA 게시판 만들기</p></blockquote><p>연습을 한번 더 했는데요 만약 QnA 게시판을 만든다면 몇분이 걸릴까요 라는 질문입니다 개발자 답게 언어는 무엇으로 할지, 도구, 프레임워크, 테스트와 같은 어떻게 만들것인가에 대한 의견부터 어떤 질문을 하는 게시판인지, 화면은 어떻게 구성되는지와 같은 기획적인 부분까지도 논의가 되었습니다 두번의 연습을 통해 플래닝 포커에 대해 간략하게나마 방식을 배워봤습니다 플래닝 포커를 진행하면서 문제가 되거나 추상적인 요구사항들을 고객에게 질문을 하거나 팀내에서 합의를 통해서 요구사항을 구체적으로 정의합니다 <code>스프린트</code> 시간에는 레고를 조립합니다 팀에서 계획한대로 진행해야 회고 시간에 문제삼지 않을껍니다 독단적으로 일을 하게 되면 회고에서 얘기가 나오겠죠 <code>회고</code>시간에는 진행하면서 좋았던점이나 나빴던점을 토대로 고쳐야 할점이 뭔지 팀원들과 스프린트를 회고하는 시간을 가지게 됩니다</p><h4 id="스프린트1"><a href="#스프린트1" class="headerlink" title="스프린트1"></a>스프린트1</h4><p>첫번째 스프린트에서는 플래닝 포커를 좀더 익히고자 계획 시간을 조금더 길게 드렸습니다 그래도 시간이 부족할거 같아서 게임전 시간에도 플래닝 포커 시간을 좀 드렸습니다 플래닝 포커를 진행하면서 백로그를 선정하고 이번 스프린트에서는 무엇을 진행할지 선택해야 합니다 하지만 주어진 시간은 엄청 짧죠 - 일부러 시간을 적게 드려서 팀내에 스크럼마스터가 선택과 집중을 하는 판단을 이끌어내기 위함입니다 첫번째 스프린트이다보니 아직 진행방식을 이해하지 못해서 어려워하시는 분들도 있고 어떻게 진행할것인지에 대한 방향에 관련한 토론을 하는 팀, 그리고 우선 만들고 보는 팀들이 다양하게 있었습니다 스프린트 시간이 다 될수록 사회자는 일부러 시간을 알려줌으로 해서 압박을 넣어줍니다 첫 회고시간이 되자 레고 조립을 멈추고 팀에서 잘되고 있는 점을 극대화시키고 문제가 있는 프로세스는 회고시간을 통해 고쳐나가는 시간을 가집니다</p><h4 id="스프린트2"><a href="#스프린트2" class="headerlink" title="스프린트2"></a>스프린트2</h4><p>두번째 스프린트부터는 결과물이 나오기 시작합니다. 하지만 변수들이 존재하죠. 스프린트에서는 랜덤으로 2-3명이 병원을 가야 합니다. 그동안은 팀에 참석할수 없죠. 프로젝트를 진행하다 보면 이러한 human managing와 같은 이슈도 등장하게 됩니다. 이를 통해 어려움을 좀 느끼게 하고 싶었는데 없어도 잘 하시더군요 또하나의 변수는 요구사항 변경입니다. 예를 들면 병원의 색상을 통일 시켜주세요, 좌우 대칭으로 건물을 만들어주세요 등등 다양한 요구사항을 추가/변경함으로써 스프린트가 진행이 잘 되지 않도록 하였습니다 이는 회고시간에 큰 영향을 줬습니다. 더이상 우리는 모든 요구사항을 맞출 수 없고 선택과 집중을 하게 됩니다</p><h4 id="스프린트3"><a href="#스프린트3" class="headerlink" title="스프린트3"></a>스프린트3</h4><p>마지막 스프린트에서는 요구사항을 마무리 하고 나머지 선택된 백로그를 완성시켜나갑니다 두번의 스프린트를 진행하고 나서 3번째 스프린트이다 보니 레고를 만지는 손놀림이 아주 빨라진 것을 느낄수 있었습니다. 일정은 다가왔지만 고객은 항상 마지막에 요구사항을 바꾸는 법이죠… 다양한 요구사항을 마지막 스프린트에서도 넣습니다. 하지만 준비가 잘 되어 있는 팀은 요구사항을 잘 받아서 수정하는 팀도 있었고, 요구사항은 애초에 신경도 안쓰고 진행하신 팀들도 있었습니다.(좋은 작전일수도….)</p><h4 id="채점"><a href="#채점" class="headerlink" title="채점"></a>채점</h4><p>세번의 스프린트가 진행되고 나서 흥분된 마음을 가라 앉히기 위해 쉬는 시간을 조금 가졌습니다. 그리고 고객에서 완성된 제품을 판매하는 채점시간이 왔습니다. 실제 프로젝트라면 마지막 시연? 정도가 될거 같습니다 팀에서 아주 재미있게 팀에서 만든 제품들을 다양한 스토리를 이용해서 소개합니다. 특히 유머있고 재치있게 요구사항을 재해석 하는 것들이 포인트였습니다. 고객이 납득만 한다면야.. 채점 결과 투팀이 박빙이였습니다. 한팀은 물량으로 승부한 A팀이였고, 한팀은 요구사항을 모두 충족하고 예술점수를 가져간 B팀이였습니다. 결과적으로 B팀이 점수를 많이 획득함으로써 레고 스크럼이 마무리가 되었습니다. (상품으로 스크럼 카드를 드렸습니다)</p><h3 id="회고"><a href="#회고" class="headerlink" title="회고"></a>회고</h3><p>레고스크럼을 통해 무엇이 좋았고 무엇이 나빴는지, 그리고 무엇을 개선하면 되는지와 같은 기본적인 회고 부터 팀원들끼리 만약 프로젝트에 스크럼을 적용한다면? 이라는 생각을 중심으로 다양한 회고가 진행이 되었습니다</p><h3 id="마무리"><a href="#마무리" class="headerlink" title="마무리"></a>마무리</h3><p>아해에서 처음으로 진행한 레고스크럼게임 행사가 마무리 되었습니다. 상당히 나쁘지 않은 피드백을 받았으며 전반적으로 괜찮았다라는 이야기를 듣게 되어 진행자로써 매우 뿌듯했습니다. 우리나라의 IT구조를 얘기할때 하도급,SI와 같은 이야기를 하면서 waterful방식으로만 진행해야 했던 기존 구조를 만약 애자일이나 스크럼과 같은 방식을 도입한다면 좋아질까 라는 질문으로 저는 처음 애자일을 공부하고 스크럼을 보게 되었습니다 꼭 애자일, 스크럼을 하라는 것은 아니지만 이러한 방식도 있다라는 것을 많은 개발자들이 이번 행사를 통해 알아갈수 있는 기회가 되어 매우 만족스럽습니다</p>]]></content>
      
      
      <categories>
          
          <category> agile </category>
          
      </categories>
      
      
        <tags>
            
            <tag> lego </tag>
            
            <tag> scrum </tag>
            
            <tag> agile </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>Ahea HackDay2018 - Viewer 팀 리뷰</title>
      <link href="/2018/09/20/ahea-hackday2018-viewer-ed-8c-80-eb-a6-ac-eb-b7-b0/"/>
      <url>/2018/09/20/ahea-hackday2018-viewer-ed-8c-80-eb-a6-ac-eb-b7-b0/</url>
      
        <content type="html"><![CDATA[<p><a href="https://github.com/devahea/2018hackerton-viewer" target="_blank" rel="noopener">https://github.com/devahea/2018hackerton-viewer</a></p><h1 id="목표"><a href="#목표" class="headerlink" title="목표"></a>목표</h1><p>화면에 nurikabe를 풀고 있는 진행상황을 출력해준다 팀이 2팀이기 때문에 2개 이상의 퍼즐을 실시간으로 보여줘야 한다</p><h1 id="설계"><a href="#설계" class="headerlink" title="설계"></a>설계</h1><ol><li>화면에 출력<ul><li>누리카베 퍼즐을 어떻게 화면에 출력해야 할까?</li><li>웹에서 누리카베 퍼즐을 어떤 기술로 해야 할까?</li><li>canvas로 그려보면 어떨까?</li></ul></li><li>실시간으로 메세지를 전송<ul><li>각 팀에서 보내주는 퍼즐진행 정보를 빠르게 화면으로 보내줘야 한다</li><li>websocket이나 socketio를 이용해보면 좋겠다</li></ul></li></ol><h1 id="구현하기"><a href="#구현하기" class="headerlink" title="구현하기"></a>구현하기</h1><h2 id="화면에-출력하기"><a href="#화면에-출력하기" class="headerlink" title="화면에 출력하기"></a>화면에 출력하기</h2><p>우리 프로젝트는 웹 환경으로 제공하려고 했습니다. 이때 웹에서 도형을 그리는 방법은 뭐가 있을까 고민했을때 1도 망설임없이 canvas를 생각했습니다. 첫번째로 네모를 그리는 방법을 찾았습니다 <a href="https://www.w3schools.com/tags/canvas_rect.asp" target="_blank" rel="noopener">https://www.w3schools.com/tags/canvas_rect.asp</a> [code lang=javascript] var c=document.getElementById(“myCanvas”); var ctx=c.getContext(“2d”); ctx.rect(20,20,150,100); ctx.stroke(); [/code] rect를 사용하여 네모를 그리는 방법을 알게 되었습니다 w3school을 보면 paramewter로 x,y,width,height를 받는것을 알수 있습니다 이를 이용하면 내가 원하는 위치에 원하는 크기로 그릴수 있을거 같습니다 두번째로 네모를 여러개를 그리는 방법을 고민했습니다 [code lang=html] &lt;!DOCTYPE html&gt; <html> <head><meta name="generator" content="Hexo 3.8.0"> <title>Hello canvas</title> <a href="/webjars/jquery/jquery.min.js">/webjars/jquery/jquery.min.js</a> <link rel="stylesheet" href="/css/prism-tomorrow.css" type="text/css"></head> <body> <div id="main-content" class="container"> </div> </body> function createMap(id, width, height) { $(“#main-content”).append(“”) var c = document.getElementById(“canvas” + id); var ctx = c.getContext(“2d”); ctx.font=”15px Arial”; var rectSize = 25; var startPoint ={x:25, y:25}; for (i = 0 ; i </html> [/code] 만약 a팀이 1번 퍼즐을 풀기위해 맵을 만든다면 <code>createMap(&#39;a_1&#39;, 10, 10)</code>을 호출한다면 10 X 10짜리 네모들이 출력이 될것입니다 세번째로 네모 안에 텍스트 집어넣기입니다 누리카베는 총 3개의 타입이 있습니다 검은색이 칠해진 block, 숫자가 들어간 number, 점 하나로 이루어진 room입니다 네모를 그리기 위해서는 <code>rect</code>함수를 사용했다면 텍스트를 넣기 위해서는 <code>fillText</code>, 검은색으로 칠하려면 fillRect를 사용하면 됩니다 [code lang=javascript] if (type == ‘number’) { ctx.fillText(number,startPoint.x + (rectSize <em> x)- 16, startPoint.y + (rectSize </em> y)- 6); ctx.stroke(); } else if (type == ‘block’) { ctx.fillRect(startPoint.x + (rectSize <em> x), startPoint.y + (rectSize </em> y), rectSize, rectSize); ctx.stroke(); } else if (type == ‘room’) { ctx.fillText(“o”,startPoint.x + (rectSize <em> x)- 16, startPoint.y + (rectSize </em> y)- 6); ctx.stroke(); } [/code]</p><h2 id="통신하기"><a href="#통신하기" class="headerlink" title="통신하기"></a>통신하기</h2><p>실시간으로 빠르게 server와 client가 데이터를 주고 받으려면 어떻게 할까 고민하는 중 websocket을 이용하면 어떨까 하여 구글링해봤습니다 <code>spring websocket</code>이라고 구글링을 하게 되면 <a href="https://spring.io/guides/gs/messaging-stomp-websocket/" target="_blank" rel="noopener">https://spring.io/guides/gs/messaging-stomp-websocket/</a> 링크가 상단에 나오는 것을 확인할 수 있습니다 해당 샘플로 프로젝트를 세팅한 후 기능 동작을 확인한 후 우리의 비즈니스에 맞게 수정하는 작업을 진행하였습니다 (수정할때 기존것을 크게 만지지 않았습니다) 퍼즐 맞추는 팀이 처음 데이터를 보내주는 <code>create</code>, 추가적으로 퍼즐을 풀면서 보내는 <code>putItem</code>을 하나 만들었습니다 [code lang=java] @Autowired SimpMessagingTemplate template; @RequestMapping(“/create”) public @ResponseBody String create(String name, Integer x, Integer y, String method, Integer number, String message){ JsonObject jsonObject = new JsonObject(); jsonObject.addProperty(“name”, name); jsonObject.addProperty(“x”, x); jsonObject.addProperty(“y”, y); jsonObject.addProperty(“method”, “create”); System.out.println(“jsonObject.toString() “ + jsonObject.toString()); template.convertAndSend(“/topic/greetings”, jsonObject.toString()); return “goods”; } @RequestMapping(“/putItem”) public @ResponseBody String putMessage(String name, Integer x, Integer y, String method, Integer number, String message){ JsonObject jsonObject = new JsonObject(); jsonObject.addProperty(“name”, name); jsonObject.addProperty(“x”, x); jsonObject.addProperty(“y”, y); jsonObject.addProperty(“method”, method); jsonObject.addProperty(“number”, number); jsonObject.addProperty(“message”, message); System.out.println(“jsonObject.toString() “ + jsonObject.toString()); template.convertAndSend(“/topic/greetings”, jsonObject.toString()); return “goods”; } @MessageMapping(“/hello”) @SendTo(“/topic/greetings”) public String greeting(HelloMessage message) throws Exception { Thread.sleep(1000); // simulated delay System.out.println(“Message “ + message); return message.getName(); } [/code] SimpleMessageTemplate은 다음과 같이 정의되어 있습니다 [code lang=java] @Configuration @EnableWebSocketMessageBroker public class WebSocketConfig implements WebSocketMessageBrokerConfigurer { @Override public void configureMessageBroker(MessageBrokerRegistry config) { config.enableSimpleBroker(“/topic”); config.setApplicationDestinationPrefixes(“/app”); } @Override public void registerStompEndpoints(StompEndpointRegistry registry) { registry.addEndpoint(“/gs-guide-websocket”).withSockJS(); } } [/code] 클라이언트에서는 어떻게 받았을까요 [code lang=javascript] var stompClient = null; function setConnected(connected) { $(“#connect”).prop(“disabled”, connected); $(“#disconnect”).prop(“disabled”, !connected); if (connected) { $(“#conversation”).show(); } else { $(“#conversation”).hide(); } $(“#greetings”).html(“”); } function connect() { var socket = new SockJS(‘/gs-guide-websocket’); stompClient = Stomp.over(socket); stompClient.connect({}, function (frame) { setConnected(true); console.log(‘Connected: ‘ + frame); stompClient.subscribe(‘/topic/greetings’, function (greeting) { showGreeting(greeting.body); setNurikabe(JSON.parse(greeting.body)); }); }); } function disconnect() { if (stompClient !== null) { stompClient.disconnect(); } setConnected(false); console.log(“Disconnected”); } function sendName() { stompClient.send(“/app/hello”, {}, JSON.stringify({‘name’: $(“#name”).val()})); } function showGreeting(message) { $(“#greetings”).append(“<tr><td>“ + message + “</td></tr>“); } function setNurikabe(message) { receiveObj = eval(message); if (receiveObj.method == ‘create’ ) { createMap(receiveObj.name, receiveObj.x , receiveObj.y); } else { appendItem(receiveObj.name, receiveObj.x , receiveObj.y, receiveObj.method, receiveObj.number); } } function createMap(id, width, height) { var rectSize = 25; var startPoint ={x:25, y:25}; $(“#main-content”).append(“<canvas id="\\" canvas""="" +="" "\\"="" width="500px" height="500px"></canvas>“) var c = document.getElementById(“canvas” + id); var ctx = c.getContext(“2d”); ctx.font=”15px Arial”; for (i = 0 ; i &lt; width; i++) { for (j = 0 ; j &lt; height; j++) { ctx.rect(startPoint.x + (rectSize <em> i), startPoint.y + (rectSize </em> j), rectSize, rectSize); ctx.stroke(); } } } function appendItem(id, x, y, type, number) { var rectSize = 25; var startPoint ={x:25, y:25}; var c = document.getElementById(“canvas” + id); var ctx = c.getContext(“2d”); ctx.font=”15px Arial”; if (type == ‘number’) { ctx.fillText(number,startPoint.x + (rectSize <em> x)- 16, startPoint.y + (rectSize </em> y)- 6); ctx.stroke(); } else if (type == ‘block’) { ctx.fillRect(startPoint.x + (rectSize <em> x), startPoint.y + (rectSize </em> y), rectSize, rectSize); ctx.stroke(); } else if (type == ‘room’) { ctx.fillText(“o”,startPoint.x + (rectSize <em> x)- 16, startPoint.y + (rectSize </em> y)- 6); ctx.stroke(); } } $(function () { $(“form”).on(‘submit’, function (e) { e.preventDefault(); }); $( “#connect” ).click(function() { connect(); }); $( “#disconnect” ).click(function() { disconnect(); }); $( “#send” ).click(function() { sendName(); }); }); [/code] 코드 중간중간에 <code>var socket = new SockJS(&#39;/gs-guide-websocket&#39;);</code> 와 <code>stompClient.subscribe(&#39;/topic/greetings&#39;, function (greeting)</code>와 같은 url이 있습니다 해당 코드가 java코드에 어디에 있는지 확인하여 매핑되는지 확인하면 좋을거 같습니다</p><h2 id="테스트"><a href="#테스트" class="headerlink" title="테스트"></a>테스트</h2><p>스프링 부트프로젝트를 실행시킵니다 [code lang=text] $ mvn spring-boot:run [/code] 저는 해커톤의 특성상(이라고 쓰고 귀찮아서 라고 읽어주세요) 시간이 부족하기 때문에 url을 떄렸습니다 방생성 : <a href="http://localhost:8080/create?name=A1&amp;x=10&amp;y=10&amp;method=create" target="_blank" rel="noopener">http://localhost:8080/create?name=A1&amp;x=10&amp;y=10&amp;method=create</a> number 마킹 : <a href="http://localhost:8080/putItem?name=A1&amp;x=1&amp;y=1&amp;method=number&amp;number=1" target="_blank" rel="noopener">http://localhost:8080/putItem?name=A1&amp;x=1&amp;y=1&amp;method=number&amp;number=1</a> (1,1) 좌표에 숫자 1이 찍힙니다 <img src="https://github.com/devahea/2018hackerton-viewer/blob/master/ex1.PNG?raw=true" alt="이미지1"> block 마킹 : <a href="http://localhost:8080/putItem?name=A1&amp;x=1&amp;y=2&amp;method=block" target="_blank" rel="noopener">http://localhost:8080/putItem?name=A1&amp;x=1&amp;y=2&amp;method=block</a> (1,2) 좌표가 블록됩니다 (윽 해커톤땐 잘 됬었음요) <img src="https://github.com/devahea/2018hackerton-viewer/blob/master/ex2.PNG?raw=true" alt="이미지2"> room 마킹 : <a href="http://localhost:8080/putItem?name=A1&amp;x=1&amp;y=3&amp;method=room" target="_blank" rel="noopener">http://localhost:8080/putItem?name=A1&amp;x=1&amp;y=3&amp;method=room</a> (1,3) 좌표가 o로 마킹 됩니다 <img src="https://github.com/devahea/2018hackerton-viewer/blob/master/ex3.PNG?raw=true" alt="이미지2"></p><h1 id="마무리"><a href="#마무리" class="headerlink" title="마무리"></a>마무리</h1><p>아해 해커톤에서 누리카베를 실시간으로 보여주기위한 view 프로젝트를 진행했습니다 짧은 시간에 샘플 코드를 빨리 찾아서 빠르게 개발해볼 수 있었습니다</p>]]></content>
      
      
      <categories>
          
          <category> 미분류 </category>
          
      </categories>
      
      
    </entry>
    
    <entry>
      <title>[2018 해커톤] ahea 해커톤 누리카베 리뷰</title>
      <link href="/2018/09/10/2018-ahea-hackerton-eb-a6-ac-eb-b7-b0/"/>
      <url>/2018/09/10/2018-ahea-hackerton-eb-a6-ac-eb-b7-b0/</url>
      
        <content type="html"><![CDATA[<p>올해 2018 아해 해커톤은 누리카베라는 게임을 해커톤으로 진행 하기로 했다.</p><p>누리카베에 대한 게임의 설명은 다음 사이트에 잘 나와있다.</p><p><a href="https://ko.puzzle-nurikabe.com/" target="_blank" rel="noopener">https://ko.puzzle-nurikabe.com/</a></p><p>누리카베를 위 사이트에서 크롤링하고 이미지를 OCR로 변환한다음 Map을 DB에 Insert 하는 서버.</p><p>서버에서 데이터를 받아와서 문제를 푼 사용자에게 Ranking을 매기고 계산하는 Front.</p><p>또 인원을 나누어 팀끼리 퍼즐을 풀어내는 Client까지 계획했다.</p><p>예상되는 시스템 구성은 다음과 같은데</p><p><img src="https://ahea.files.wordpress.com/2018/09/1.png" alt="1"></p><p>팀 공통 주제 중 내가 맡은 건 크롤러가 가져온 데이터를 파싱해서 db에 insert 하는 부분이었는데</p><p>2가지 방법을 생각했다.</p><p>1)</p><ol><li><p>div값 좌표를 크롤링</p></li><li><p>크롤링 된걸 데이터화</p></li><li><p>데이터 insert</p></li></ol><p>2)</p><ol><li><p>크롤링으로 이미지 캡쳐</p></li><li><p>ocr - 크롤링 된걸 데이터 화</p></li><li><p>데이터 insert</p></li></ol><p>2번의 경우는 이미지를 캡쳐하는 라이브러리, OCR 라이브러리 두가지의 사용법을 알아야 해서</p><p>빠르게 진행하는 해커톤에 맞지 않아 30분만 살펴보고 쉽지 않을것 같으면 바로 1번으로 바꾸기로 했다.</p><p>쉽게 되지 않을것 같아서 2번으로 진행했고 총 3명의 팀원이서</p><p>각각 jhipster로 환경구축, 데이터 크롤링, 크롤링 한것을 db형식에 맞게 파싱.</p><p>프론트와 독립적으로 진행되기 때문에 디비 구조 부터 잡았어야 했는데 구조는 다음과 같이 잡았다.</p><p>숫자가 있는값은 숫자로 될 수 있도록 했고,</p><p>1~XX 까지는 쓰일 수 있는 숫자여서, 빈칸 -1, ㅁ-&gt; 0 , 숫자 -&gt; 숫자 이런식으로 설계했다.</p><p><img src="https://ahea.files.wordpress.com/2018/09/2.png" alt="2"></p><p>크롤링 개발과 독립적으로 파싱하는것을 만들기 위해 누리카베 사이트를 살펴봤는데</p><p>소스코드를 보면 다음과 같이 되어있다.</p><p><img src="https://ahea.files.wordpress.com/2018/09/3.png" alt="3"></p><p>div 클래스 이름으로 각각 어떤 상태인지 구분 할 수 있었다.</p><pre><code>\* cell selectable cell-off - 흰벽\* nurikabe-task-cell wall  - 점선벽\* nurikabe-task-cell       - 숫자</code></pre><p>파싱을 할때 html -xml 파서를 이용했어야 했는데 몰라서 String을 split 로 짤라서 구분했다.</p><p>줄바꿈은 top의 px가 달라지면 줄바꿈으로 인식하도록 했다.</p><p>그런데 문제가 된게 빈칸은 똑같은 줄에 있더라도 px가 달랐는데 이는 누리카베 경계가 되는 선</p><p>때문에 같은 줄에 있어도 px 차이가 났다.</p><p>해결책은 top 픽셀값이 +-2 가 넘어가면 줄바꿈으로 인식되게 수정했다.</p><p>파싱 개발을 다 마치고 누리카베 문제 풀이에 들어갔는데 팀원들과 회의를 하는데 의견은 대충</p><p>나 : 패턴으로 검색</p><p>호훈님 : 전체를 검색</p><p>PM 의견 : 패턴으로 하는 팀은 있고, 어떤 문제는 전체를 대입해 봐야 하니 전체 패턴을 찾고 소거법으로 제거 해 가자.</p><p>결론은</p><ol><li><p>맵에서 좌표, 숫자를 추출해내자.</p></li><li><p>숫자로 표시된 타일의 갈 수 있는 모든 경우의 수 추출.</p></li><li><p>2번에서 구한 경우의 수가 1번에 경로에 있으면 삭제</p></li><li><p>3번에서 나온 경우의 수와 다른 숫자의 경우의 수의 교집합을 찾음.</p></li><li><p>나온 교집합들에 게임룰을 적용해서 안되는 패턴을 제거한다.</p></li></ol><p>이렇게 나온 순서도를 서로 팀원들과 나누어 진행했는데 이런 문제는 많이 풀어보지 못해서 생각보다 시간이 엄청 오래 걸렸다.</p><p>먼가 항상 기술 공부만 해서 이렇게 어떤 자료구조를 쓰고 어떻게 값을 수정하고 이런걸 많이 안해보니깐 퍼포먼스도 안나오고 그래도 4년차인데 내가 신입때 생각했던 4년차의 퍼포먼스가 나오지 않는것 같다. 문제는 알고 있는데 고치지 않으면 발전이 없는데 발전없이 살고 있었던것 같다. 어디가서 개발자라고 하기에 창피한 실력인것 같다. 그래도 더 기간이 지나기 전에 알아차릴수 있어서 다행이다.</p><p>—-  마지막으로 해커톤을 참석하신 분들의 후기  —-</p><p>종인 - 1박2일이라 컨디션 조절을 좀 신경안써서 좋았다. 2박3일이면 쪽잠 자고 해야겟다 생각… 이번밤만 지나면 끝이니깐.. 좀 더 열심히 했다. 다른걸로 시간을 안뺏겨서 좋았다. 환경설정 등등</p><p>먹을것도 먹었고 투덜거림이 없음. 다른 사람과 커뮤니케이션 못한게 아쉽. 알고리즘.. 힘들었다 재미있고 머리 안터지는걸로…. 알고리즘 준비 안했으면 무의미 했다.</p><p>호훈님 - 괜찮았다… 팀안에서 이해 수준이 비슷해서 좋았다. 진행이 수월했음. 처음에 목적이 알고리즘이 었는데.. 다른거에 시간을 뺏겨서 아쉽다. 결론적으로 안써먹다. 주제에만 집중하면 좋았을것.</p><p>근열님 - 행사가 처음이라 새롭기도 하고 배울점이 많았음. 해보지 않았던걸 해서 재미있었는데 이해 못하는것도 많았음. 평균적인 실력이 부족한거같아 힘들었다. 전체적으로 빨리 진행해야 하는데 못해서 힘듬. 개선 할 점은 개인적인 역량이 조율이 되서 행사진행 할때 원활 했으면 좋겟다.</p><p>홍신님 - 안해봤던것들 jpa같은 것들 사용법을 경험해본것이 좋았다. 필요한 기술 스택을 몰라 진행하는데 쉽지 않았다. 일주일 전에 예비 모임을 가졌으면 좋겟다. 누리카베에 대한 기획이나 처음에 세팅, 준비해야할것들 시간을 줄이고 실제로 계획을 더 많이 세웠으면 좋을것 같다. 준비없이 해서 민폐인것 같다.</p><p>문겸님 - 새로운 기술 몰랐던거 접해볼수 있어서 좋았음. 새로운 걸 시도 할때 주목적이 알고리즘이었는데 환경설정에 오래 걸려서 정작 알고리즘 구현하는데 힘들었음. 개선할점은 필요한 부분 같은 걸 사전모임으로 최소 기술 스펙정도는 보고 올 수 있을정도로 하면 좋을것 같다.</p><p>민수님 - 팀원 세분이 새로운걸 도전했고, 피드백이 좋아서 만족. 팀원이 접해본것만 해도 만족. 시간적인 부분을 보면 새로운 기술이 아니라 서로 잘 아는걸로 프로토 타입을 만들었으면 빨랐을것 같다. 스프링5 쓰면 머 하지도 못했을것. 초점을 잘 캐치 하지 못한것 같다. 이해 못하거나 커뮤니케이션 부분들에 있어서 수정하는데 시간이 오래 걸렸다. 작년에는 멀 해야할지 머리속에 그려졌는데, 구현 방식을 몰랐다. 이번에는 뭘 해야할지 감이 없었다. 이번이 어려웠던 시간 이었음. 목표를 정하고 각자 할 수 있는 기술로 하면 달라지지 않았을까…</p><p>경운 - 알고리즘이라 힘들었음. 같이 일하는 사람들 실력을 파악할수 있어서 좋았음.</p><p>성현 - 난 완성 다함. 못써봐서 아쉬움. 행사를 유지 하고 있는것만 으로 좋음. 협업을 하지 않음. 다 자서 나도 잤음. 완성을 못하고…. 아쉬움. 다들 뭐 했나….. 어떻게 소개 시켜줄지 걱정스러움. 내년부터는… 침대있는곳 안되겟다… 마음가짐도 중요할것 같다. 비싼 개발자들 일 안해서 고민중…. pm의 욕심이 과하지 않았나… 개인적 목표는 치고박고 싸우고 안해봤던거 하고 다른사람들 보고 배우고 팔로업도 해주고… 팀끼리 잘된것 같다. si개발자들 안해본것 해봐서 좋았음.</p><p>스터디 한 걸 많이 집어 넣지 못함. 팀끼리 경계선을 볼 수 있어서 좋았다. 개인적으로 만족스럽지 않음. 배워가는 느낌이 있엇는데… 그런게 없었음.</p>]]></content>
      
      
      <categories>
          
          <category> 해커톤 </category>
          
      </categories>
      
      
    </entry>
    
    <entry>
      <title>선택이 아닌 필수 TDD</title>
      <link href="/2018/09/10/ec-84-a0-ed-83-9d-ec-9d-b4-ec-95-84-eb-8b-8c-ed-95-84-ec-88-98-tdd/"/>
      <url>/2018/09/10/ec-84-a0-ed-83-9d-ec-9d-b4-ec-95-84-eb-8b-8c-ed-95-84-ec-88-98-tdd/</url>
      
        <content type="html"><![CDATA[<h3 id="Test-First-Development"><a href="#Test-First-Development" class="headerlink" title="Test-First Development"></a>Test-First Development</h3><p>TDD = TFD(Test-First Development) + Refactoring</p><p>TDD는 TFD와 리팩토링이 합쳐진 개발 방법론으로 소프트웨어 엔지니어인 켄트 벡(KentBeck)에 의해 고안된 실제 코드를 작성하기 전 테스트 코드를 먼저 작성하여 개발하는 SW 개발 방법론이다.</p><blockquote><p>What is the primary goal of TDD? One view is the goal of TDD is specification and not validation (Martin, Newkirk, and Kess 2003). In other words, it’s one way to think through your requirements or design before your write your functional code (implying that TDD is both an important agile requirements and agile design technique). Another view is that TDD is a programming technique. As Ron Jeffries likes to say, the goal of TDD is to write clean code that works. - agiledata</p></blockquote><p>TDD는 디자인, 기술적 관점에 따라 기본적인 목표는 다르다. 첫 번째로 디자인 관점으로는 검증이 아닌 명세를 목표로 하고 있다. 즉 TDD 자체가 요구사항이고 디자인으로 생각한다. 또 다른 기술적인 관점에서의 TDD의 목표는 작동하는 깨끗한 코드(<code>Clean code that works(중복이 없고 명확한 코드)</code>)를 작성하는 것이다. TDD는 일반적인 개발 프로세스의 고질적인 문제점들을 고안해서 나온 개발 방법론이다. 그 때문에 TDD와 일반 개발 프로세스는 차이를 보면 우리가 왜 TDD를 해야 하는지 알 수 있다.</p><hr><h3 id="일반적인-개발-프로세스의-문제점들"><a href="#일반적인-개발-프로세스의-문제점들" class="headerlink" title="일반적인 개발 프로세스의 문제점들"></a>일반적인 개발 프로세스의 문제점들</h3><p>  <img src="https://ahea.files.wordpress.com/2018/09/tdd1.png?w=300" alt=""></p><p>일반적인 개발 프로세스</p><p>일반적인 개발 프로세스는 <code>설계(디자인) &amp;gt; 개발(코드 작성) &amp;gt; 테스트</code>하는 단계를 반복한다. 실제 실무에서 개발자 대부분이 <code>일반적인 개발 프로세스</code>를 따라가고 있다. 이러한 개발 방법론에 익숙해진 개발자가 보기엔 고질적인 문제점을 찾아 볼 수 없다. 어쩌면 개발에 나타나는 문제점들이 당연하다고 여기고 있을 수 있다. 하지만 <code>일반적인 개발 프로세스</code>에서의 문제점은 크게 세 가지로 나타난다.</p><blockquote><ul><li>자체 버그 검출 능력 저하</li><li>소스코드의 품질 저하</li><li>자체 테스트 비용의 증가</li></ul></blockquote><p>이 문제점들이 발생되는 이유는 간단하다. 어느 프로젝트든 초기 설계가 완벽하다고 말할 수 없기 때문이다. 고객의 요구사항 또는 디자인의 오류 등 많은 외부 또는 내부 조건에 의해 재설계하여 점직전으로 완벽한 설계로 나아간다. 재설계로 인해 개발자는 코드를 삽입, 수정, 삭제하는 과정에서 쓰레기 코드가 남거나 코드가 중복처리 될 가능성이 크다. 결론적으로 이러한 코드들은 재사용이 어렵다. 더 나아가 코드가 복잡해지고 관리가 어려워져 유지보수를 어렵게 만든다. 이러한 코드는 작은 부분의 기능 수정에도 모든 부분을 테스트해야 하므로 전체적인 버그를 검출하기 어려움이 따라 <code>자체 버그 검출 능력</code>이 저하된다. 그 결과 어디서 버그가 발생할지 모르기 때문에 잘못된 코드도 고치지 않으려 하는 현상이 나타나고 이러한 현상은 <code>소스코드의 품질 저하</code>에 직결된다. 작은 수정에도 모든 기능을 다시 테스트해야 하는 문제가 발생하여 <code>자체 테스트 비용</code>이 증가 된다.</p><h3 id="두려움을-관리하는-TDD"><a href="#두려움을-관리하는-TDD" class="headerlink" title="두려움을 관리하는 TDD"></a>두려움을 관리하는 TDD</h3><blockquote><p>Test-driven development (TDD) is a way of managing fear during programming. - Kent Beak</p></blockquote><p>  켄트 벡은 자신의 글에 ‘TDD는 개발에 있어 두려움을 관리해준다.’라고 명시했다. 여기서의 두려움이란 <code>일반적인 개발 프로세스</code>에서 나타난 여러 문제점을 뜻한다. 이러한 문제점들은 중복된 코드로부터 시작되는데  <code>Clean code that works</code>를 추가하는 TDD는 이러한 중복된 코드로부터 발생하는 많은 문제점을 해결해준다. 무엇보다 TDD와 <code>일반적인 개발 프로세스</code>의 가장 큰 차이점은 테스트 코드를 작성한 뒤에 코드를 작성한다는 점이다. <img src="https://ahea.files.wordpress.com/2018/09/tdd2.png?w=300" alt=""></p><p>TDD 개발 프로세스</p><p>TDD의 개발 프로세스는 다음과 같다. <code>디자인(설계)</code> 단계에서 프로그래밍 목적을 반드시 미리 정의해야만 하고 또 무엇을 테스트해야 할지 미리 정의(테스트 케이스 작성)해야만 한다. <img src="https://ahea.files.wordpress.com/2018/09/architecturetfd.png?w=284" alt=""></p><p>TFD 순서도</p><p><code>테스트 케이스</code>가 작성된 후 <code>테스트 코드 작성</code> 단계에서 <code>TFD 개발 프로세스</code>와 같은 방식으로 테스트 코드를 작성한다. 테스트 코드를 작성하는 도중에 발생하는 예외 사항(버그, 수정사항)들은 <code>테스트 케이스</code>에 추가하고 설계를 개선한다. 이후 테스트가 통과된 코드만을 <code>코드 작성</code> 단계에서 실제 코드를 작성한다. 이러한 반복적인 단계가 진행되면서 자연스럽게 코드의 버그는 줄어들고, 소스코드는 간결해진다. 또한, <code>테스트 케이스</code> 작성으로 인해 자연스럽게 설계가 개선됨으로 재설계 시간이 절감된다.</p><hr><h3 id="Clean-Code"><a href="#Clean-Code" class="headerlink" title="Clean Code"></a>Clean Code</h3><p>TDD의 목표는 작동하는 깨끗한 코드(<code>Clean code that works</code>)를 작성하는 것이다. 하지만 아직도 ‘TDD는 어떻길래 중복코드가 없어지는 마술을 보이는 걸까?’는 의문이 생긴다.</p><blockquote><ul><li>Don’t write a line of new code unless you first have a failing automated.</li><li>Eliminate duplication. - KentBeck</li></ul></blockquote><p>켄트 벡은 이에 <code>Clean code that works</code>에 대한 TDD를 두 가지 과정으로 정의했다. 처음 실패한 자동화 코드가 없으면 새로운 코드 행을 작성하지 않는다. 그다음 중복을 제거한다고 정의했지만 <code>Clean code that works</code>가 되어가는 과정이 명확하지 않다. TDD를 숙련한 사람이라면 켄트 벡의 정의에 대해 이해를 할 수 있지만, TDD의 입문자가 보기엔 켄트 벡의 정의는 너무나도 추상적이고 함축적이다. 여기서 TTD의 순서도를 보면 켄트 벡이 정의한 두 가지 원칙과 더불어 Clean Code가 되어가는 과정을 명확히 알 수 있다.   <img src="https://ahea.files.wordpress.com/2018/09/architecturetdd.png?w=300" alt=""></p><p>TDD 순서도</p><p>1) 하나의 작은 단위의 테스트 코드를 작성한다. 2) 테스트를 한다. 3) 테스트가 통과될 때까지 테스트 코드를 수정한다. 4) 테스트가 통과된 테스트 코드는 리펙토링을 한다. 5) 리펙토링한 코드를 테스트한다. 6) 리펙토링한 코드가 통과 될때까지 코드를 수정한다. 7) 테스트가 통과되면 테스트 케이스에 있는 다음 테스트 코드를 작성한다. 이처럼 TDD는 작은 단위부터 시작하여 점진적으로 개발한다. 이때 일련의 반복적인 과정을 통해 자연스럽게 코드는 명확해지고 깔끔해진다. 여기서 우리는 한가지 규칙적인 반복 패턴을 볼 수 있다.</p><hr><h3 id="밥-삼촌의-TDD-Cycle"><a href="#밥-삼촌의-TDD-Cycle" class="headerlink" title="밥 삼촌의 TDD Cycle"></a>밥 삼촌의 TDD Cycle</h3><p>클린 코드 책의 저자로 유명한 로버트 C 마틴(엉클 밥)은 TDD의 개발 프로세스를 따라가다 보면 발생하는 반복적인 패턴에 대해 시간별로 주기를 정의했다.</p><blockquote><p>I sat with KentBeck in 1999 and paired with him in order to learn.  What he taught me to do was certainly test first; but it involved a more fine-grained process than I’d ever seen before. He would write one line of a failing test, and then write the corresponding line of production code to make it pass. Sometimes it was slightly more than one line; but the scale he used was was very close to line by line. - Robert C. Martin(Uncle Bob)</p></blockquote><p>위의 글을 보면 켄트 벡은 행(line) 단위의 테스트를 진행을 지향하여 개발한다는 걸 알 수 있다. 행 단위의 테스트는 밥이 제시한 세 가지 규칙에 따라 진행된다.</p><h4 id="TDD의-세-가지-규칙"><a href="#TDD의-세-가지-규칙" class="headerlink" title="TDD의 세 가지 규칙"></a>TDD의 세 가지 규칙</h4><p>밥이 제시한 TDD의 세 가지의 규칙은 다음과 같다.</p><ol><li>먼저 실패하는 테스트 코드를 작성한다.</li><li>컴파일은 실패하지 않으면서 실행이 실패하는 정도로만 테스트 코드를 작성한다.</li><li>현재 실패하는 테스트 코드가 통과된 코드만 실제 코드에 작성한다.</li></ol><p>이 세 가지 규칙은 나노 주기라 불린다. 그 이유인즉슨 코드의 행 단위의 개발 및 테스트가 이루어지게 된다. 이때 초 단위의 반복적인 테스트 주기가 발생하게 되는데 이 주기를 TDD의 나노 주기라 불린다.  켄트 벡과 밥은 테스트 코드 작성에 있어 다양한 스타일이 있지만, 위와 같은 세 가지 규칙을 벗어난 개발 스타일을 금기시하고 있다.</p><h4 id="RGR-Cycle"><a href="#RGR-Cycle" class="headerlink" title="RGR Cycle"></a>RGR Cycle</h4><blockquote><p>If we pull back to the minute by minute scale we see the micro-cycle that experienced TDDers follow. The Red/Green/Refactor cycle. - Robert C. Martin(Uncle Bob)</p></blockquote><p>초 단위에 발생되는 나노 주기가 있다면 분 단위에 발생되는 RGR 주기가 있다. <img src="https://ahea.files.wordpress.com/2018/09/tdd4.png?w=300" alt=""></p><p>RGR Cycle</p><p>RGR 주기는 단위 테스트(Unit Test)마다 발생된다. RGR 주기의 규칙은 다음과 같다.</p><ol><li>Red           실패하는 단위 테스트 만들기</li><li>Grean       테스트가 통과하도록 작성하기</li><li>Refactor   통과된 테스트 코드를 리팩토링하기</li></ol><blockquote><p>Write a test, make it run, make it right. To make it run, one is allowed to violate principles of good design. Making it right means to refactor it. - KentBeck</p></blockquote><p>여기서 우리는 Red 단계에서 Green로 진행되는 과정을 살펴봐야된다. 이 과정에서 켄트 벡은 테스트가 통과하기 위해 금기(복붙, 설계를 무시한 개발)가 되는 행동을 해도 된다고 한다. 이때 발생하는 중복된 코드, 올바르지 못한 구조 등은 Refactor 단계에서 해결해준다고 말한다. 이 점은 로직에 따라서 <code>일반 개발 프로세스</code>보다 개발속도가 더 나올 수 있다는 점을 알 수 있다.</p><blockquote><p>Make It Work Make It Right Make It Fast - KentBeck</p></blockquote><p>RGR 주기에 대한 아이디어는 켄트 벡의 빨리 작동하는 코드 개발(TDD 원초적인 공식)으로 부터 착안했다. 결국 그 원초적인 공식에 따라 RGR 주기는 소프트웨어가 제대로 작동하는 데에 목적이 있다. 또한 RGR 주기는 실제 개발 단계에서 개발과 동시에 리팩토링을 하기 위한 활동이다.</p><h3 id="시간단위의-마일스톤"><a href="#시간단위의-마일스톤" class="headerlink" title="시간단위의 마일스톤"></a>시간단위의 마일스톤</h3><p>TDD의 마지막 주기는 이전의 주기들을 통해 <code>Clean Architecture</code>로 이끌어가는 주기이다. 이전의 주기들을 매시간 단위로 점검하는 과정을 통해 제어해야 한다. 이유인즉슨 나노 주기와 RGR 주기는 작은 단위에 초점을 맞춰 빠르게 진행되고 있어서 개발의 방향성을 잃을 수 있는 위험이 크기 때문이다. 그로 인해 이 주기에서는 테스트 케이스를 통해 개발에 대한 방향성 및 구조적인 상황을 점검하는 시간을 가져야 한다.</p><hr><h3 id="Unit-Test"><a href="#Unit-Test" class="headerlink" title="Unit Test"></a>Unit Test</h3><p>앞서 TDD의 주기들은 어디까지나 TDD가 <code>Clean code that works</code>을 지향하고 있기 때문이다. <code>Clean code that works</code>를 실현하기 위해선 리펙토링 과정은 필연적이다. 리펙토링은 RGR 주기에서 단위 테스트 단위로 이루어지고 있는데 이 때문에 단위 테스트와 TDD는 밀접한 관계를 맺고 있다. 다만 주객이 바뀌면 안 된다. 이 점은 많은 개발자가 오해하는 부분인데 단위 테스트를 하는 이유는 TDD가 지향하는 <code>Clean code that works</code>을 실현하기 위한 일종의 방법이지 단위 테스트를 하기 위해 TDD를 한다는 건 말은 모순이기 때문이다.</p><blockquote><p>TDD                 설계 프로세스 단위 테스트   정밀한 테스트 케이스</p></blockquote><p>  일반적으로 단위 테스트는 객체 또는 모듈의 함수(자바에서는 클래스)에 초점을 맞춘다. 테스트가 단일 기능에 한정되도록 함으로써 테스트는 간단하고 신속하게 이루어진다. 특히 단위 테스트는 코드를 변경해야 하는 경우 유용하다. 코드가 작동하는지 확인하는 단위 테스트가 있으면 코드를 안전하게 변경할 수 있고 실행 시 다른 부분에서 프로그램이 중단되지 않는다는 점을 확신할 수 있다.</p><h4 id="단위-테스트의-FIRST-규칙"><a href="#단위-테스트의-FIRST-규칙" class="headerlink" title="단위 테스트의 FIRST 규칙"></a>단위 테스트의 FIRST 규칙</h4><p>다음과 같이 밥은 단위 테스트의 규칙을 정의했다. <img src="https://ahea.files.wordpress.com/2018/09/tdd5.png?w=300" alt=""></p><p>단위 테스트의 F.I.R.S.T 규칙</p><ul><li><p>단위 테스트는 빨라야 한다. - Fast</p></li><li><p>단위 테스트는 독립적으로 작성한다. - Independent</p></li><li><p>단위 테스트는 어느 환경에서든 반복 가능해야 한다. - Repeatable</p></li><li><p>단위 테스트는 자체검증이 되어야 한다. - Selef-Validating</p></li><li><p>단위 테스트는 실제 코드를 작성 전에 작성해야 한다. - Timely</p></li></ul><p><strong>Fast</strong> 테스트는 빨라야 한다. 여기서 빠름의 기준은 밀리 초(ms)이다. 단위 테스트를 테스트하는 데 있어 실행 시간이 0.5 초 또는 0.25 초가 걸리는 테스트는 빠른 테스트가 아니다. 하나의 프로젝트에서 적게는 몇백 개에서 많게는 수천 개의 테스트를 할 수 있으므로 테스트의 실행 시간은 빨라야 한다. 만약 테스트가 느리다면 개발자는 테스트를 주저하게 되고 자주 검증하지 않은 소스코드는 그만큼 버그가 발생할 확률이 높아진다. <strong>Independent</strong> 테스트에 사용된 데이터들은 서로 의존하면 안 된다. 테스트에 필요한 데이터는 테스트 내부에서 독립적으로 사용해야 한다. 만약 데이터가 서로에게 의존하면 테스트 하나가 실패할 때 나머지도 잇달아 실패하므로 원인을 진단하기 어려워지기 때문이다. 때론 데이터의 존재 여부를 찾는 테스트가 있는 경우엔 해당 데이터는 테스트 내부에서 생성되어야 하며 나중에 테스트에 영향을 미치지 않도록 제거해야 한다. <strong>Repeatable</strong> 테스트는 어느 환경에서든 반복적으로 테스트를 실행할 수 있어야 한다. 여기서 환경은 네트워크 나 데이터베이스에 의존하지 않는 환경을 뜻한다. 결론적으로 인터넷이 되든 안 되든 데이터베이스에 접속하든 안 하든 언제 어디서나 테스트를 할 수 있어야 한다. 환경에 의존하지 않는 테스트가 실패할 수 있는 유일한 이유는 오로지 테스트할 클래스 또는 메소드가 제대로 작동하지 않기 때문이다. <strong>Selef-Validating</strong> 테스트는 자체 검증이 되어야 한다. 테스트의 검증은 수작업이 아닌 자동화가 되어야 하는데 테스트가 실행될 때마다 메서드 출력이 올바른지를 확인하는 것은 개발자가 결정해서는 안 된다. 이 때문에 자바 환경에서는 테스트에 대한 검증을 지원하는 JUnit을 사용하여 테스트의 통과 여부를 결정한다. <strong>Timely</strong> - 단위 테스트는 실제 코드를 작성하기 전에 작성해야된다. 이 규칙은 TDD를 수행하는 경우 반드시 따라야 하는 규칙이다. FIRST 규칙은 단위 테스트를 작성하는 데 좋은 기준이 된다. 좀 더 다양한 단위 테스트를 작성하는 방법은 밥의 Clean Code 책을 참고하자.</p><hr><h3 id="결론"><a href="#결론" class="headerlink" title="결론"></a>결론</h3><p>TDD는 <code>Clean code that works</code>를 목표로 한다. TDD는 TDD Cycle이라는 반복적인 주기가 발생한다. <code>Clean code that works</code>의 실현은 TDD Cycle 중 RGR 주기의 리펙토링 통해 이루어진다. 이 과정에서 테스트 코드는 중복 제거가 이루어지는데 여기서 중복 제거는 단순한 코드의 중복 제거를 넘어서 반복적인 기능을 하나의 클래스(또는 인터페이스)로 묶는 과정을 뜻하기도 한다. 즉 구조가 재설계 되기도 하는데 이러한 결과에서 우리는 TDD가 코드뿐만이 아닌 <code>Clean Architecture</code>를 실현하는 개발 방법론으로 사용할 수 있다는 점을 알 수 있다. 또한, 반복적인 자동화된 검증 과정을 통해 개발자에게 코드에 대해 신뢰를 하게 해줄뿐더러 더 나아가 소프트웨어의 버그 발생률을 감소시키고 품질 향상에 도움을 준다.</p><blockquote><p>TDD를 도입한 소프트웨어는 약 15~35% 정도의 개발시간 증가, 결함율(버그)은 약 40~90% 정도 줄어들었다. - Microsoft, IBM</p></blockquote><p>위와 같이 연구 자료들은 TDD가 선택이 아닌 필수라는 사실을 대변하고 있다. 자세한 TDD의 자세한 기대효과를 알고 싶다면 <a href="https://www.researchgate.net/publication/3188484_On_the_effectiveness_of_the_test-first_approach_to_programming" target="_blank" rel="noopener">On the Effectiveness of the Test-First Approach to Programming</a>을 참고하자.</p><p><strong>Test</strong> <strong>Refectoring</strong> <strong>Clean code that works</strong></p><p><strong>.</strong> <strong>.</strong> <strong>.</strong></p><p><strong>TDD Cycle</strong></p><p><strong>.</strong> <strong>.</strong> <strong>.</strong></p><p><strong>Clean Architecture</strong></p><p><strong>.</strong> <strong>.</strong> <strong>.</strong></p><p><strong>TDD</strong></p><hr><h3 id="참고"><a href="#참고" class="headerlink" title="참고"></a>참고</h3><p><a href="https://www.eecs.yorku.ca/course_archive/2003-04/W/3311/sectionM/case_studies/money/KentBeck_TDD_byexample.pdf" target="_blank" rel="noopener">https://www.eecs.yorku.ca/course_archive/2003-04/W/3311/sectionM/case_studies/money/KentBeck_TDD_byexample.pdf</a> <a href="http://agiledata.org/essays/tdd.html" target="_blank" rel="noopener">http://agiledata.org/essays/tdd.html</a> <a href="https://www.microsoft.com/en-us/research/group/empirical-software-engineering-group-ese/?from=http%3A%2F%2Fresearch.microsoft.com%2Fen-us%2Fgroups%2Fese%2Fnagappan_tdd.pdf" target="_blank" rel="noopener">https://www.microsoft.com/en-us/research/group/empirical-software-engineering-group-ese/?from=http%3A%2F%2Fresearch.microsoft.com%2Fen-us%2Fgroups%2Fese%2Fnagappan_tdd.pdf</a> <a href="https://blog.cleancoder.com/uncle-bob/2014/12/17/TheCyclesOfTDD.html" target="_blank" rel="noopener">https://blog.cleancoder.com/uncle-bob/2014/12/17/TheCyclesOfTDD.html</a> <a href="http://blog.cleancoder.com/uncle-bob/2013/09/23/Test-first.html" target="_blank" rel="noopener">http://blog.cleancoder.com/uncle-bob/2013/09/23/Test-first.html</a> <a href="http://wiki.c2.com/?MakeItWorkMakeItRightMakeItFast" target="_blank" rel="noopener">http://wiki.c2.com/?MakeItWorkMakeItRightMakeItFast</a> <a href="http://agileinaflash.blogspot.com/2009/02/first.html" target="_blank" rel="noopener">http://agileinaflash.blogspot.com/2009/02/first.html</a> <a href="https://pragprog.com/titles/olag/agile-in-a-flash" target="_blank" rel="noopener">https://pragprog.com/titles/olag/agile-in-a-flash</a> <a href="https://codeutopia.net/blog/2015/03/01/unit-testing-tdd-and-bdd/" target="_blank" rel="noopener">https://codeutopia.net/blog/2015/03/01/unit-testing-tdd-and-bdd/</a> <a href="https://xebia.com/blog/tdd-not-unit-tests/" target="_blank" rel="noopener">https://xebia.com/blog/tdd-not-unit-tests/</a> <a href="https://builttoadapt.io/why-tdd-489fdcdda05e" target="_blank" rel="noopener">https://builttoadapt.io/why-tdd-489fdcdda05e</a></p>]]></content>
      
      
      <categories>
          
          <category> 미분류 </category>
          
      </categories>
      
      
    </entry>
    
    <entry>
      <title>IoC (DI, Service Locator...)</title>
      <link href="/2018/09/09/1754/"/>
      <url>/2018/09/09/1754/</url>
      
        <content type="html"><![CDATA[<h1 id="IoC"><a href="#IoC" class="headerlink" title="IoC"></a>IoC</h1><p><strong>Inverse of Control</strong>는 제어권을 개발자가 아닌 제 3자(프레임워크)가 가지게 하는 것이다. <strong>그렇다면 우리는 왜 제어권을 3자에게 위임해야 하는가?</strong> 이에 대한 답을 찾기전에 과거로 돌아가보자. 과거 많은 형태의 오픈소스들이 나오고 있었고, 이들의 공통적인 이슈는 서로 다른 객체를 어떻게 연결할 것인지에 대한 문제였다. 이를 해결할 한 가지 방법으로 IoC가 제시되었다. 즉, IoC의 주된 목적은 Application의 Dependency를 제거해서 느슨한 결합을 제공하는 것이다. 그럼 Dependency란 무엇일까?</p><blockquote><p>Dependency (computer science) or coupling, a state in which one object uses a function of another object - Wiki</p></blockquote><ul><li>코드에서 두 모듈 간의 연결.</li><li>객체지향언어에서는 두 클래스 간의 관계</li></ul><p>간단한 코드를 작성해보자.</p><p>public class MemberService {<br>    public String parseString(ObjectMapper objectMapper, Member member) throws JsonProcessingException {<br>        return objectMapper.writeValueAsString(member);<br>    }<br>}</p><p>위 코드는 Jackson 라이브러리의 <code>ObjectMapper</code>를 이용하여 특정 객체를 Json String으로 변환작업을 하는 로직이다. <code>MemberService</code>는 <code>ObjectMapper</code>의 기능을 사용하고 있기 때문에 의존하고 있다고 할 수 있다. <code>ObjectMapper.writeValueAsString()</code>의 구현부가 변하게 되면 <code>MemberService.parseString()</code> 또한 변하게 된다. 비슷한 개념인 <strong>Coupling</strong>이 있다 Coupling이란 모듈간의 결합도 및 상호의존성의 정도를 말한다. <img src="https://upload.wikimedia.org/wikipedia/commons/thumb/9/9c/Coupling_sketches_cropped_1.svg/600px-Coupling_sketches_cropped_1.svg.png" alt="결합도"> 위의 <code>MemberService</code>는 클래스간의 강하게 결합을 하고 있다. 왜냐하면 몇몇은 JSON 변환 작업을 <code>ObjectMapper</code>를 사용해서 그대로 재사용하면 되지만 다른 몇몇은 <code>Gson</code>을 사용하기 때문에 코드에 전반적인 수정이 필요하다. 이러한 강한 결합을 <strong>Interface</strong>의 도움을 받아 느슨하게 할 수 있다.</p><p>public interface JsonParser {<br>    <t> T parseObject(String s, Class<t> clazz);<br>    <t> String parseString(T obj);<br>}</t></t></t></p><p>public class MemberService {<br>    public String parseString(JsonParser jsonParser, Member member) {<br>        return this.jsonParser.parseString(member);<br>    }<br>}</p><p>이전 코드에서는 <code>MemberService</code> 클래스안에 <code>ObjectMapper</code>가 직접적으로 들어가있었지만, 이번 코드에서는 <code>MemberService</code>는 Interface인 <code>JsonParser</code>만을 알고 있다. 이로 인해 사용자는 원하는 <code>JsonParser</code> 구현체를 입맛에 맞게 사용할 수 있다. 또 다른 사례를 알아보자.</p><p>public class CalendarReader {<br>    public List readCalendarEvents(File calendarEventFile){<br>        //open InputStream from File and read calendar events.<br>    }<br>}</p><p>위의 코드는 XML Local file을 통해서 이벤트 목록을 읽어오는 메소드다. 본인만 쓴다면 문제가 없겠지만, 이 소스를 다수의 사람들이 사용을 해야한다. 그런데 그들 중 일부는 XML을 통해 이벤트를 관리하지만, 다른 몇몇은 DB, Network 등을 통해서 관리를 한다. 즉, 다른 리소스로 관리를 하는 사람은 해당코드를 재사용할 수가 없게 된다. 이를 좀 더 포괄적인 <code>InputStream</code>을 사용하면서 결합을 좀 더 느슨하게 유도 할 수 있다.</p><p>public class CalendarReader {<br>    public List readCalendarEvents(InputStream calendarEventFile){<br>        //read calendar events from InputStream<br>    }<br>}</p><p>이렇듯 느슨한 결합을 통하여 클래스의 재사용성을 높일 수 있다. 또한 재사용성을 높인 다는 말은 비슷한류의 중복코드가 제거될 수 있음을 의미하기도 한다.</p><hr><p>자! 다시 처음으로 돌아가보자. IoC의 주된 목적은 Application의 Dependency를 제거하는 것이라고 하였다. IoC 방식에는 아래 사진외에도 여러가지가 있다 그러나 우리는 몇가지 핵심적인 방식들을 살펴보도록 하자. <img src="https://ahea.files.wordpress.com/2018/09/ecba2-3rdimage.jpg" alt="사진"></p><h2 id="Dependency-Injection"><a href="#Dependency-Injection" class="headerlink" title="Dependency Injection"></a>Dependency Injection</h2><p>IoC 방식 중 가장 대표적인 방식으로 보인다. Interface의 느슨한 결합을 이용하여 Compile 시점에서 Dependency를 가지지 않고, Runtime 시점으로 미룰 수 있다. 이를 좀 더 쉽게 표현하자면, 코드상에서 구현체가 존재하지 않고 단지 Inteface만 존재한다. 이로 인해 구현부가 변경되더라도 해당 코드를 수정하는 것이 아닌 Dependency만 변경해 주면된다. 거두절미하고 코드를 살펴보자.</p><p>public class Member {<br>    private String name;<br>    private int age;<br>    private String address;<br>}</p><p>public class MemberService {<br>    private final ObjectMapper objectMapper = new ObjectMapper();</p><pre><code>public String parseString(Member member) throws JsonProcessingException {    return this.objectMapper.writeValueAsString(member);}public Member parseObject(String member) throws IOException {    return this.objectMapper.readValue(member, Member.class);}</code></pre><p>}</p><p>위의 코드는 <code>Member</code> 객체를 JSON 형태의 <code>String</code>으로, JSON형태의 <code>String</code>을 <code>Member</code>객체로 변환하는 코드이다. 그런데 특정한 이슈(Library 지원 종료, 속도 문제, 회사 정책 등)로 인하여 JSON 변환 Library 인 <code>ObjectMapper</code>를 <code>Gson</code>이나 다른 라이브러리로 교체하고 싶으면 어떻게 될까?</p><p>public class MemberService {<br>    private final Gson gson = new Gson();</p><pre><code>public String parseString(Member member) {    return this.gson.toJson(member);}public Member parseObject(String member) {    return this.gson.fromJson(member, Member.class)}</code></pre><p>}</p><p>아예 새로운 코드가 되어버렸다. 클래스와 메소드 이름만 같지 모든 구현부가 바뀌어버렸다. 개인이 혼자 쓰는 프로젝트라면 상관이 없을 것이다. 그러나 오픈소스 또는 여러 기업에 팔아야되는 입장인데 위처럼 구현부가 변할때마다 코드를 수정해서 줘야 한다면 큰 문제가 있다. 이를 우리가 사용자 입맛에 맞게 일일이 변경해서 주는 것이 아니라, <strong>가이드</strong>를 제공해줌으로써 사용자가 알아서 입맛에 맞게 수정하도록 변경해보자. 앞서 말한 Interface의 도움을 받아 사용자에게 가이드를 줌과 동시에 객체간에 느슨한 결합을 맺어주자.</p><p>public interface JsonParser {<br>    <t> T parseObject(String s, Class<t> clazz);<br>    <t> String parseString(T obj);<br>}</t></t></t></p><p>public class MemberService {<br>    private JsonParser jsonParser;</p><pre><code>public String parseString(Member member) {    return this.jsonParser.parseString(member);}public Object parseObject(String member) {    return this.jsonParser.parseObject(member, Member.class);}</code></pre><p>}</p><p>우리는 위처럼 코드를 작성 후 오픈소스로 공개를 하거나, 다른 기업에 팔면 된다. 그럼 <code>ObjectMapper</code>를 사용하는 기업은 어떻게 자기 입맛에 맞게 구현을 할까? 간단하다.</p><p>public class JacksonParser implements JsonParser {<br>    private final ObjectMapper objectMapper;</p><pre><code>public JacksonParser() {    this.objectMapper = new ObjectMapper();}@Overridepublic &lt;T&gt; T parseObject(String s, Class&lt;T&gt; clazz) {    try {        return this.objectMapper.readValue(s, clazz);    } catch (IOException e) {        throw new JsonParseException(e);    }}@Overridepublic &lt;T&gt; String parseString(T obj) {    try {        return this.objectMapper.writeValueAsString(obj);    } catch (JsonProcessingException e) {        throw new JsonParseException(e);    }}</code></pre><p>}</p><p>다음은 <code>Gson</code>의 구현체이다.</p><p>public class GsonParser implements JsonParser {<br>    private final Gson gson;</p><pre><code>public GsonParser() {    this.gson = new Gson();}@Overridepublic &lt;T&gt; T parseObject(String s, Class&lt;T&gt; clazz) {    return this.gson.fromJson(s, clazz);}@Overridepublic &lt;T&gt; String parseString(T obj) {    return this.gson.toJson(obj);}</code></pre><p>}</p><p>자 그럼 <code>MemberService</code>를 실행시켜보자. 잘 돌아갈 것이다. 는 무슨 <code>NullPointerException</code>이 떨어질 것이다. 왜냐하면 전역변수(jsonParser)로 선언만 해놓았지 구현체를 할당하지 않았기 때문이다. 우리는 전역변수에 인스턴스를 할당하는 방법을 잘 알고있다. 주로 우리는 다음과 같이 인스턴스를 할당한다.</p><p>public class MemberService {<br>    private JsonParser jsonParser = new JacksonParser();<br>}</p><p>public class MemberService {<br>    private final JsonParser jsonParser;</p><pre><code>public MemberSservice() {    this.jsonParser = new JacksonParser();}</code></pre><p>}</p><p>위의 코드의 문제점은 무엇일까? 우리는 지금까지 코드 레벨에서 특정 구현 객체(<code>JacksonParser</code>)를 보이지 않게 숨기려고 했는데, 다시 드러났다. 결국 허사가 된 것이다. 이를 다시 숨기려면 어떻게 해야 될까? 객체 생성을 사용자에게 전가시키고 그 객체를 주입을 받는 것이다. 좀 더 정확하게 말하자면 의존성을(Dependency)을 사용자에 의해 주입(Injection)받는 것이다.</p><h3 id="Constructor-Injection"><a href="#Constructor-Injection" class="headerlink" title="Constructor Injection"></a>Constructor Injection</h3><p>주로 필수적인 Dependency에 사용된다.</p><p>public class MemberService {<br>    private final JsonParser jsonParser;</p><pre><code>public MemberService(JsonParser jsonParser) {    this.jsonParser = jsonParser;}</code></pre><p>}</p><h3 id="Setter-Injection"><a href="#Setter-Injection" class="headerlink" title="Setter Injection"></a>Setter Injection</h3><p>주로 부수적인 Dependency에 사용된다.</p><p>public class MemberService {<br>    private JsonParser jsonParser;</p><pre><code>public void setJsonParser(JsonParser jsonParser) {    this.jsonParser = jsonParser;}</code></pre><p>}</p><h3 id="Method-Injection"><a href="#Method-Injection" class="headerlink" title="Method Injection"></a>Method Injection</h3><p>Setter Injection과 비슷하므로 생략한다. 위의 3가지 경우 중 하나로 구현을 했으면, 사용자는 다음과 같이 사용하면 된다.</p><p>public static void main(String [] args) {<br>    JsonParser parser = new JacksonParser();</p><pre><code>//Constructor InjectionMemberService memberService = new MemberService(parser);//Setter InjectionmemberService = new MemberService();memberService.setParser(parser);memberService.parseObject(...);memberService.parseString(...);</code></pre><p>}</p><p>또한 유닛 테스트를 좀 더 쉽게 할 수 있는 장점이 있다. 유닛 테스트는 일반적으로 외부의 의존성을 제외하고, 해당클래스에 집중을 하는 테스트 기법이다. <code>MemberService</code>의 경우에는 사실 비즈니스 로직이 없이 의존성을 가진 인스턴스의 기능을 사용하는 것 뿐이지만, 로직이 있다고 가정을 하고 작성을 해보자. <code>JsonParser</code>의 구현체들이 직접 실행되는 것이 아닌 Mock, Stub의 개념을 조금 넣어보자. 해당코드는 아래와 같다.</p><p>public class MockJsonParser implements JsonParser {<br>    @Override<br>    public <t> T parseObject(String s, Class<t> clazz) {<br>        return new Member(“김민수”, 26, “수원시”);<br>    }</t></t></p><pre><code>@Overridepublic &lt;T&gt; String parseString(T obj) {    return &quot;{\\&quot;name\\&quot; : \\&quot;김민수\\&quot;, \\&quot;age\\&quot; : 26, \\&quot;address\\&quot; : \\&quot;수원시\\&quot;}&quot;;}</code></pre><p>}</p><p>public static void main(String [] args) {<br>    JsonParser parser = new MockJsonParser();</p><pre><code>//Constructor InjectionMemberService memberService = new MemberService(parser);memberService.parseObject(...);memberService.parseString(...);</code></pre><p>}</p><p>이처럼 주입을 시켜주면 간단하게 테스트를 할 수가 있다. 사실 이 상황에서는 강력함이 보이지 않지만, 만약 이것이 JSON 변환 작업이 아닌 DB나 Network와 연결이 된 작업이라면 직접 해당 리소스와 연결되지 않고 Interface를 구현한 Mock객체로 간단하게 테스트를 해볼 수가 있다. 우리는 지금까지 사용자에게 Dependency Injection을 하게끔 유도함으로 유연하고 재활용가능한 클래스를 만들었다. 좀 더 생각해볼만 한 것은 스프링 레퍼런스와, 마틴파울러의 글에서는 IoC와 DI를 마치 동일하다는 듯이 설명을 해놓았다.</p><blockquote><p>IoC is also known as dependency injection (DI) - Sping Reference</p></blockquote><blockquote><p>As a result I think we need a more specific name for this pattern. Inversion of Control is too generic a term, and thus people find it confusing. As a result with a lot of discussion with various IoC advocates we settled on the name Dependency Injection - Martin Fowler</p></blockquote><p>이 때문에 필자는 처음에 IoC와 DI가 동일한 줄 알았다. 그러나 아까 봤던 그림처럼 IoC에는 여러가지 구현 방법이 존재한다. <strong>개인적인 추측</strong>으로는 많은 경우에서 IoC를 DI로 구현하기 때문에 위처럼 말한 것으로 보인다.</p><h2 id="Service-Locator"><a href="#Service-Locator" class="headerlink" title="Service Locator"></a>Service Locator</h2><blockquote><p>This process is fundamentally the inverse, hence the name Inversion of Control (IoC), of the bean itself controlling the instantiation or location of its dependencies by using direct construction of classes, or a mechanism such as the Service Locator pattern - Spring Reference</p></blockquote><p>Service Locator에 관한 핵심만 말하자면 이를 이용해서도 제어를 역전(IoC)시킬 수 있다. 이 패턴 또한 목적은 Dependency를 제거하는 것이다. 그리고 DI와 비슷한 점이 많아 이해하기가 한결 쉬울 것이다. 구현된 코드를 한번 살펴보도록 하자.</p><p>public class MemberService {</p><pre><code>private final JsonParser jsonParser;public MemberService() {    this.jsonParser = ServiceLocator.jsonParser();}public String parseString(Member member) {    return this.jsonParser.parseString(member);}</code></pre><p>}</p><p>public class ServiceLocator {<br>    public static JsonParser jsonParser() {<br>        //경우에 따라 Singleton이나 다른 Scope로 구현을 하기도 한다.<br>        return new JacksonParser();<br>    }<br>}</p><p>언듯보면 생성자를 통해 의존성을 주입하는 방식과 비슷해 보이기도 한다. 그러나 위에 작성한 Constructor Injection의 실행 코드를 보면 <code>main()</code> 메소드에서 사용자가 직접 <code>new</code> 키워드를 통해 인스턴스를 생성 후 주입을 해준다. 다시말하면 런타임시에 수동적으로 의존성이 연결이 된다. 그러나 Service Locator는 <code>ServiceLocator.jsonParser()</code>에 원하는 인스턴스를 생성해두면 <code>MemberService</code>가 생성이 될 때 직접 <code>ServiceLocator.jsonParser()</code>를 호출하여 능동적으로 의존성을 맺는다. 능동적이란 단어가 좀 긍정적여 보이긴 하지만, 위에서 처럼 테스트코드로 디펜던시를 바꿔야되는 상황을 한번 가정해보자.</p><p>public class ServiceLocator {<br>    public static JsonParser jsonParser() {<br>        //경우에 따라 Singleton이나 다른 Scope로 구현을 하기도 한다.<br>        return new MockJsonParser();<br>    }<br>}</p><p>그럼 <code>ServiceLocator</code>는 테스트할 때와 서비스를할 때의 상황에 따라 코드를 바꿔줘야되는 이슈가 생긴다. 이외에도 안티패턴이라고 여겨지는 몇가지 상황이 있다고 한다.</p><hr><p>참고</p><ul><li><a href="https://www.codeproject.com/Articles/592372/Dependency-Injection-DI-vs-Inversion-of-Control-IO" target="_blank" rel="noopener">https://www.codeproject.com/Articles/592372/Dependency-Injection-DI-vs-Inversion-of-Control-IO</a></li><li><a href="https://en.wikipedia.org/wiki/Dependency" target="_blank" rel="noopener">https://en.wikipedia.org/wiki/Dependency</a></li><li><a href="http://tony-programming.tistory.com/entry/Dependency-%EC%9D%98%EC%A1%B4%EC%84%B1-%EC%9D%B4%EB%9E%80" target="_blank" rel="noopener">http://tony-programming.tistory.com/entry/Dependency-의존성-이란</a></li><li><a href="http://tutorials.jenkov.com/ood/understanding-dependencies.html#whatis" target="_blank" rel="noopener">http://tutorials.jenkov.com/ood/understanding-dependencies.html#whatis</a></li><li><a href="https://martinfowler.com/articles/injection.html" target="_blank" rel="noopener">https://martinfowler.com/articles/injection.html</a></li><li><a href="https://justhackem.wordpress.com/2016/05/14/inversion-of-control/" target="_blank" rel="noopener">https://justhackem.wordpress.com/2016/05/14/inversion-of-control/</a></li><li><a href="https://justhackem.wordpress.com/2016/05/13/dependency-inversion-terms/" target="_blank" rel="noopener">https://justhackem.wordpress.com/2016/05/13/dependency-inversion-terms/</a></li></ul>]]></content>
      
      
      <categories>
          
          <category> 미분류 </category>
          
      </categories>
      
      
    </entry>
    
    <entry>
      <title>2018-해커톤 Crawler</title>
      <link href="/2018/09/09/2018-ed-95-b4-ec-bb-a4-ed-86-a4-crawler/"/>
      <url>/2018/09/09/2018-ed-95-b4-ec-bb-a4-ed-86-a4-crawler/</url>
      
        <content type="html"><![CDATA[<p>저희는 nurikabe 홈페이지에서 퍼즐의 크롤링을 담당했습니다   개발 순서는</p><ol><li><a href="https://www.puzzle-nurikabe.com/" target="_blank" rel="noopener">https://www.puzzle-nurikabe.com/</a> 사이트에 접속 한 다음</li><li>퍼즐 부분의 html 태그를 가져 옵니다.</li><li>html태그를 2차원 int로 변환 하여 던져 줍니다.</li></ol><p>개발 과정 중에 사용한 Tool과 라이브러리는</p><ul><li>JHipster로 프로젝트 생성</li><li>jBrowserdriver라는 Headless Browser를 통한 크롤링</li><li>Jackson Json Paser로 데이터 JSON컨버팅</li></ul><p>을 하였습니다.</p>]]></content>
      
      
      <categories>
          
          <category> 미분류 </category>
          
      </categories>
      
      
    </entry>
    
    <entry>
      <title>JHipster와 생성 도구</title>
      <link href="/2018/08/18/jhipster-ec-99-80-ec-83-9d-ec-84-b1-eb-8f-84-ea-b5-ac/"/>
      <url>/2018/08/18/jhipster-ec-99-80-ec-83-9d-ec-84-b1-eb-8f-84-ea-b5-ac/</url>
      
        <content type="html"><![CDATA[<p>이전 시간에는 JHipster의 프로젝트 생성에 대해서 다루었습니다. 이번 시간에는 적극적으로 <code>Sub Generator</code>를 활용 하여 Entity, Srping Controller, Spring Service를 생성하는 방법과 JDL, UML를 이용 하여 Entity들을 파일로 Impot, Export하는 방법에 대해 알아 봅시다. 또한 MSA사용시 Cloud용 Ganerator를 알아 봅시다.</p><h1 id="Entity-생성"><a href="#Entity-생성" class="headerlink" title="Entity 생성"></a>Entity 생성</h1><p>데이터를 담을 수 있는 객체를 생성 할 수 있으며, DB와의 연관관계 및 Sub Genorator를 통해 Entity의 <code>Field</code>와 데이터의 길이 및 제한을 위해 <code>Field의 Validation Check</code>, <code>다른 Entity와의 연관관계 지정</code> 까지 가능 합니다. [code lang=bash] $ jhipster entity Entity이름 –옵션 [/code]</p><ul><li>Field를 생성 할 것인가?<ul><li>name, type, validate 설정</li></ul></li><li>연관관계를 맺을 것인가?<ul><li>연관관계설정</li></ul></li><li>비즈니스 로직용 클래스를 만들 것인가?<ul><li>Controller만, Controller와 Service Class, Controller와 Service Interface</li></ul></li><li>Entity의 페이징 기능 사용 할 것인가?<ul><li>무한스크롤, 페이지넘버링크</li></ul></li></ul><p>크게 4가지 질문에 답을 하면, 선택에 따라</p><ul><li>Java 파일 : Entity, DTO, Service, Controller의 java</li><li>설정 파일 : liquibase의 xml</li><li>Web 파일 : Entity의 ts</li></ul><p>파일 들이 생성 됩니다.</p><h1 id="Spring-Controller-생성"><a href="#Spring-Controller-생성" class="headerlink" title="Spring Controller 생성"></a>Spring Controller 생성</h1><p>URL 매핑 관련 Spring Controller 생성 입니다. [code lang=bash] $ jhipster spring-controller Controller명 [/code]</p><ul><li>컨트롤러를 만들 것인가?</li><li>추가할 액션은(URL명)?<ul><li>HTTP method는?</li></ul></li></ul><p>크게 2가지 질문만 답을 하면, 선택에 따라 Srping Controller 파일이 생성 됩니다.</p><h1 id="Spring-Service-생성"><a href="#Spring-Service-생성" class="headerlink" title="Spring Service 생성"></a>Spring Service 생성</h1><p>비즈니스 로직을 담을 Spring Service 생성 입니다. [code lang=bash] $ jhipster spring-service Service명 [/code]</p><ul><li>인터페이스 연계 Service를 만들 것인가?</li></ul><p>한가지 질문만 있으며, 선택에 따라 Service용 인터페이스와 서비스 클래스파일이 생성 됩니다.</p><blockquote><p>Entity생성은 생산성에 좋지만, Controllrt와 Service는 직접 생성하는게 더 좋은거 같습니다.</p></blockquote><h1 id="JDL-사용"><a href="#JDL-사용" class="headerlink" title="JDL 사용"></a>JDL 사용</h1><p>JDL(JHipster Domain Language)은 Entity의 생성을 많이 할 경우 유용하며, JDL파일을 가지고 도메인 다이어그램을 그릴수 있는 <a href="https://start.jhipster.tech/jdl-studio/" target="_blank" rel="noopener">JDL Studio</a>, <a href="https://www.jhipster.tech/jhipster-ide/" target="_blank" rel="noopener">JDL IDE Plugin</a>라는 툴이 있어 협업 시 효과적 입니다. [code lang=bash] //프로젝트에 JDL 삽입 시 $ jhipster import-jdl jdl파일명 //프로젝트에서 JDL 추출 시 $ jhipster export-jdl jdl파일명 [/code] 이 기능을 활용 하여 자유자재로 Import와 Export하여 팀원들과 공유 및 커뮤니케이션을 할 수 있습니다. <a href="https://start.jhipster.tech/jdl-studio/" target="_blank" rel="noopener">JDL Studio</a>는 웹서버로 제공 하며, <a href="https://www.jhipster.tech/jhipster-ide/" target="_blank" rel="noopener">JDL IDE Plugin</a>은 현재 이클립스와 비주얼 스튜디오 코드만 존재 합니다.</p><h1 id="UML-사용"><a href="#UML-사용" class="headerlink" title="UML 사용"></a>UML 사용</h1><p>UML을 활용한 Import와 Export가 가능하며, 이 기능은 사용 할 시 Genorator 설치 가 필요 합니다. [code lang=bash] $ yarn add global jhipster-uml [/code] 지원 가능한 UML 서비스는 아래와 같습니다.</p><ul><li><a href="https://www.modeliosoft.com/en/" target="_blank" rel="noopener">Modelio</a></li><li><a href="http://www.umldesigner.org/" target="_blank" rel="noopener">UML Designer</a></li><li><a href="https://www.genmymodel.com/" target="_blank" rel="noopener">GenMyModel(유료)</a></li></ul><p>[code lang=bash] $ jhipster-uml UML파일 [/code]</p><h1 id="Entity사용에-관한-Ganorator정리"><a href="#Entity사용에-관한-Ganorator정리" class="headerlink" title="Entity사용에 관한 Ganorator정리"></a>Entity사용에 관한 Ganorator정리</h1><p>살펴본 결과 <code>한 개의 Entity를 생성 시엔 Entity Generator를 사용</code>하는 게 좋고, <code>다량의 Entity 생성은 JDL을 통해 생성</code>하는 게 좋습니다. 그리고 협업하시는 분과의 <code>커뮤니케이션 시 JDL Studio, JDL IDE Plugin의 도메인 다이어그램을 활용</code>하시면 좋을 거 같습니다.</p><h1 id="Cloud-생성"><a href="#Cloud-생성" class="headerlink" title="Cloud 생성"></a>Cloud 생성</h1><p>Cloud 사용을 위한 다양한 Ganerator를 제공 하며 종류는 아래와 같습니다.</p><ul><li>Cloud Foundry</li><li>Heroku</li><li>Kubernetes</li><li>OpenShift</li><li>Rancher</li><li>AWS</li><li>Boxfuse</li><li>docker-compose</li></ul><p>Cloud 활용은 <a href="https://www.jhipster.tech/production/" target="_blank" rel="noopener">https://www.jhipster.tech/production/</a> 이페이지를 참조 하시면 됩니다. docker-compose는 뒤에서 MSA설명 할 때 다시 설명 드리겠습니다.</p><h1 id="그-외-생성-도구"><a href="#그-외-생성-도구" class="headerlink" title="그 외 생성 도구"></a>그 외 생성 도구</h1><p>위에서 소개해드린 생성 도구 이 외에도 JHipster 공식 Sub Generator는 <a href="https://github.com/jhipster/generator-jhipster/tree/master/generators" target="_blank" rel="noopener">https://github.com/jhipster/generator-jhipster/tree/master/generators</a> 이 페이지에서 확인 하실 수 있습니다.</p>]]></content>
      
      
      <categories>
          
          <category> 미분류 </category>
          
      </categories>
      
      
    </entry>
    
    <entry>
      <title>[초급편] JAVA HIPSTER 공부하기</title>
      <link href="/2018/08/17/ec-b4-88-ea-b8-89-ed-8e-b8-java-hipster-ea-b3-b5-eb-b6-80-ed-95-98-ea-b8-b0/"/>
      <url>/2018/08/17/ec-b4-88-ea-b8-89-ed-8e-b8-java-hipster-ea-b3-b5-eb-b6-80-ed-95-98-ea-b8-b0/</url>
      
        <content type="html"><![CDATA[<p><em><strong>프로그래밍 초급자가 바라본 JAVA HIPSTER - “아~ 이건 언제 다 공부하냐”</strong></em> <strong>1. 가장 먼저 한 일 - “<a href="https://www.jhipster.tech&quot;" target="_blank" rel="noopener">https://www.jhipster.tech&quot;</a> 사이트 둘러보기</strong></p><ul><li>(의문을 가지다) : “Jhipster 는 무엇이냐”</li><li>(공식적인 답변) : “Jhipster 는 스프링부트와 앵귤러(또는 리액트) 기반 웹 어플리케이션 또는 스프링 마이크로서비스를 생성하고 개발하고 배포하기 위한 개발 플랫폼이다” (JHipster is a development platform to generate, develop and deploy Spring Boot + Angular/React Web applications and Spring microservices)</li></ul><p><strong>2. 두번째로 한 일 - Jhipster Quick Start (16분 동영상) 따라해보기</strong> [jhipster를 설치하기 위한 6가지 방법] - 한개씩 설치 방법을 포스팅할 예정</p><ul><li>Jhipster Online : “<a href="https://start.jhipster.tech/#/&quot;" target="_blank" rel="noopener">https://start.jhipster.tech/#/&quot;</a></li><li>Local installation with Yarn</li><li>Local installation with NPM</li><li>Installation with a package manager ( Homebrew on MacOSX, Chocolatey on Windows)</li><li>Vagrant box installation</li><li>Docker installation</li></ul><p>: Jhipster 를 설치하는 방법은 총 6가지가 있으며, 동영상에서는 2번째 방법인 Local installation with Yarn 방법을 사용하였다.</p><ul><li>java 설치 : Oracle website 에서 자바 8 버전 이상을 다운로드 및 설치</li><li>Node 설치 : LTS 64-bit version을 다운로드 및 설치</li><li>Yarn 설치 : 운영체제별 맞춤 설치방법 제공(윈도우의 경우 .msi 제공)</li><li>Yeoman 설치 : Jhipster Marketplace 이용 시 -&gt; “yarn global add yo”</li><li>Jhipster 설치 : “yarn global add generator-jhipster”</li></ul><hr><ul><li>New Jhipster application 설치</li><li>신규 폴더 생성 : (Ex) mkdir myapplication</li><li>신규 생성 폴더 이동 : (Ex) cd myapplication</li><li>신규 어플리케이션 생성을 위한 명령어 입력 : (Ex) jhipster</li></ul><p>===== 어플리케이션 생성 시 질문 내역 =====</p><ol><li>Which type of application would you like to create?</li></ol><ul><li>Monolithic application: this a classical, one-size-fits-all application. It’s easier to use and develop, and is our recommended default.</li><li>Microservice application: in a microservices architecture, this is one of the services.</li><li>Microservice gateway: in a microservices architecture, this is an edge server that routes and secures requests.</li><li>JHipster UAA server: in a microservices architecture, this is an OAuth2 authentication server that secures microservices. Refer to the JHipster UAA documentation for more information.</li></ul><ol><li><p>What is the base name of your application?</p></li><li><p>What is your default java package name?</p></li><li><p>Do you want to use the jhipster registry to configure, monitor and scale your application?</p></li><li><p>Which type of authentication would you like to use?</p></li></ol><ul><li>JWT authentication: use a JSON Web Token (JWT), which is the default choice</li><li>HTTP Session Authentication: the classical session-based authentication mechanism, like we are used to do in Java (this is how most people use Spring Security).</li><li>OAuth 2.0 / OIDC Authentication: this uses an OpenID Connect server, like Keycloak or Okta, which handles authentication outside of the application.</li><li>Authentication with JHipster UAA server: this uses a JHipster UAA server that must be generated separately, and which is an OAuth2 server that handles authentication outside of the application.</li></ul><ol><li>Which type of database would you like to use?</li></ol><ul><li>No database (only available when using a microservice application)</li><li>An SQL database (H2, MySQL, MariaDB, PostgreSQL, MSSQL, Oracle), which you will access with Spring Data JPA</li><li>MongoDB</li><li>Cassandra</li><li>Couchbase</li></ul><ol><li><p>Which production database would you like to use?</p></li><li><p>Which development database would you like to use?</p></li></ol><ul><li>H2, running in-memory. This is the easiest way to use JHipster, but your data will be lost when you restart your server.</li><li>H2, with its data stored on disk. This is a better option than running in-memory, as you won’t lose your data upon application restart.</li><li>The same database as the one you chose for production: it’s a bit more complex to set up, but it should be better in the end to work on the same database as the one you will use in production. This is also the best way to use liquibase-hibernate as described in the development guide.</li></ul><ol><li><p>Do you want to use the spring cache abstraction?</p></li><li><p>Do you want to use Hibernate 2nd level cache?</p></li><li><p>Would you like to use Maven or Gradle?</p></li><li><p>Which other technologies would you like to use?</p></li></ol><ul><li>API first development using swagger-codegen</li><li>Search engine using ElasticSearch</li><li>Clustered HTTP sessions using Hazelcast</li><li>WebSockets using Spring Websocket</li><li>Asynchronous messages using Apache Kafka</li></ul><ol><li>Which Framework would you like to use for the client?</li></ol><ul><li>Angular</li><li>React</li></ul><ol><li><p>Would you like to use the LibSass stylesheet preprocessor for your CSS?</p></li><li><p>Would you like to enable internationalization support?</p></li><li><p>Which testing frameworks would you like to use?</p></li></ol><ul><li>Performance tests using Gatling</li><li>Behaviour tests using Cucumber</li><li>Angular integration tests with Protractor</li></ul><ol><li>Would you like to install other generators from the jhipster Marketplace?</li></ol><hr><ul><li><p>신규 소스 파일 생성 후, Maven 또는 Gradle 명령어를 이용하여 어플리케이션 기동</p></li><li><p>Maven 기반 리눅스, 맥, 윈도우 파워쉘의 경우 :  ./mvnw</p></li><li>Maven 기반 윈도우즈 cmd의 경우 : mnvw</li><li>Gradle 기반 리눅스, 맥, 윈도우 파워셀의 경우 : ./gradlew</li><li>Gradle 기반 윈도우즈 cmd의 경우 : gradlew</li></ul><p><strong>3. 세번째로 한 일 - JHipster UML 과 JDL Studio 사용하여 Entity 생성하기</strong></p><ul><li>Jhipster UML는 무엇(?) : “jhipster의 서브프로젝트”로서  UML Editor에서 Jhipster-UML 다이어그램 생성을 지원, 현재 공식적으로 지원하는 Editor는 다음과 같다.<ul><li>Modelio</li><li>UML Designer</li><li>GenMyModel</li></ul></li><li>Jhipster UML  사용하기<ul><li>step 1 - xmi 확장자의 파일 형태로 class 다이어그램을 추출한다.</li><li>step 2 - Jhipster 어플리케이션의 루트 폴더로 xmi 파일을 업로드한 후, 명령어를 실행한다. “jhipster-uml</li></ul></li><li>JDL Studio는 무엇(?) : “jhipster에서 공식적으로 지원하는 온라인 툴로서 도메인 기반 언어인 JDL을 이용하여 객체 및 관계를 정의한다.<ul><li>step 1 - jdlstudio(“<a href="https://start.jhipster.tech/jdl-studio/&quot;" target="_blank" rel="noopener">https://start.jhipster.tech/jdl-studio/&quot;</a>) 사이트에서 객체 및 관계를 정의한다.</li><li>step 2 - Download text file of this JDL 메뉴를 이용하여 .jh 파일을 생성한다.</li><li>step 3 - 해당 파일을 jhipster 어플리케이션의 루트 폴더로 업로드한 후, 명령어를 실행한다. “jhipster import-jdl</li></ul></li></ul><ol><li>미쳐 정리하지 못한 것들</li></ol><ul><li>추가적인 기능연계 : (Ex) 스프링시큐리티, 엘라스틱서치, 웹소켓, 캐시 등</li><li>배포 기능 : 클라우드에 서비스하기(heroku, aws, cloud Foundry 등)</li></ul>]]></content>
      
      
      <categories>
          
          <category> 미분류 </category>
          
      </categories>
      
      
    </entry>
    
    <entry>
      <title>JHipster MSA 구축</title>
      <link href="/2018/08/13/jhipster-msa-ea-b5-ac-ec-b6-95/"/>
      <url>/2018/08/13/jhipster-msa-ea-b5-ac-ec-b6-95/</url>
      
        <content type="html"><![CDATA[<h1 id="개요"><a href="#개요" class="headerlink" title="개요"></a>개요</h1><p>Mricroservice는 수많은 장점을 가지고 있지만 구축하는건 생각보다 쉽지 않습니다. JHipster와 함께 MSA구축을 하면 한층 쉽게 다가갈수 있다고 생각 되어 글을 작성 하게 되었습니다. 본 글에서는 크게</p><ul><li>개발 MSA 환경 구축</li><li>Docker Compose를 활용한 Service Mash</li></ul><p>나뉘며 프로젝트 생성부터 Microservice Gateway와 Microservice Application생성과 더불어 상용 배포를 위한 Docker Compose 설정까지 알아 보겠습니다.</p><h1 id="개발-MSA-환경-구축"><a href="#개발-MSA-환경-구축" class="headerlink" title="개발 MSA 환경 구축"></a>개발 MSA 환경 구축</h1><p><img src="https://www.jhipster.tech/images/microservices_architecture_detail.001.png" alt="MSA diagram"></p><ul><li>Gateway 생성<ul><li>Registry 실행</li><li>Gateway 실행</li></ul></li><li>Application 생성<ul><li>Application 실행</li></ul></li></ul><p>여기에선 이 구조로 프로젝트를 생성 해 보겠습니다. <img src="https://user-images.githubusercontent.com/6037055/44248354-066b8700-a225-11e8-8303-4049bb6fc16b.png" alt="wallet"> <img src="https://user-images.githubusercontent.com/6037055/43988352-c1192640-9d6e-11e8-9723-d77ee7674fb1.png" alt="directory"></p><h2 id="Gateway-생성"><a href="#Gateway-생성" class="headerlink" title="Gateway 생성"></a>Gateway 생성</h2><p>Gateway를 생성한 뒤 먼저 JHipster Registry를 실행한다. [code lang=bash] // Gateway로 프로젝트 생성 $ cd gateway $ jhipster [/code] <img src="https://user-images.githubusercontent.com/6037055/43988345-bfed690c-9d6e-11e8-9c47-0fb1dd3b1516.png" alt="gateway_generate"> [code lang=bash] // Registry 실행 $ docker-compose -f src/main/docker/jhipster-registry.yml up [/code] <img src="https://user-images.githubusercontent.com/6037055/43988350-c0b8cbce-9d6e-11e8-86b4-98b644cfc333.png" alt="registry_run"> JHipster Registry는 <code>Spring Cloud Config</code>와 <code>Eureka Server</code>로 이루어져 있으며 Microservice의 Config관리 및 서버 발견 역할을 한다. registry가 셋팅 된후에 gateway를 실행 시킨다. [code lang=bash] // Gateway 실행 $ ./gradlew [/code] <img src="https://user-images.githubusercontent.com/6037055/43988346-c021a9ba-9d6e-11e8-9ad7-e797411cdbb9.png" alt="gateway_run"></p><h2 id="Application-생성"><a href="#Application-생성" class="headerlink" title="Application 생성"></a>Application 생성</h2><p>[code lang=bash] // Application로 프로젝트 생성 (member, wallet 각각 실행) $ cd member $ jhipster [/code] <img src="https://user-images.githubusercontent.com/6037055/43988348-c05189b4-9d6e-11e8-8b74-86da2dd6425a.png" alt="member_generate"> <img src="https://user-images.githubusercontent.com/6037055/43988351-c0eb1688-9d6e-11e8-90e8-0d0a7a825fe9.png" alt="wallet_generate"> 생성 후 별도의 비즈니스로직 추가 후 애플리케이션을 실행 하시면 됩니다. [code lang=bash] // Gateway 실행 $ ./gradlew [/code]</p><h2 id="개발-MSA-환경-실행"><a href="#개발-MSA-환경-실행" class="headerlink" title="개발 MSA 환경 실행"></a>개발 MSA 환경 실행</h2><p>지금까지 잘 따라오셨으면</p><ul><li>Registry</li><li>Gateway</li><li>Application</li></ul><p>3개의 서비스들이 잘 실행 되어 있고 Gateway에서 각각의 Application의 API를 호출하면 정상적으로 동작하는걸 확인 하실 수 있습니다. <img src="https://user-images.githubusercontent.com/6037055/43988349-c08271aa-9d6e-11e8-9e30-80feec06d61a.png" alt="registry_check"> <img src="https://user-images.githubusercontent.com/6037055/43988355-c1a150f6-9d6e-11e8-8c77-b38491c25a79.png" alt="gateway_check"> <img src="https://user-images.githubusercontent.com/6037055/43988353-c1499aaa-9d6e-11e8-9a1f-ad028fc7361b.png" alt="gateway_app_check_1"> <img src="https://user-images.githubusercontent.com/6037055/43988354-c17b96e0-9d6e-11e8-831e-49487bc1052d.png" alt="gateway_app_check_2"> swagger를 통해 Gateway에서 각각의 member와 wallet Service의 API를 확인하고 개발 할 수 있습니다.</p><h1 id="Docker-Compose를-활용한-Service-Mash"><a href="#Docker-Compose를-활용한-Service-Mash" class="headerlink" title="Docker Compose를 활용한 Service Mash"></a>Docker Compose를 활용한 Service Mash</h1><p><img src="https://ahea.files.wordpress.com/2018/08/d160f-1jk4vdnsrf6ynab2nyhmsdq.png" alt="docker-compose logo"> Docker Compose는 Multi-Container 정의 툴로써 YAML형식의 파일로 작성 하며, 여러 개의 Docker Container를 한번에 생성 하실 수 있습니다. Docker Compose를 실행하기전 각각의 애플리케이션의 Dokcer Image가 필요하여 아래의 명령어를 실행 해줘야 합니다. [code lang=bash] $ ./gradlew bootWar -Pprod buildDocker [/code] <code>docker images</code>로 Docker Image를 확인 하실 수 있습니다. [code lang=bash] $ docker images [/code] <img src="https://user-images.githubusercontent.com/6037055/43988576-e06f3f48-9d73-11e8-97e9-42f814005407.png" alt="docker_images"> 필요한 모든 준비가 완료 되었습니다. 이제 docker-compose로 서비스들을 묶은 뒤 실행만 하면 됩니다. [code lang=bash] $ cd wallet-app-compose $ jhipster docker-compose [/code] <img src="https://user-images.githubusercontent.com/6037055/43988578-e25a1c4c-9d73-11e8-9d9b-86288ad38cb7.png" alt="docker-compose_generate"> 생성을 완료 한 후 실행을 해봅니다. [code lang=bash] $ docker-compose up -d [/code] <img src="https://user-images.githubusercontent.com/6037055/43988579-e2fdcd2e-9d73-11e8-810f-423e7461d370.png" alt="docker-compose_up"> <img src="https://user-images.githubusercontent.com/6037055/44254727-a08bf900-a23e-11e8-9a75-167e6ba44e5b.png" alt="docker-compose"> 이외 compose사용시 유용한 명령어들 입니다.</p><ul><li><code>docker-compose up -d</code> - 컨테이너들 생성과 동시에 실행</li><li><code>docker-compose down</code> - 컨테이너들 종료와 동시에 삭제</li><li><code>docker-compose start</code> - 컨테이너들 실행</li><li><code>docker-compose stop</code> - 컨테이너들 종료</li></ul><p>docker로 실행 시 몇가지 유용한 명령어를 정리 해 보았습니다.</p><ul><li><code>docker stats</code> - 컨테이너의 cpu, memory, I/O 등</li><li><code>docker images</code> - 이미지 확인</li><li><code>docker ps</code> - 컨테이너 확인</li><li><code>docker rmi</code> - 이미지 삭제</li><li><code>docker rm</code> - 컨테이너 삭제</li></ul><p><img src="https://user-images.githubusercontent.com/6037055/43988577-e0bbab3a-9d73-11e8-8d1e-733ba811f815.png" alt="docker_stats"> 자세한 사용법은 명령어 뒤에 <code>--help</code> 를 넣어 확인 바랍니다. JHipster Console도 설치 하여 MSA관리를 수월할 수 있게 도와 줍니다. <img src="https://user-images.githubusercontent.com/6037055/43988583-efa2428a-9d73-11e8-9dcf-a49e5cee3901.png" alt="console_dashboard"> <img src="https://user-images.githubusercontent.com/6037055/43988604-4267cec2-9d74-11e8-94e0-ad09e3a3b3b2.png" alt="console_log"></p>]]></content>
      
      
      <categories>
          
          <category> 미분류 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> docker </tag>
            
            <tag> java </tag>
            
            <tag> JHipster </tag>
            
            <tag> spring boot </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>JHipster란?</title>
      <link href="/2018/07/29/jhipster-eb-9e-80/"/>
      <url>/2018/07/29/jhipster-eb-9e-80/</url>
      
        <content type="html"><![CDATA[<h1 id="JHipster란"><a href="#JHipster란" class="headerlink" title="JHipster란?"></a>JHipster란?</h1><p><img src="https://i2.wp.com/keyholesoftware.com/wp-content/uploads/jHipster.jpg" alt=""> 간단히 정의 하면 <code>자바 기반 생성(generate) 개발 플랫폼</code> 이라고 말씀 드릴 수 있습니다. 기존 뛰어난 생산성으로 흥한 개발 플랫폼인 Ruby의 <code>Ruby on Ralse</code>나 Node.js의 <code>Meteor.js</code>등 애플리케이션 개발을 생성 도구 활용으로 인기를 끌었습니다. 그동안 Spring 진영에서도 생성 도구를 활용한 개발이 없어 생산성에서 뒤쳐졌지만, JHipster에서 만들게 되어 Spring에서도 빠른 생산성을 확보하게 되었습니다. 생성 도구는 Yeoman이라는 기존 웹 보일러플레이트 프로젝트 생성 도구인데 JHipster에서 Yeoman기반으로 만들어 활용 하였습니다.</p><h1 id="Yeoman이란"><a href="#Yeoman이란" class="headerlink" title="Yeoman이란?"></a>Yeoman이란?</h1><p><img src="https://cdn-images.threadless.com/threadless-media/artist_shops/shops/yeoman/products/633217/shirt-1529592223-b157e98a44b27cc571605d6297f9f9e9.png" alt=""> 웹 개발을 프레임워크 및 라이브러리들을 통합하여 쉽게 프로젝트를 생성 할 수 있는 Tool 입니다. [code lang=bash] $ npm i -g yo $ npm i -g generator-원하는도구 [/code] 기본적으로 Node.js가 설치 되어 있어야 하며, <code>yo</code>를 설치 후 원하는 도구를 설치 하면 됩니다. Yeoman에서 제공하는 API를 활용하면 쉽게 CLI기반 Generate가 가능 하므로 관심 있으신 분들은 <a href="http://yeoman.io/authoring/index.html" target="_blank" rel="noopener">http://yeoman.io/authoring/index.html</a> 이 URL을 참조 하셔서 개발 하시면 됩니다.</p><h1 id="JHipster-Sample-Project"><a href="#JHipster-Sample-Project" class="headerlink" title="JHipster Sample Project"></a>JHipster Sample Project</h1><h2 id="준비"><a href="#준비" class="headerlink" title="준비"></a>준비</h2><p>JHipster를 사용하기 전 필수로 설치할 프로그램을 소개 합니다.</p><ul><li>Java</li><li>Git</li><li>Node.js</li><li>Yarn</li><li>Yeoman</li></ul><p>Java와 Git, Node.js는 OS에 맞추어 설치 하시고 Yarn과 Yeoman은 Node.js와 함께 설치된 npm으로 설치 하시면 됩니다. [code lang=bash] $ npm i -g yo $ npm i -g yarn $ yarn global add generator-jhipster [/code] <a href="https://www.jhipster.tech" target="_blank" rel="noopener">https://www.jhipster.tech</a> 에 접속 하여 Quick Start를 보고 샘플 프로젝트 생성을 진행 하겠습니다. JHipster 문서 보실때 헷갈릴까봐 한가지 짚고 넘어 가겠습니다. 명령어 사용 시 옛날 방식과 최근 방식에 차이점이 있는데 yo를 쓰고 안쓰고 차이 입니다. 입맛에 맞게 골라서 사용하시면 될거 같습니다.</p><ul><li>프로젝트 생성 시</li></ul><p>[code lang=bash] //옛날 방식 $ yo jhipster //최근 방식 $ jhipster [/code]</p><ul><li>추가 기능 사용 시</li></ul><p>[code lang=bash] //옛날 방식 $ yo jhipster:추가기능 //최근 방식 $ jhipster 추가기능 [/code]</p><h2 id="생성"><a href="#생성" class="headerlink" title="생성"></a>생성</h2><p>샘플프로젝트 생성 시 선택 가능한 내역 입니다. <strong>굵게</strong> 표시한건 이번 프로젝트 생성 시 선택한 것 입니다.</p><ul><li>어떤 타입의 프로젝트를 생성하는가?<ul><li><strong>모놀로식 애플리케이션</strong></li><li>마이크로서비스 애플리케이션</li><li>마이크로서비스 게이트웨이</li><li>JHipster UAA Server</li></ul></li><li>어떤 인증을 사용 할 것인가?<ul><li><strong>JWT</strong></li><li>Oauth2 / OIDC</li><li>HTTP Sesstion Authentication</li></ul></li><li>어떤 DB를 사용 할 것인가?<ul><li><strong>SQL(H2, MySQL, MariaDB, PostgreSQL, Oracle, MSSQL)</strong></li><li>MongoDB</li><li>Couchbase</li><li>Cassandra</li></ul></li><li>(SQL 선택시 나옴) dvelopment와 production에 사용할거 선택</li><li>Spring Cache를 사용할 것인가?<ul><li>Ehcach</li><li>Hazelcast</li><li>Memcached</li><li><strong>사용안함</strong></li></ul></li><li>어떤 빌드도구를 쓸 것인가?<ul><li>Maven</li><li><strong>Gradle</strong></li></ul></li><li>다른 기술을 사용할 것인가?(모두 선택 가능)<ul><li>엘라스틱서치 기반 검색</li><li>웹소켓</li><li>OpenAPI-generator</li><li>Kafka</li></ul></li><li>어떤 Front를 사용 할 것인가?<ul><li>Angular 6</li><li><strong>React</strong></li></ul></li><li>추가 테스트 프레임워크를 사용 할 것인가?(모두 선택 가능)<ul><li>Gatling</li><li>Cucumber</li><li>Protractor</li></ul></li><li>어떤 기본 언어를 선택 할 것인가?<ul><li><strong>한국어</strong></li><li>영어</li><li>기타 등등</li></ul></li><li>추가로 지원할 언어는?(모두 선택 가능)<ul><li><strong>영어</strong></li><li>나머지 선택지는 위와 동일</li></ul></li></ul><p>본격적으로 생성을 해보겠습니다. [code lang=powershell] PS C:\Users\a\jhipsterProjects&gt; mkdir myApp; cd myApp PS C:\Users\a\jhipsterProjects\myApp&gt; [/code] <img src="https://user-images.githubusercontent.com/6037055/43363131-6739432a-9338-11e8-88ab-e67f65f64b9d.png" alt=""> <img src="https://user-images.githubusercontent.com/6037055/43363132-6772ba7e-9338-11e8-9d92-7373b8dfce3c.png" alt=""> <img src="https://user-images.githubusercontent.com/6037055/43363133-67ae6d12-9338-11e8-972a-3eaacf0252ab.png" alt=""> <img src="https://user-images.githubusercontent.com/6037055/43363134-68561d00-9338-11e8-898c-d3e064410f55.png" alt=""> <img src="https://user-images.githubusercontent.com/6037055/43363135-68837304-9338-11e8-8567-1c57306f30d0.png" alt=""> <img src="https://user-images.githubusercontent.com/6037055/43363136-68b06cba-9338-11e8-9b85-4e598c6b5100.png" alt=""> <img src="https://user-images.githubusercontent.com/6037055/43363137-68dacd16-9338-11e8-9219-6b28739e03df.png" alt=""> <img src="https://user-images.githubusercontent.com/6037055/43363138-6906a3d2-9338-11e8-964b-0f321ad0a7d0.png" alt=""> <img src="https://user-images.githubusercontent.com/6037055/43363130-670d28f8-9338-11e8-92f0-0ae781eaaec9.png" alt=""> Spring Boot + React앱이 만들어 졌고 다음시간엔 JDL과 CLI을 통한 Entity+Controller+Service생성을 알아 보겠습니다.</p>]]></content>
      
      
      
        <tags>
            
            <tag> docker </tag>
            
            <tag> java </tag>
            
            <tag> devops </tag>
            
            <tag> JHipster </tag>
            
            <tag> spring </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>해외판 전자정부프레임워크? JHipster에 대해 알아 보자!</title>
      <link href="/2018/07/29/ed-95-b4-ec-99-b8-ed-8c-90-ec-a0-84-ec-9e-90-ec-a0-95-eb-b6-80-ed-94-84-eb-a0-88-ec-9e-84-ec-9b-8c-ed-81-ac-jhipster-ec-97-90-eb-8c-80-ed-95-b4-ec-95-8c-ec-95-84-eb-b3-b4-ec-9e-90/"/>
      <url>/2018/07/29/ed-95-b4-ec-99-b8-ed-8c-90-ec-a0-84-ec-9e-90-ec-a0-95-eb-b6-80-ed-94-84-eb-a0-88-ec-9e-84-ec-9b-8c-ed-81-ac-jhipster-ec-97-90-eb-8c-80-ed-95-b4-ec-95-8c-ec-95-84-eb-b3-b4-ec-9e-90/</url>
      
        <content type="html"><![CDATA[<h1 id="개요"><a href="#개요" class="headerlink" title="개요"></a>개요</h1><p>우리나라에서 공공기관과 민간기업에서 많이 사용하는 전자정부프레임워크가 있습니다. 업데이트도 느리거니와 생성도 불편하다고 생각 됩니다. 웹 프론트엔드 개발은 전자정부프레임워크인 경우 JSP(Java Server Page)와 jQuery라이브러리를 활용한 개발이고, JHipster는 웹 프레임워크 Angular나 React를 활용하여 개발 할 수 있게 기본 설정 되어 있습니다. 그 외에도 최신 개발 트렌드 및 라이브러리 교체 시기도 확연히 달라 JHipster를 사용하여 개발 트렌드를 쫓아가면 어떨가 싶습니다.</p><p>JHipster 5.2.1</p><p>egov 3.7.0</p><p>Backend</p><p>Spring Boot 2.0.4</p><p>Spring 4.2.4</p><p>Frontend</p><p>Angular 6 or React</p><p>JSP, jQuery</p><p>Log</p><p>Logback</p><p>log4j</p><p>Version Manage</p><p>Git</p><p>SVN or Nuxus</p><p>CLI기반으로 코드 생성 및 각종 편의 도구를 제공 하여 프로젝트 생성 및 유지 보수 생산성을 높힐 수 있는 JHipster를 소개 합니다. 해외에서 자바 개발 플랫폼으로 핫한 프로젝트 입니다. <img src="https://user-images.githubusercontent.com/6037055/43363798-c1e66ce4-9347-11e8-9c80-5d0f75f53d36.png" alt="제이힙스터깃허브"> 다양한 기업들에서도 JHipster를 사용하고 있습니다. <img src="https://user-images.githubusercontent.com/6037055/43364341-4d914e8e-9353-11e8-8ea5-c0d427a04592.png" alt="제이힙스터사용기업들"> 프로젝트 설정부터 시작 해서 귀찮은 일은 JHipster가 도 맡아 하고 개발자는 <code>비즈니스 로직에만 집중</code> 할 수 있습니다. JHipster로 할 수 있는것</p><ul><li>Spring Boot + Angular/React 프로젝트</li><li>UML을 통한 Entity+Controler+Service 자동 생성</li><li>MSA 환경 구축</li><li>Docker Image 생성</li><li>Cloud와 통합 기능 제공(Kubernetis, Heroku, AWS 등)</li></ul><p>이외에도 여러 오픈소스들을 사용할 수 있게 셋팅이 되어 있으며 입맛이 맞게 골라서 사용 하실 수 있습니다.</p><h1 id="개인적으로-마음에-드는-부분"><a href="#개인적으로-마음에-드는-부분" class="headerlink" title="개인적으로 마음에 드는 부분"></a>개인적으로 마음에 드는 부분</h1><p>Spring Project들을 사용 하면서 공부 할 때 구조를 잘 잡는게 중요하다고 생각 됩니다. 물론 샘플 프로젝트만으로도 만족 할 수 있겠지만, 여러 프로젝트들을 융합 하였을때 복잡성이 증가하고 문맥과 명칭들이 뒤죽박죽 섞여 있어 통일성을 잃기 쉽습니다. 그래서 JHipster의 생성된 프로젝트를 봤을 때 깔끔한 설정과 generator를 사용 하여 일관된 개발을 할 수 있게 도와 줍니다.</p><h1 id="소개"><a href="#소개" class="headerlink" title="소개"></a>소개</h1><p>소개는</p><ul><li>JHipster란? With Sample Project</li><li>JHipster와 생성 도구</li><li>JHipster와 오픈소스</li><li>JHipster MSA With Docker Compose</li></ul><p>4 단계로 나눠서 소개를 할까 싶습니다.</p>]]></content>
      
      
      <categories>
          
          <category> 미분류 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> docker </tag>
            
            <tag> java </tag>
            
            <tag> devops </tag>
            
            <tag> JHipster </tag>
            
            <tag> spring </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>Lego Scrum Game(기획편)</title>
      <link href="/2018/06/13/lego-scrum-game-ea-b8-b0-ed-9a-8d-ed-8e-b8/"/>
      <url>/2018/06/13/lego-scrum-game-ea-b8-b0-ed-9a-8d-ed-8e-b8/</url>
      
        <content type="html"><![CDATA[<p>아해 스터디를 진행하면서 팀원들에게 자주 했던 말 중에 하나는 언제 기회가 되면 레고 스크럼을 함꼐 해보자 였습니다 언제 레고 스크럼을 알게 되었는지는 기억이 나지 않지만 2018년 6월 처음으로 아해팀에서 레고스크럼 게임 행사를 진행하게 되었습니다 이번 포스팅에서는 어떻게 행사를 준비하게 되었는지 <code>기획편</code>과 2018년 행사의 내용이 담긴 <code>진행편</code>으로 나누어 글을 써보자 합니다 <code>기획편</code>에서는 매년 아해팀에서 레고 스크럼 게임 행사를 준비하려고 할때 참고할수 있도록, 그리고 아해 뿐만 아니라 다른 많은 분들이 참고하셔서 레고 스크럼 게임을 진행하실수 있는 내용을 담아보려고 합니다</p><h1 id="레고-스크럼-게임이란"><a href="#레고-스크럼-게임이란" class="headerlink" title="레고 스크럼 게임이란"></a>레고 스크럼 게임이란</h1><p><img src="http://www.plays-in-business.com/wp-content/uploads/2015/09/lego-scrum-city-2.jpg" alt="lego scrum image"> 스크럼을 함께 배워보고 실제로 해보고도 싶은데… 여기서 문제가 될만한 것들이 뭐가 있을까요?</p><ul><li>함께 배우는 개발자들의 언어가 다르다</li><li>함께 배우는 개발자들의 실력이 다르다</li><li>아무리 작은 텀 프로젝트 하나를 한다고 해도 시간이 많이 든다</li></ul><p>제가 생각하는 문제는 다음과 같았습니다. 아주 짧고 굵게 스크럼을 익히기 위한 방법이 뭐가 있을까 찾다보니 레고 스크럼이 위의 문제를 해결하면서 스크럼을 배워볼수 있는 답이였습니다 레고는 누구나 만질수 있으며 실력의 차이라는거도 있지 않습니다. 또 레고스크럼게임은 2-3시간이면 끝나기 때문에 짧고 굵게 배우기 좋은 방법이였습니다</p><h1 id="인터넷에서-scrum-game-자료"><a href="#인터넷에서-scrum-game-자료" class="headerlink" title="인터넷에서 scrum game 자료"></a>인터넷에서 scrum game 자료</h1><p>이번 행사를 준비하면서 가장 불안했던 부분은 레고로 스크럼을 배워보자고 하면 사람들이 행사를 참여하는데 있어 정보를 어떻게 찾아볼것인가 였습니다. 제가 만약 참가자였다면 레고 스크럼 게임이 뭐지? 하고 인터넷을 찾아봤을거 같은데요 네이버에서 레고 스크럼을 검색할 경우 지금은 저희가 올렸던 아해 행사 모집글 정도가 올라오고 특별히 레고 스크럼에 관련된 정보를 알수 없었습니다 이 말은 한국자료는 없다라고 봐도 되지 않나 싶습니다 저같은 경우는 두가지 루트로 레고 스크럼 게임을 준비했습니다</p><h2 id="유튜브-동영상"><a href="#유튜브-동영상" class="headerlink" title="유튜브 동영상"></a>유튜브 동영상</h2><p>유튜브에서는 scrum이라고만 검색해도 꽤 상단에 레고 스크럼 게임 자료를 보실 수 있습니다 (기억은 안나지만 저도 이렇게 처음 레고 스크럼 게임을 알게 되지 않았나 싶습니다) <img src="https://raw.githubusercontent.com/devload/devload.github.io/master/assert/image/ahea_lego_scrum1/1.png" alt="유튜브 스크럼 검색 캡쳐"> <code>UTS Software Engineering</code>이라는 유튜브명으로 많은 자료가 올라와있습니다. 어떻게 하는지에 대한 내용부터 이팀에서 진행한 행사의 진행내용도 확인할 수 있었습니다 <a href="https://www.youtube.com/watch?v=Wy5F1XyNt74&amp;t=531s" target="_blank" rel="noopener">Lego Scrum Game 2017 - YouTube</a></p><h2 id="lego4scrum"><a href="#lego4scrum" class="headerlink" title="lego4scrum"></a>lego4scrum</h2><p><a href="https://www.lego4scrum.com/" target="_blank" rel="noopener">https://www.lego4scrum.com/</a> 저희가 준비하는데 아주 실질적인 자료는 이곳에서 얻게 되었습니다 <img src="https://raw.githubusercontent.com/devload/devload.github.io/master/assert/image/ahea_lego_scrum1/2.png" alt="유튜브 스크럼 검색 캡쳐"> 라이센스가 Creative Commons Attribution 3.0 Unported License. 라고 나와 있는데요. 처음부터 끝까지, 그리고 진행 방식과 주의점까지 아주 잘 나와 있습니다 도큐먼트를 한글로도 받을 수 있는데요…. 물론 번역을 해주신 분께는 너무 감사드리는 일이지만 약간은 번역기 느낌이 납니다. 내용을 영어 문서와 함께 보시는것을 추천드립니다</p><h1 id="레고-구매하기"><a href="#레고-구매하기" class="headerlink" title="레고 구매하기"></a>레고 구매하기</h1><p>준비의 1단계는 레고 구매였습니다 저희는 다음제품을 구매했습니다 <img src="https://raw.githubusercontent.com/devload/devload.github.io/master/assert/image/ahea_lego_scrum1/3.png" alt="유튜브 스크럼 검색 캡쳐"> <a href="https://www.amazon.com/Building-Bricks-Blocks-Pieces-Brands/dp/B019VC1E66/ref=sr_1_5?ie=UTF8&amp;qid=1528731814&amp;sr=8-5&amp;keywords=building+bricks+1000+pc+bulk+blocks" target="_blank" rel="noopener">Amazon.com: Building Bricks - 1000 Pc Bulk Blocks - Includes 60 Roof Pieces - Tight Fit with Major Brands: Toys &amp; Games</a> 국내에서 레고 벌크를 구매하기는 쉽지 않았습니다 거의 해외구매를 해야 했고요 저희팀은 인터파크를 통해서 구매했습니다 lego4scrum의 문서를 보시면 그 팀에서 사용한 레고 벌크 모델이 명확하게 나와 있습니다 저희는 가격을 최대한 줄여보려고 500개가 아닌 1000개 짜리를 구매했습니다 lego4scrum에서는 한팀당 500피스정도 있으면 된다고 얘기합니다 아쉬웠던 점은 바퀴나 사람은 위에 제품에 있지 않았습니다 차를 만들고 싶을때 바퀴나 사람이 탈수 있도록 사람 캐릭터가 있으면 더 좋았을거 같습니다</p><h1 id="백로그-만들기"><a href="#백로그-만들기" class="headerlink" title="백로그 만들기"></a>백로그 만들기</h1><p>이번 스크럼게임의 주제를 저희는 도시 만들기로 했습니다 (많은 자료가 도시를 만들었고 처음 진행하는 행사라 무난한 주제를 잡았습니다) 심시티를 하듯이 맵을 구상해야 했습니다 도로가 있고 강이 흐르는 아주 간단한 지도를 생각했습니다 그렇다면 도시에 있는것들이 무엇이 있을까를 고민해서 백로그를 만들었습니다</p><ul><li>강을 건널수 있는 다리</li><li>가정집 (1층짜리 2층짜리)</li><li>경찰서</li><li>소방서</li><li>공원</li><li>교회</li><li>유치원</li><li>버스정류장</li><li>편의점</li><li>병원</li><li>화장실</li><li>벤치</li><li>기념비</li></ul><p>각자 백로그에는 몇가지 요구사항을 넣었습니다 예를 들면 기념비의 경우 개발자를 위한 기념비를 건설해주세요 라는 요구사항이 있으며, 교회의 경우 십자가 모양이 있어야 한다는 건물의 특징을 요구사항에 잘 적어놨습니다 <img src="https://raw.githubusercontent.com/devload/devload.github.io/master/assert/image/ahea_lego_scrum1/4.png" alt="유튜브 스크럼 검색 캡쳐"> 사실 백로그를 몇가지 이렇게 제시했지만 만약 제가 다음 행사를 진행한다면 큰 주제만 정하고(심시티처럼 도시를 건설하던지, 심즈처럼 신혼집을 꾸미던지) 백로그는 팀에서 정하라고 해볼까도 합니다 백로그의 요구사항을 아주 구체적으로 넣지는 않았습니다.. 일부러요.. 왜냐하면 스크럼을 하면서 고객과의 소통을 중요하게 인식시키고 싶었는데요.. 요구사항을 일부러 추상적으로 해서 고객에게 자꾸 물어보거나 또는 팀에서 꾸준한 커뮤니케이션을 통해 요구사항을 구체화 하는 그런 액션이 일어나기를 바랬습니다 또 각자 팀마다 재미있는 아이디어가 들어가서 독특한 결과물이 나오길 기대했죠 첨부파일을 통해 저희팀에서 사용한 백로그를 공유드립니다 [<a href="https://github.com/devload/devload.github.io/tree/master/assert/file/ahea\_lego\_scrum1\]" target="_blank" rel="noopener">https://github.com/devload/devload.github.io/tree/master/assert/file/ahea\_lego\_scrum1\]</a></p><h1 id="플래닝-포커"><a href="#플래닝-포커" class="headerlink" title="플래닝 포커"></a>플래닝 포커</h1><p><img src="https://upload.wikimedia.org/wikipedia/commons/thumb/e/eb/CrispPlanningPokerDeck.jpg/250px-CrispPlanningPokerDeck.jpg" alt="플래닝 포커"> 레고 스크럼 게임의 핵심은 레고로 결과물을 잘 뽑아내는게 목표가 아니고 스크럼 자체를 경험하는게 아주 중요한 목표라고 생각합니다 이번 스프린트에서 얼마만큼의 백로그를 소모할것인지 목표로 하려면 백로그를 소모하는데 얼마만큼의 워킹이 걸릴지를 잘 예측해야 합니다 그러려면 모든 팀원이 백로그를 해결하는데 있어 같은 생각을 가져야 합니다 예를 들면 회원가입이라는 백로그가 있다고 했을때 A는 2시간이 걸릴거 같다고 생각하지만 B는 30분이면 끝낼수 있을거라는 생각을 하고 있다면 A는 간단하게 끝낼 방법을 생각하지 못했기 때문에 B보다 오랜 시간이 걸린다고 예측했을수도 있고 반대로 B는 A가 예측한 문제점을 고려하지 않았을 수도 있겠죠 이때 모든 팀원들이 백로그에 대해 같은 생각을 만들어주는 방법중에 하나로 플래닝 포커를 합니다 <a href="https://www.youtube.com/watch?v=0FbnCWWg_NY&amp;t=179s" target="_blank" rel="noopener">Agile in Practice: Planning Poker - YouTube</a> 아이폰/안드로이드 앱에 <code>scrum time</code>이라는 앱을 추천드립니다</p><h1 id="행사에-필요한-다양한-비품들"><a href="#행사에-필요한-다양한-비품들" class="headerlink" title="행사에 필요한 다양한 비품들"></a>행사에 필요한 다양한 비품들</h1><p>이번 아해에서 진행한 레고스크럼에서 애자일의 가치중 가장 높은 우선순위로 잡은것은 커뮤니케이션입니다 모르는 사람들과 팀을 구성하여 한두시간동안 커뮤니케이션을 잘하려면 뭐가 필요할까 고민했습니다 그래서 우선적으로 준비해야 할것이 <code>명찰</code>이였습니다 별거 아닌거 같지만 이름을 몰라서 호칭이 너무 애매해지는것을 막고 싶었습니다 두번째로 스크럼 보드를 직접 그려보는 경험이 필요할거 같았습니다 행사 전날까지도 고민했던 부분인데 lego4scrum에서는 팀이 구성되면 책상을 옮기거나 하면서 가볍게 호흡해보는 것이 좋다라고 나옵니다 스크럼보드도 직접 그리면서 하나의 가벼운 호흡 맞추기가 되었으면 했습니다 참고로 저희 스크럼 보드는 todo/doing/done이 구분되어 있는 표와 번다운차트가 있었습니다 스크럼 보드를 보면서 진행사항을 확인할수 있도록 하고 싶었습니다 저희는 지도도 직접 그리게 했습니다 마찬가지로 가벼운 호흡 맞추기였습니다 스크럼보드와 지도를 그리기 위해 한팀당 b2용지 두장이 필요했고 색연필을 제공해드렸습니다 또 포스티지를 드렸는데 스프린트 백로그로 옮길때 사용하고, 지도에 건물 짓기 전에 포스티지로 표현해놓는 식으로 유튜브에서는 많이 하는데 저는 진행자로써 굳이 어떻게 써라 라고 말씀드리진 않았습니다 나눠드리면 알아서 잘 쓰십니다</p><h1 id="행사진행"><a href="#행사진행" class="headerlink" title="행사진행"></a>행사진행</h1><p>팀구성이 다 되었다면 레고 스크럼 게임 진행방법을 리뷰합니다 저희는 플래닝 포커를 시작전에 연습을 몇번 하고 진행했습니다 플래닝 포커를 너무 귀찮아 하지 않도록 행사 진행하면서 애자일 코치들이 진행을 잘 잡아주셔야 할거 같습니다 스크럼게임은 3단게로 진행합니다 게임전 - 게임 - 게임 후</p><h2 id="게임전"><a href="#게임전" class="headerlink" title="게임전"></a>게임전</h2><h3 id="팀구성"><a href="#팀구성" class="headerlink" title="팀구성"></a>팀구성</h3><p>최대한 모르는 사람끼리 팀이 되게 해주세요 한팀당 4-6명이 적당합니다</p><h3 id="백로그-만들기-1"><a href="#백로그-만들기-1" class="headerlink" title="백로그 만들기"></a>백로그 만들기</h3><p>저희는 저희가 정한 백로그를 나눠드렸습니다 백로그는 많으면 많을수록 좋습니다 절대 못할만큼의 양을 주세요 팀에서 선택과 집중을 할지 안할지는 모르지만 충분히 할수 있도록 하게 하지 마세요</p><h3 id="추정하기"><a href="#추정하기" class="headerlink" title="추정하기"></a>추정하기</h3><h3 id="지도그리기"><a href="#지도그리기" class="headerlink" title="지도그리기"></a>지도그리기</h3><h3 id="스크럼-보드-만들기"><a href="#스크럼-보드-만들기" class="headerlink" title="스크럼 보드 만들기"></a>스크럼 보드 만들기</h3><h2 id="게임"><a href="#게임" class="headerlink" title="게임"></a>게임</h2><p>3번의 스프린트 계획 3분 - 스프린트7분 리뷰 5분 처음 스프린트에서는 계획의 시간을 좀 길게 주는것을 권장합니다 시간의 압박을 계속 줘야 합니다 시간이 거의 다 되면 계속 깜빡거리는 카운트다운 시계가 혹시 있다면 그런거 쓰세요 그리고 계속 시간을 알려주면서 귀찬게 만들고 스트레스를 계속 줘야 합니다 또 중간중간 요구사항을 강력하게 변경하세요 - 건물 색을 통일시켜주세요 - 좌우 대칭으로 만들어주세요 - 더 넓게 만들어주세요 진행하면서 계속 요구사항을 흔들어주세요 실제로 일어날만한 다양한 이벤트를 넣으세요 - 병에 걸리셨습니다 3분 쉬세요 - a님과 b님 팀을 이번스프린트에서 바꿔주세요</p><h2 id="결과-보고-회고"><a href="#결과-보고-회고" class="headerlink" title="결과 보고 (회고)"></a>결과 보고 (회고)</h2><p>회고에서는 전반적으로 다양한 의견이 나오면 좋습니다 - 무엇을 느꼈나요 - 스크럼 팀의 진행에 어떤 느낌을 받았나요 - 스프린트 반복은 잘 진행된거 같나요 - 다음에 게임을 한다면 무엇이 바껴야 하나요 - 요구사항 변경이 될 때 기분이 어땠나요</p><h2 id="애자일-코치"><a href="#애자일-코치" class="headerlink" title="애자일 코치"></a>애자일 코치</h2><p>애자일 전문가가 꼭 필요한건 아닙니다 애자일코치가 있다면 이분의 역할은 진행이 잘 되지 않거나 잘못된 방향으로 가고 있는 스크럼 내용을 중간중간에 잡아내서 피드백을 주시면 좋습니다 팀에 독단적인 맴버가 있거나 대화의 방식에 문제가 있다면 잡아주는게 좋습니다 애자일코치는 레고 게임에 참여하기보단 돌아다니면서 코치해주는 스탭과 같은 느낌입니다 (뭐든 마찬가지지만 어떻게 정하느냐에 따라 다릅니다 팀에 하나씩 있어서 레고도 같이할수도 있는거죠.. 정하기 나름입니다)</p><h2 id="스크럼-마스터"><a href="#스크럼-마스터" class="headerlink" title="스크럼 마스터"></a>스크럼 마스터</h2><p>스크럼마스터가 꼭 필요한건 아닙니다 스크럼마스터는 스크럼 진행을 하는 역할입니다만 팀장은 아닙니다 스크럼마스터는 개인의 의견을 최대한 내지 마시고 진행에 집중하는것이 좋습니다 실제 스크럼마스터는 프로젝트 개발에 참여하기보단 진행에 참여하는 경우가 많습니다 팀원들이 잘 의사소통할 수 있도록 노력해야 합니다</p><h2 id="고객"><a href="#고객" class="headerlink" title="고객"></a>고객</h2><p>고객은 아주 변덕스럽고 고집이 쎄고 뭐든 잘 모르는척 해야 합니다 요구사항이 분명하지 않다면 분명 질문이 올텐데요.. 물어보는 질문 이외에 것은 답변을 최대한 하지 마세요 하나를 물어보면 열을 말해주는 고객이 되지 말란 말입니다~ 실제 고객은 그렇지 않나요 ㅎㅎ 저희가 기획단계에서 준비한 내용은 이렇습니다 lego4scrum과 저희문서를 함께 보신다면 레고 스크럼 게임이 무슨행사일지 조금은 감을 잡으시는데 도움이 되길 바랍니다</p>]]></content>
      
      
      <categories>
          
          <category> 미분류 </category>
          
          <category> lego </category>
          
      </categories>
      
      
    </entry>
    
    <entry>
      <title>Spring, 어디까지 까봤니? (배경지식, Servlet)</title>
      <link href="/2018/05/11/spring-ec-96-b4-eb-94-94-ea-b9-8c-ec-a7-80-ea-b9-8c-eb-b4-a4-eb-8b-88-eb-b0-b0-ea-b2-bd-ec-a7-80-ec-8b-9d-ec-9e-91-ec-84-b1-ec-a4-91/"/>
      <url>/2018/05/11/spring-ec-96-b4-eb-94-94-ea-b9-8c-ec-a7-80-ea-b9-8c-eb-b4-a4-eb-8b-88-eb-b0-b0-ea-b2-bd-ec-a7-80-ec-8b-9d-ec-9e-91-ec-84-b1-ec-a4-91/</url>
      
        <content type="html"><![CDATA[<h2 id="Java-Servlet"><a href="#Java-Servlet" class="headerlink" title="Java Servlet"></a>Java Servlet</h2><p>최근에 java에 입문한 쥬니어라면 “Java Servlet”에 대해 어디선가 들어봤지만, 누구도 자세히 알려주지 않습니다. 주로 회사에서 배우다보면 업무에 필요한 프레임워크 레벨부터 배우기 때문입니다. Java Servlet의 소스를 보면 아래와 같이 설명되어 있습니다. [code language=”java”] package javax.servlet; import java.io.IOException; /*<em> </em> Defines methods that all servlets must implement. <em> </em> <em> A servlet is a small Java program that runs within a Web server. Servlets </em> receive and respond to requests from Web clients, usually across HTTP, the <em> HyperText Transfer Protocol. </em> <em> </em> To implement this interface, you can write a generic servlet that extends <em> <code>javax.servlet.GenericServlet</code> or an HTTP servlet that extends </em> <code>javax.servlet.http.HttpServlet</code>. * * * This interface defines methods to initialize a servlet, to service requests, <em> and to remove a servlet from the server. These are known as life-cycle </em> methods and are called in the following sequence: *</p><p><em>1.  The servlet is constructed, then initialized with the <code>init</code> \</em> method. *</p><ol start="2"><li>Any calls from clients to the <code>service</code> method are handled. *</li><li>The servlet is taken out of service, then destroyed with the <em> <code>destroy</code> method, then garbage collected and finalized. </em></li></ol><p>* * * In addition to the life-cycle methods, this interface provides the <em> <code>getServletConfig</code> method, which the servlet can use to get any </em> startup information, and the <code>getServletInfo</code> method, which allows <em> the servlet to return basic information about itself, such as author, </em> version, and copyright. <em> </em> @version $Version$ <em> </em> @see GenericServlet <em> @see javax.servlet.http.HttpServlet </em>/ public interface Servlet { [/code] 우선 2가지를 자세히 볼 필요가 있습니다.</p><ol><li>“package javax.servlet;” Servlet 인터페이스가 속한 패키지는 javax.servlet이다. 곧 Servlet은 java extension 기능이고, java 자체적으로 제공하는 기능인 것입니다.</li><li>“A servlet is a small Java Program that runs within a Web server” Servlet은 웹서버에서 동작하는 작은 프로그램이다.</li></ol><p>자세히 보면 Servlet의 동작 방식도 알 수 있습니다. 생성자로 인해 생성되면, “init” 메소드가 실행되어 초기화되고, client로부터의 요청은 “service” 메소드가 처리하고, 제거될 때는 “destroy” 메소드가 실행됩니다. 물론 깊게 보려면 각 메소드별로 소스를 봐야 하겠지만, javadoc만 정독해도 클래스의 역할과 흐름을 어느정도 파악할 수 있습니다.</p><h2 id="Servlet-Container-Web-Container"><a href="#Servlet-Container-Web-Container" class="headerlink" title="Servlet Container (Web Container)"></a>Servlet Container (Web Container)</h2><p>“Servlet Container”라는 이름에서 유추해보면 무언가 Servlet을 여러개 포함하고 있을 것 같습니다. “Servlet Container”는 개념적인 이야기이기 때문에 위키피디아의 설명을 찾아보았습니다. <img src="https://ahea.files.wordpress.com/2018/05/web_container.png" alt="web_container">   위키피디아 설명의 가장 상단에 작성된 요약본이지만, 중요한 얘기는 다 나왔습니다.</p><ol><li>서블릿과 상호 작용한다.</li><li>서블릿의 생명주기를 관리해준다.</li><li>URL과 특정 서블릿을 맵핑하여 URL 요청이 올바른 접근 권한을 갖도록 보장한다.</li></ol><p>위에서 길게 설명한 내용(Java servlet, Servlet Container)을 간략하게 그림으로 살펴보면 아래와 같습니다. <img src="https://ahea.files.wordpress.com/2018/05/servlet.png" alt="servlet"> 즉, “Servlet Container는 Servlet의 생명주기를 관리하여 Servlet을 생성해서 가지고 있고, 생성한 Servlet에 특정 URL을 맵핑하여 Client의 요청을 넘겨준다. 그리고  Servlet은 Servlet Container가 전달해준 요청을 적절하게 처리하고 응답을 생성하여 Servlet Container를 통해 회신해준다.” 정도로 정리할 수 있겠습니다.</p>]]></content>
      
      
      <categories>
          
          <category> 미분류 </category>
          
          <category> 공개스터디 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> java </tag>
            
            <tag> servlet </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>Spring, 어디까지 까봤니? (발표자료)</title>
      <link href="/2018/05/11/spring-ec-96-b4-eb-94-94-ea-b9-8c-ec-a7-80-ea-b9-8c-eb-b4-a4-eb-8b-88-eb-b0-9c-ed-91-9c-ec-9e-90-eb-a3-8c/"/>
      <url>/2018/05/11/spring-ec-96-b4-eb-94-94-ea-b9-8c-ec-a7-80-ea-b9-8c-eb-b4-a4-eb-8b-88-eb-b0-9c-ed-91-9c-ec-9e-90-eb-a3-8c/</url>
      
        <content type="html"><![CDATA[<p>[slideshare id=96711359&amp;doc=springframeworkdebugging-180511135733]</p>]]></content>
      
      
      <categories>
          
          <category> 미분류 </category>
          
          <category> 공개스터디 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> java </tag>
            
            <tag> spring </tag>
            
            <tag> application context </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>[MSA] #6 Spring Cloud Netflix</title>
      <link href="/2018/04/26/msa-6-spring-cloud-netflix/"/>
      <url>/2018/04/26/msa-6-spring-cloud-netflix/</url>
      
        <content type="html"><![CDATA[<p>스프링과 전 세계에서 MSA를 제일 잘하는 기업 중 하나인 Netflix에선 이미 MSA 구축을 편하게 하는 많은 기술과, 갖가지 이슈에 대한 해결책 또한 제공을 하고 있습니다.</p><blockquote><p><a href="https://cloud.spring.io/spring-cloud-netflix/#quick-start" target="_blank" rel="noopener">Spring Cloud Netflix</a>는 자동 환경 설정과 Spring Environment 및 다른 Spring 프로그래밍 모델 관념의 바인딩을 바탕으로 Spring Boot 어플리케이션을 위한 Netflix OSS(Open Source Software) 통합을 제공합니다. 몇 가지 간단한 어노테이션을 사용하여 어플리케이션 내부의 공통 패턴을 신속하게 사용하고 설정할 수 있습니다. 그리고 battle-tested를 거친 Netflix component를 통해 대규모 분산 시스템을 구축할 수 있습니다. 제공되는 패턴에는 Service Discovery (Eureka), Circuit Breaker (Hystrix), Intelligent Routing (Zuul) and Client Side Load Balancing (Ribbon) 등을 제공합니다.</p></blockquote><p>기능</p><ul><li>Service Discovery : Eureka 인스턴스를 등록할 수 있으며, client는 Spring이 관리하는 빈을 사용하여 탐지할 수 있습니다.</li><li>Service Discovery : 내장된 Eureka Server는 선언적 java config를 통하여 생성될 수 있습니다.</li><li>Circuit Breaker : Hystrix clients는 간단한 어노테이션 기반으로 구축될 수 있습니다.</li><li>Circuit Breaker : 선언적 java config로 내장된 Hystrix dashboard</li><li>선언적 REST Client : Feign은 JAX-RS 또는 Spring MVC 어노테이션으로 인터페이스를 동적으로 구현합니다.</li><li>Client Side Load Balancer: Ribbon</li><li>External Configuration : Spring 환경에서 Archaius로 연결 (Spring Boot를 사용하여 Netflix 구성 요소를 설정 가능)</li><li>Router and Filter : Zuul 필터의 자동 등록 및 Reverse Proxy 생성 설정 접근에 대한 간단한 규칙</li></ul><p>Zuul, Eureka, Ribbon을 위주로 Spring Cloud Netflix 생태계가 어떻게 돌아가는지 알아보겠습니다. Zuul은 API Gateway입니다. 외부에서 들어오는 모든 요청은 Zuul로 들어오고, URL에 맞는 서비스로 라우팅을 시켜줍니다. 만약 동일한 서비스가 여러 개의 인스턴스에 있는 경우에는 로드밸런싱을 통해 트래픽을 나눕니다. 이는 Zuul에 내장된 Ribbon이 하는 기능이며, Default는 <a href="https://ko.wikipedia.org/wiki/%EB%9D%BC%EC%9A%B4%EB%93%9C_%EB%A1%9C%EB%B9%88_%EC%8A%A4%EC%BC%80%EC%A4%84%EB%A7%81" target="_blank" rel="noopener">라운드로빈</a> 방식에 의해 분산이 됩니다. 또한 Filter 기능을 통하여 로깅, 인증, 모니터링, CORS 정책 같은 서비스 간의 공통된 기능을 처리할 수 있습니다. 이외의 기능은 <a href="https://github.com/Netflix/zuul/wiki" target="_blank" rel="noopener">이곳</a>을 통해 확인해주세요. 위에서 Zuul이 URL에 맞는 서비스로 라우팅을 시켜준다고 했습니다. 이 과정에서 Eureka는 URL을 해석하여 해당 서비스의 서버 정보를 Zuul에게 전달합니다. 그럼 이를 통해서 Zuul이 해당 서버에 라우팅을 해주는 것이지요. 그럼 우리의 도서사이트에 Spring Cloud Netflix를 최종적으로 적용해 보겠습니다. <img src="http://cfile25.uf.tistory.com/image/9926564E5AD87FCB13717A" alt=""> 참고</p><ul><li><a href="https://cloud.spring.io/spring-cloud-netflix/#quick-start" target="_blank" rel="noopener">https://cloud.spring.io/spring-cloud-netflix/#quick-start</a></li><li><a href="https://github.com/Netflix/zuul/wiki" target="_blank" rel="noopener">https://github.com/Netflix/zuul/wiki</a></li></ul>]]></content>
      
      
      <categories>
          
          <category> 미분류 </category>
          
      </categories>
      
      
    </entry>
    
    <entry>
      <title>[MSA] #5 Service Discovery</title>
      <link href="/2018/04/26/msa-5-service-discovery/"/>
      <url>/2018/04/26/msa-5-service-discovery/</url>
      
        <content type="html"><![CDATA[<p><strong>MSA는 Cloud 환경과 밀접하게 관련이 있습니다.</strong> 각 서비스마다 다른 서버에 올려야 되는데, 물리 서버를 사용하게 되면 관리하기 힘들어집니다. 100개의 서버가 필요하다면 100개의 물리 서버의 비용과 장소 비용 하드웨어 관리 비용 등이 듭니다. 그러나 Cloud를 사용하게 되면 이런 이슈를 AWS와 같은 솔루션에서 해결해줍니다. 그리고 <strong>가용성을 고려</strong>해야 되기 때문에도 많은 서버에 관리해야 합니다. 예를 들면 주문 서비스는 수익과 직결되는 서비스입니다. 그래서 트래픽과 같은 환경에 따라 문제가 된다면 금전적으로 손실을 얻을 수 있습니다. 그래서 하나의 인스턴스(서버)에 하나의 서비스를 올려두는 것이 아니라 두 개 이상의 인스턴스에 동일한 서비스를 올린 후 인스턴스 1에 문제가 생기면 인스턴스 2를 통해 로직을 수행합니다. (일반적으로는 모든 서비스에 가용성을 고려해서 여러 개의 인스턴스를 둡니다.) <img src="http://cfile25.uf.tistory.com/image/99F603435A926F0B010F31" alt=""> Auto-scaling을 사용하면 앞선 이슈를 보다 더 간단하게 해결할 수 있습니다 Auto-scaling은 트래픽에 따라 서버(인스턴스)를 조정해줍니다. 예를 들면 새벽과 같이 트래픽이 낮을 때는 최소의 서버만을 구동시키고, 트래픽이 많은 오후 시간대에는 트래픽에 따라 3, 4, 5개 … 자동적으로 늘려줍니다. 이처럼 Cloud 환경에서는 Auto-scaling, 업그레이드, 확장 등의 이유로 인스턴스가 생성, 소멸되며 때로는 IP 주소가 변경되기까지 합니다. 이것은 Cloud에서 변경이 되는 것이지 우리의 서비스가 이를 알 수 없습니다. 다시 말해서 Auto-scaling이 되어서 인스턴스가 하나 생성되었더라도 우리는 이를 알아차리고, 생성된 인스턴스에 트래픽을 분산시킬 수 없습니다. 이런 것을 감지하는 역할이 Service Discovery입니다. Service Discovery가 어떻게 돌아가는지에 대해 알아보겠습니다. <img src="http://cfile27.uf.tistory.com/image/99E44A3A5A955A902C9BCC" alt=""></p><ol><li><p>각 서비스가 실행될 때 Service Registry에 IP, port 등의 서버 정보를 저장합니다. (파란 점선)</p></li><li><p>Client에서 HTTP 요청이 들어옵니다.</p></li><li><p>Router는 정해진 시간마다 Service Registry에 가서 서비스들의 서버 정보를 가져옵니다.</p></li><li><p>요청이 들어온 URL을 해석해 Service Registry에서 가져온 서버 정보를 토대로 해당 서비스로 라우팅을 시킵니다. (http://{url}/users… 란 URL이 있으면 유저 서비스라는 것을 짐작할 수 있겠죠?)</p></li></ol><p>몇 가지 더 보충하자면 요청이 들어올 때마다 Service Registry를 통해 서버 정보를 가져오지는 않고요. 한번 가져온 정보는 알고리즘에 의해 캐시가 됩니다. 그리고 Service Registry는 지정된 시간에 한 번씩 서비스들에게 ping을 보내서 서버가 살아있는지 확인하고 죽어있으면 정보를 지웁니다. 위의 서버를 운영 중 갑자기 주문 트래픽이 늘어나면 Auto-scaling에 의해  인스턴스 2가 생성이 됩니다. 그 후 주문 서비스가 인스턴스 2에 올라가게 되고 그 과정에서 해당 서버 정보를 Service Registry 서버에 등록을 합니다. 그리고 하나의 서비스가 두 개의 서버에 있기 때문에 로드밸런싱 되어 트래픽이 분산됩니다. 그리고 IP, port를 이미 가지고 있기 때문에 DNS 서버에 다녀오지 않습니다. 이는 성능상으로도 이점이 있다고 합니다. 참고</p><ul><li><a href="https://www.nginx.com/blog/service-discovery-in-a-microservices-architecture/" target="_blank" rel="noopener">https://www.nginx.com/blog/service-discovery-in-a-microservices-architecture/</a></li></ul>]]></content>
      
      
      <categories>
          
          <category> 미분류 </category>
          
      </categories>
      
      
    </entry>
    
    <entry>
      <title>[MSA] #4 API Gateway</title>
      <link href="/2018/04/26/msa-4-api-gateway/"/>
      <url>/2018/04/26/msa-4-api-gateway/</url>
      
        <content type="html"><![CDATA[<p>MSA는 각각의 서비스를 API 형태로 제공한다는 것을 알게 되었습니다. 그러면서 몇 가지 이슈가 생겨나게 됩니다. 예를 들면 서비스마다 주소가 다르다는 점과 로깅, 모니터링, CORS처럼 서비스 간의 공통된 로직의 관리가 있습니다. 차근차근 API Gateway가 어떤 식으로 이를 해결하는지 알아보겠습니다. <strong>API Gateway란? </strong>API 서버 앞단에서 모든 API 서버들의 End-Point를 단일화하여 묶어주는 녀석. <strong>기능</strong> <strong>1. API 요청을 한 곳에서 받아서 해당 서비스로 라우팅(이동)을 시켜줍니다.  </strong> 예를 들어 다음과 같은 환경에 서비스가 구동한다고 가정하겠습니다.</p><p> 유저</p><p>책</p><p>주문</p><p>주소</p><p>1.1.1.1</p><p>2.2.2.2</p><p>3.3.3.3</p><p>백엔드 팀은 3가지의 서비스를 완벽하게 구현을 하였고, 프론트엔드 팀 또는 앱 팀과의 협업을 위해 API 문서를 잘 정리한 후 전달을 하면 잠시 후 해당 팀에서  “왜 각각의 서비스마다 호출해야 될 주소가 달라요?”라며 물을 겁니다. 지금이야 서비스가 3개지만 프로덕션는 점점 커갈 것이고, 종국에는 수십, 수백 개의 서비스마다 주소를 구별해야 하게 되면 큰 이슈로 남을 것입니다. API Gateway는 간단하게 모든 서비스의 요청을 받은 후 해당 서비스로 라우팅(이동)을 시켜줍니다. <img src="http://cfile28.uf.tistory.com/image/99AE5E3A5A900B53197C5F" alt=""></p><api gateway="" 없는="" 구조=""><p><img src="http://cfile10.uf.tistory.com/image/9912B13A5A900B5310665A" alt=""></p><api gateway=""><p><strong>2. 보안을 강화해줍니다.</strong> API Gateway는 외부에서 접근할 수 있도록 public으로 열어두고 각 서비스들은 내부 IP에서만 접근할 수 있게 private으로 구축해두게 되면 보안적으로 이점이 있습니다. <strong>3. 각 서비스의 공통된 로직을 처리해줍니다.</strong> 대표적으로는 로깅, CORS(Cross-Origin Resource Sharing), 보안 및 인증, 모니터링 등이 있습니다. 온라인 서점을 예로 들면 유저, 책, 서비스를 이용하기 위해서 A라는 인증 방법을 사용하고 있습니다. 다시 말해서 A라는 로직을 통과해야 유저정보를 보거나 책을 주문할 수 있는 거죠. 그런데 만약 서비스를 하고 있다가 A로직의 치명적인 이슈가 발생하여 B라는 로직으로 변경을 하기 위해서는 모든 서비스의 인증 로직을 변경해야 됩니다. 이는 프로젝트 간의 중복 코드가 생겨났고 악취를 풍긴다는 걸 의미합니다. 이러한 이슈를 API Gateway의 필터 기능을 통해 해결할 수 있습니다. <img src="http://cfile23.uf.tistory.com/image/99DF42355A91552C1454FF" alt=""> 이 이외에도 API Gateway 제품에 따라 스트레스 테스트, 로드밸런싱 등 다양한 기능을 제공합니다.</p></api></api>]]></content>
      
      
      <categories>
          
          <category> 미분류 </category>
          
      </categories>
      
      
    </entry>
    
    <entry>
      <title>[MSA] #3 Circuit Breaker</title>
      <link href="/2018/04/26/msa-3-circuit-breaker/"/>
      <url>/2018/04/26/msa-3-circuit-breaker/</url>
      
        <content type="html"><![CDATA[<p><strong>Circuit Breaker란?</strong> 에너지가 있는 도선과 중립 도선 사이의 전류 균형이 깨졌을 때, 전류를 차단하는 장치 학생 때 포기한 물리수업에서 나올 법한 말들이 나오네요. 한국어로는 누전 차단기입니다. (두꺼비집) <img src="http://cfile8.uf.tistory.com/image/99C7F6385AE1C49E249D48" alt=""> 누전으로 인해 집이 다 불타버리는 것보다는 이상 징후가 있을 때 전류를 차단하여 잠깐 불편한 것이 훨씬 낫습니다. 이렇게 접근하면 Circuit Breaker를 좀 더 쉽게 이해할 수 있습니다. 앞에서 MSA의 장점 중 하나가 한 서비스는 다른 서비스에 영향을 안 끼친다고 했습니다. 그럼 만약 한 서비스가 다른 서비스에 디펜던시를 가지고 있어도 영향을 끼치지 않을까요?? 온라인 서점 서비스를 통해 이야기해보겠습니다. 책 리스트를 호출하는 API가 있습니다. 그런데 기획팀에서 리스트의 최상단에는 고객이 구입할만한 책을 보여주기를 요구했습니다. 우리는 간단하게 개인화 서비스의 API를 통하여 고객에게 맞는 상품을 가져온 뒤 리스트 첫 번째 항목에 넣을 것입니다. 그런데 아래처럼 개인화 서비스 모두가 과도한 트래픽이나 서버 문제 등 다양한 이유로 마비가 되면 어떻게 될까요? <img src="http://cfile22.uf.tistory.com/image/992844395AE1C6A7203A56" alt=""> 개인화 서비스의 장애가 그대로 책 서비스에도 전파되어, 책 서비스 또한 장애를 일으키게 됩니다. 이를 <strong>장애 전파</strong>라합니다. 과도한 트래픽에 의한 장애를 좀 더 생각해보겠습니다. 서비스는 감당할 수 있는 Request의 수를 정해놓고 그 이상의 Request가 오게 되면 큐에 쌓이게 되고 순차적으로 처리가 됩니다. (tomcat의 max-thread) 현재 개인화 서비스는 과도한 트래픽으로 인해 큐에 많은 수의 Request가 쌓여있는 상태고 책 서비스가 개인화 서비스를 호출하게 되면 큐가 다 비워질 때까지 기다려야 되는 끔찍한 상황이 오게 됩니다. 하지만 우리는 이것을 대비하여 timeout을 설정해 두곤합니다. 그래서 책 서비스가 개인화 서비스를 호출했을 때, 설정한 timeout을 넘어가게 되면 에러를 발생시켜 무작정 기다리는 것을 방지할 수 있습니다. 그러나 또 한편으로는 문제가 생길 때마다 설정한 timeout 만큼 기다려야 합니다. MSA로 변경하면서 서비스 간에 영향을 안 끼칠 것을 기대했지만, 기대와 달리 서비스 간에 의존을 하고 있으면 강하게 영향을 끼치게 됩니다. Circuit Breaker는 이러한 문제를 해결할 수 있게 도와줍니다. 개인화 서비스가 정상적으로 동작할 때는 Circuit Breaker는 타 서비스로 잘 흘려보내줍니다. <img src="http://cfile9.uf.tistory.com/image/9996603A5AE1CFA32A45DD" alt=""></p><p>&lt;일반적인 경우&gt;</p><p>그런데 개인화 서비스가 비정상적일 경우에는 Circuit Breaker는 이를 감지하여 개인화 서비스로 보내지 않고, 책 서비스에 다시 되돌려 줍니다. Circuit Breaker 구현체마다 에러를 핸들링 할 여러 가지 방식이 있는데, 대표적으로는 Default 값을 설정하는 것입니다. 가령, 개인화 서비스의 추천 책 API가 문제가 될 것을 방지해  Default로 스테디셀러 책을 두는 것입니다. 그렇게 되면 개인화 서비스가 마비됨에도 불구하고 에러 없이 자연스러운 연출이 가능하게 됩니다. 더불어 설정한 timeout 만큼 기다릴 필요도 없게 됩니다. 왜냐하면 Circuit Breaker가 문제를 감지하게 되면 그 즉시 대응을 하기 때문입니다. <img src="http://cfile5.uf.tistory.com/image/9950963A5AE1CFA30372FF" alt=""></p><p>&lt;문제가 생긴 경우&gt;</p>]]></content>
      
      
      <categories>
          
          <category> 미분류 </category>
          
      </categories>
      
      
    </entry>
    
    <entry>
      <title>[MSA] #2 Microservice Architecture 란?</title>
      <link href="/2018/04/26/msa-2-microservice-architecture-eb-9e-80/"/>
      <url>/2018/04/26/msa-2-microservice-architecture-eb-9e-80/</url>
      
        <content type="html"><![CDATA[<p>이전 글에서는 Monolithic Architecture에 대해서 알아봤습니다. Monolithic은 모든 것이 하나로 묶여있다고 말했었는데요, 이번에 소개할 MSA는 묶여있는 것을 나누는 것입니다. 마틴 파울러는 MSA를 다음과 같이 정의합니다.</p><blockquote><p>마이크로 서비스 아키텍처 스타일은 단일 응용 프로그램을 나누어 작은 서비스의 조합으로 구축하는 방법이다.</p></blockquote><p><img src="http://cfile21.uf.tistory.com/image/99C9C7455A71C8300AA0DE" alt=""> 위의 그림은 이전에 본 Monolithic으로 구현된 프로젝트입니다. MSA로 변경하게 되면 어떻게 변할까요? <img src="http://cfile9.uf.tistory.com/image/990DCB4D5A7B067D307CC1" alt=""> 가로 방향으로 구분되어 있던 경계가 MSA에서는 세로 방향으로 구분됩니다. 이는 하나의 프로젝트가 프레젠테이션, 비즈니스, 데이터베이스 계층으로 구분되던 것을 하나의 서비스가 하나의 프로젝트로서 프레젠테이션, 비즈니스, 데이터베이스 계층을 가지게 됨을 의미합니다. 즉 각각의 서비스 별로 프로젝트가 생기게 되며, 하나의 서비스가 문제가 생긴다고 해서 다른 서비스에 영향을 주지 않습니다. Method로 호출하면 되는 걸 왜 굳이 REST 방식으로 호출하고, 잘 돌아가는 프로젝트를 굳이 시간을 들여 나누어서 얻을 수 있는 것은 어떤 것이 있을까요? <strong>1. 빌드 및 테스트 시간을 단축시킬 수 있다.</strong> 30개의 서비스를 가진 Monolithic 의 빌드 시간이 30분이었다면, MSA는 각각의 서비스를 1분 만에 빌드 할 수 있습니다. 이는 CI / CD를 추구하는 기업에서는 좀 더 적합한 모델이 됩니다. 왜냐하면 하루에도 몇 번을 빌드 및 배포를 해야 하는데 그때마다 많은 시간을 소모하게 된다면 낭비이기 때문입니다. <strong>2. 폴리글랏 아키텍처 구성이 가능하다.</strong> 상황에 맞게 기술을 유연하게 적용할 수 있습니다. 예를 들어 TPS(시간당 트랜잭션)가 높고, 읽기 작업이 많은 서비스에는 Node + Redis로 구현을 하고, 트랜잭션 및 안정성이 중요한 서비스에는 Spring + RDB를 적용할 수 있습니다. <strong>3. 탄력적이고 선택적인 확장이 가능하다.</strong> MSA는 작은 단위의 작업이라서 필요한 서비스만을 선택적으로 확장할 수 있습니다. 만약, 주문 서비스와 이벤트 서비스의 사용률이 90 : 10 이라면 이벤트 서비스만을 선택적으로 확장(scale out) 할 수 있습니다. <strong>4. 하나의 서비스가 다른 서비스에 영향을 주지 않습니다.</strong> 이전 글처럼 책을 무료로 주는 이벤트를 한다고 가정을 해보겠습니다. 이벤트 서비스에 트래픽이 몰려 해당 서버가 죽더라도 다른 서비스에는 영향이 가지 않습니다. 각 서버마다 서비스를 놓기 때문이죠. 물론, 죽은 서비스를 타 서비스가 호출하게 되면 문제는 생깁니다. 이는 Circuit Breaker에서 좀 더 알아보도록 하겠습니다.</p><p><img src="http://cfile24.uf.tistory.com/image/994B10335AD8704B2D3729" alt=""> 이러한 것은 각각의 서비스가 분리됨으로써 가능한 이점들입니다. 그러면 서비스를 분리함으로써 생기는 문제점은 무엇이 있을까요? <strong>1. 성능 이슈가 있다.</strong> Monolithic은 다른 서비스 간의 상호작용이 필요할 시에는 Method 호출을 이용합니다. 즉 이러한 행위는 메모리 안에서 일어나죠. 그러나 MSA와 같은 경우에는 주로 HTTP를 사용합니다. 이는 Network IO를 통하여 다른 서버까지 갔다 다시 와야 됨을 의미합니다. ‘첫 번째 문제점이 성능이라니…’라고 생각이 들 법도 하지만 요즘은 하드웨어나 기술이 많이 발전했고 성능보다는 유지 보수에 좀 더 무게중심을 둔다는 점을 미뤄볼 때, 개인적으로는 Client가 크게 체감하지 못할 정도면 MSA의 장점에 좀 더 손을 들어줘도 될 거 같습니다. <strong>2. 트랜잭션이 불편하다.</strong> Spring에서는 @Transactional이라는 어노테이션하나만 달아주면 자동적으로 트랜잭션 처리를 해줍니다. 그러나 서비스가 각각으로 나뉘게 되면 불편함이 따르긴 합니다. 그래서 MSA에서는 서비스 간에 Global 트랜잭션이 일어나는 상황보다는 Local 트랜잭션이 주로 이루어지게 경계를 나누고, 불가피하게 서비스 간에 트랜잭션이 필요하면 트랜잭션 로직을 추가합니다. <strong>3. 관리 포인트가 늘어난다.</strong> Monolithic은 간단한 경우 어플리케이션서버와 DB 서버 두 개를 관리하면 되지만, MSA에서는 기본적으로 서비스 수 * 인스턴스만큼의 서버 (경우에 따라 DB)가 존재하고 서버가 늘어난 만큼 로깅, 모니터링, 배포, 테스트, 클라우드 환경에서의 관리들은 부담스럽니다. 이러한 문제는 관리에 들어가는 비용을 줄이기 위해 자동화와 간단하게 모니터링할 수 있는 환경을 권장합니다. <strong>spring boot admin - 모니터링</strong> <strong>jenkins - 테스트, 빌드, 배포 자동화 (CI)</strong> <strong>MSA의 경계의 기준은 어떻게 될까요?</strong></p><ul><li>자율적인 기능</li><li>SRP</li><li>배포 단위의 크기</li><li>서브도메인</li><li>폴리글랏 아키텍처</li><li>선택적 확장</li><li>작고 애자일한 팀</li><li>트랜잭션</li></ul><p><strong>서비스간의 상호작용은 어떻게 이뤄져야 할까?</strong> <img src="http://cfile8.uf.tistory.com/image/99610A3B5AD8730D2060CD" alt=""> 주문이 일어날 때는 간략하게 유저와 책 정보를 주문 테이블에 넣고, 배송 서비스에 유저와 책에 대한 정보까지 전달을 합니다. 유저, 책은 동기적으로 일어나야겠지만 배송은 비동기적으로 일어나도 상관이 없을 것 같네요</p><blockquote><p>동기 : REST/JSON 비동기 : MQ 프로토콜</p></blockquote><p>MSA가 다른 Architecture과 마찬가지로 모든 상황에 적합한 것은 아닙니다. 각 기업마다 갖가지 상황이 존재할 것이고, 이를 기반으로 뭐를 내주고 뭘 얻을 것인지 이해타산을 잘 따져야 합니다. 특히 상황에 맞는 설계가 가장 중요할 것 같습니다 가령. Monolithic을 메인으로 삼고 유연성이 필요한 서비스들만을 분리하는 것도 하나의 방법이 됩니다. 참고</p><ul><li><a href="https://tkddlf59.github.io/2016/10/10/2016-10-10-msa1/" target="_blank" rel="noopener">https://tkddlf59.github.io/2016/10/10/2016-10-10-msa1/</a></li><li><a href="http://www.aladin.co.kr/shop/wproduct.aspx?ItemId=113808876" target="_blank" rel="noopener">http://www.aladin.co.kr/shop/wproduct.aspx?ItemId=113808876</a></li></ul>]]></content>
      
      
      <categories>
          
          <category> 미분류 </category>
          
      </categories>
      
      
    </entry>
    
    <entry>
      <title>[MSA] #1 Monolithic Architecture 란?</title>
      <link href="/2018/04/26/msa-1-monolithic-architecture-eb-9e-80/"/>
      <url>/2018/04/26/msa-1-monolithic-architecture-eb-9e-80/</url>
      
        <content type="html"><![CDATA[<p>요즘은 Microservice Architecture(이하 MSA)가 항상 화두에 올라있는 것 같습니다. 그래서 MSA가 도입된 배경과 갖가지 이슈를 어떻게 해결했는지에 대해 차근차근 써보려고 합니다. Monolithic이라는 단어를 들어보셨나요? 생소해서 구글에게 한번 물어봤습니다. <img src="http://cfile25.uf.tistory.com/image/991F7C355A70772D0994EB" alt=""> 개인적으로 ‘단단히 짜여 하나로 되어 있는’라는 어감은 참 부정적인 인상을 주네요. 왜냐하면 더 나은 코드와 설계를 위해서는 책이나 선배 개발자분들이 분리를 강조하셨기 때문이죠. “응집도를 높이고 결합도를 낮춰라”, “클래스를 분리해서 SRP를 준수하라” 등등. 이런 껄끄러운 마음을 가지고 Monolithic에 대해서 알아보도록 하겠습니다. Monolithic Architecture는 모든 것이 하나의 프로젝트에 묶여있는 것을 말합니다. 일반적으로는 MSA가 아니면 Monolithic으로 개발하고 있다고 생각하시면 됩니다. 이해가 잘 안되시더라도 천천히 글을 읽으시면 자연스럽게 이해하게 되실 겁니다. 온라인 서점을 만든다고 가정을 해보겠습니다. 초기 단계이니 작게 유저, 책, 주문 3가지의 서비스로 시작하고, MVC로 계층을 나누겠습니다. <img src="http://cfile21.uf.tistory.com/image/99C9C7455A71C8300AA0DE" alt=""> 위의 구조로 해당 사이트는 아무 문제 없이 잘 동작할 것입니다.  프로젝트, 데이터베이스 서버 총 2개의 서버만 관리하면 되기 때문에 편하게 운영을 할 수 있습니다. 그러나 이 온라인 서점 서비스가 점차 성장하기 시작했고, 많은 고객을 얻음과 동시에 그에 상응하는 갖가지 요구 사항으로 인해 서비스는 점차 복잡해져갑니다. 새로운 기능들도 생기고, 기존에 있던 기능들도 커져가죠. <img src="http://cfile23.uf.tistory.com/image/99663D405A71CF30233CAC" alt=""> 위의 그림처럼 점점 서비스가 커져가면서 갖가지 이슈가 생깁니다. <strong>1. 빌드 시간, 테스트 시간이 길어진다.</strong> 처음에는 전혀 문제가 되지 않던 빌드와 테스트가 서비스가 커짐에 따라 점점 오래 걸립니다. CI / CD (지속적 통합 / 지속적 배포)가 강조되고 있고, 페이스북 같은 경우는 하루에도 수십 번을 프로덕션에 배포를 한다고 합니다. (<a href="http://apstore.co.kr/%ED%8E%98%EC%9D%B4%EC%8A%A4%EB%B6%81%EC%9D%80-%EC%96%B4%EB%96%BB%EA%B2%8C-%EA%B0%9C%EB%B0%9C%ED%95%98%EA%B3%A0-%EB%B0%B0%ED%8F%AC%ED%95%A0%EA%B9%8C/" target="_blank" rel="noopener">참고</a>) <strong>2. 개발 언어에 종속적이다.</strong> 상황에 맞게 기술을 유연하게 적용하지 못합니다. Java + Spring으로 구현이 되어있다면, 선택의 여지없이 Java + Spring으로 구현을 해야 합니다.   <strong>3. 선택적으로 확장할 수 없다.</strong> 이벤트 서비스와 주문 서비스의 사용률이 90 : 10이더라도, 원하는 서비스만 확장할 수 없고, 프로젝트 하나를 통째로 확장해야 합니다. <strong>4. 하나의 서비스가 모든 서비스에 영향을 준다.</strong> 하나의 서비스에 문제가 생기면 Monolithic은 구조상 모든 서비스에 영향을 줄 수밖에 없습니다. 이벤트 서비스에 트래픽이 몰려 해당 서버가 죽게 된다고 가정을 해보겠습니다. Monolithic에서는 하나의 서버에 모든 서비스가 있기 때문에 하나의 서비스의 트래픽 폭주로 인해 다른 서비스도 마비되는 상황이 옵니다. 이것 외에도 많은 분들이 서비스가 커져 감에 따라 Monolithic구조의 불편함을 많이 경험하셨을 거라 생각이 듭니다. 2편에서 MSA를 소개하고 위의 이슈를 어떻게 해결하는지 생각해보겠습니다. 참고</p><ul><li><a href="http://www.aladin.co.kr/shop/wproduct.aspx?ItemId=113808876" target="_blank" rel="noopener">http://www.aladin.co.kr/shop/wproduct.aspx?ItemId=113808876</a></li></ul>]]></content>
      
      
      <categories>
          
          <category> 미분류 </category>
          
      </categories>
      
      
    </entry>
    
    <entry>
      <title>2018 세미나 - Server에서 만남을 추구하면 안되는 걸까</title>
      <link href="/2018/04/23/server-ec-97-90-ec-84-9c-eb-a7-8c-eb-82-a8-ec-9d-84-ec-b6-94-ea-b5-ac-ed-95-98-eb-a9-b4-ec-95-88-eb-90-98-eb-8a-94-ea-b1-b8-ea-b9-8c/"/>
      <url>/2018/04/23/server-ec-97-90-ec-84-9c-eb-a7-8c-eb-82-a8-ec-9d-84-ec-b6-94-ea-b5-ac-ed-95-98-eb-a9-b4-ec-95-88-eb-90-98-eb-8a-94-ea-b1-b8-ea-b9-8c/</url>
      
        <content type="html"><![CDATA[<p>강진우님의 리눅스 커널 이야기를 읽고 직접 실습을 하며 정리한 내용 입니다.</p><h1 id="도입"><a href="#도입" class="headerlink" title="도입"></a>도입</h1><p>사람과 사람사이 예의가 정말 중요 합니다. 서버에서 동작하는 서비스들 한테도 마찬가지인데요. 이 글에서는서버에서 돌아가는 서비스들의 관계와 사람의 관계를 비교해 가면서 설명 하겠습니다.</p><p><img src="https://ahea.files.wordpress.com/2018/04/null.png" alt=""></p><h1 id="1차-웹서비스"><a href="#1차-웹서비스" class="headerlink" title="1차 웹서비스"></a>1차 웹서비스</h1><p><img src="https://ahea.files.wordpress.com/2018/04/null1.png" alt=""> 예제에서 쓰인 웹 서비스는 파이썬 웹 프레임워크인 Flask를 썻으며 DB로는 Key/Value store인 redis를 사용 하였습니다.</p><ol><li><a href="http://localhost:5000/test/1" target="_blank" rel="noopener">http://localhost:5000/test/1</a> 접속</li><li>Flask에서 Redis에 접속하여 Set(1,155030303)를 실행(redis에 데이터 주입)</li><li>Flask에서 Redis에 Get(1)을 하여 데이터 가져오기</li><li>사용자에게 전달</li></ol><p>해당 서비스의 플로우는 총 4단계로 구성 되며 이 예제를 가지고 사용자에게 서비스 가능한 웹서비스를 튜닝 하겠습니다. 사과를 구입할 경우엔 이런식의 플로우로 흘러간다고 예를 들겠습니다. <img src="https://ahea.files.wordpress.com/2018/04/null2.png" alt=""> Flask와 Redis의 사이도 마찬가지인데요</p><p><img src="https://ahea.files.wordpress.com/2018/04/null3.png" alt=""></p><p>위의 그림과 같이 3way-handshake 후에 데이터셋팅을 하고 데이터를 가져오며 4way-handshake를 통해 연결을 끊습니다. 만약에 이작업을 1000명 혹은 10000명이 요청할 경우 <img src="https://ahea.files.wordpress.com/2018/04/null4.png" alt=""> 2가지 문제점이 발생하게 됩니다.</p><ol><li>TCP 연결과 종료에 대한 오버헤드</li><li>local port에 대한 고갈</li></ol><h2 id="여기서-잠깐-local-port란"><a href="#여기서-잠깐-local-port란" class="headerlink" title="여기서 잠깐!!! local port란?"></a>여기서 잠깐!!! local port란?</h2><p><img src="https://ahea.files.wordpress.com/2018/04/2018-ec84b8ebafb8eb8298-serverec9790ec849c-eba78ceb82a8ec9d84-ecb694eab5aced9598eba9b4-ec9588eb9098eb8a94-eab1b8eab98c-1.png" alt="2018 세미나 - Server에서 만남을 추구하면 안되는 걸까 (1)"> <img src="https://ahea.files.wordpress.com/2018/04/null5.png" alt=""> Client가 TCP 소켓 연결시 필요한 port, OS에서 정의 해놓은 local port 범위 안에서 할당 보통 http Request를 날리거나 다른 TCP연결을 할시에 OS에서 ‘IP주소:로컬포트’를 가지고 통신을 하게 됨</p><h2 id="문제점-2가지"><a href="#문제점-2가지" class="headerlink" title="문제점 2가지"></a>문제점 2가지</h2><h3 id="TCP-통신-오버헤드"><a href="#TCP-통신-오버헤드" class="headerlink" title="TCP 통신 오버헤드"></a>TCP 통신 오버헤드</h3><p><img src="https://ahea.files.wordpress.com/2018/04/null6.png" alt=""> 3way-handshake와 4way-handshake를 1000번 10000번 하게 되면 그만큼의 네트워크 자원 낭비가 되기 때문에 계속 연결 되어 있는 상태여야 합니다. <img src="https://ahea.files.wordpress.com/2018/04/2018-ec84b8ebafb8eb8298-serverec9790ec849c-eba78ceb82a8ec9d84-ecb694eab5aced9598eba9b4-ec9588eb9098eb8a94-eab1b8eab98c-9.png" alt="2018 세미나 - Server에서 만남을 추구하면 안되는 걸까 (9)"> 아까의 사과 구매 프로세스를 대입해 보면 사과 1000개를 구매 할 때에도 똑같이 1000번을 인사해야 하는 불상사가 생깁니다.</p><h3 id="local-port-고갈의-문제"><a href="#local-port-고갈의-문제" class="headerlink" title="local port 고갈의 문제"></a>local port 고갈의 문제</h3><p><img src="https://ahea.files.wordpress.com/2018/04/null7.png" alt=""> Flask에서 Client가 되므로 지속적으로 local_port를 만들어 내어 나중엔 고갈이 되어 버리는 현상까지 오게 됩니다. 그리고 다시 사용할시엔 timewait지속 시간이 60초 이므로 60초가 지나야 다시 사용 가능 합니다. <img src="https://ahea.files.wordpress.com/2018/04/2018-ec84b8ebafb8eb8298-serverec9790ec849c-eba78ceb82a8ec9d84-ecb694eab5aced9598eba9b4-ec9588eb9098eb8a94-eab1b8eab98c.png" alt="2018 세미나 - Server에서 만남을 추구하면 안되는 걸까"> netstat 명령어를 통해 현재 OS의 소켓 상태를 확인 할수 있으며 Flask가 local_port를 무지막지하게 사용한 모습을 보실수 있습니다. <img src="https://ahea.files.wordpress.com/2018/04/null5.png" alt=""> 우분투에서 할당 해 줄수 있는 포트를 ‘sysctl -a | grep local_port’ 명령어로 확인 할수 있습니다. 위의 문제점을 해결할 방법도 2가지가 됩니다.</p><ol><li>net.itv4.tcp_tw_reuse 활성화</li><li>Connection Pool</li></ol><h2 id="해결법-2가지"><a href="#해결법-2가지" class="headerlink" title="해결법 2가지"></a>해결법 2가지</h2><h3 id="net-ipv4-tcp-tw-reuse-활성화"><a href="#net-ipv4-tcp-tw-reuse-활성화" class="headerlink" title="net.ipv4.tcp_tw_reuse 활성화"></a>net.ipv4.tcp_tw_reuse 활성화</h3><p><img src="https://ahea.files.wordpress.com/2018/04/null8.png" alt=""> ‘sysctl -a | grep reuse’명령어를 통해 확인 할수 있으며 0이면 비활성 1이면 활성화 입니다. ‘sysctl -w net.ipv4.tcp_tw_reuse=1’명령어를 입력시 활성화 되며 이 기능은 패킷 소실의 위험이 있습니다. 지금과 같은 형태에서는 비추천 하지만 다른서버에 접속하는 Cilent용 서버일 경우에는 필요 할 수도 있습니다.</p><h3 id="Connection-Pool"><a href="#Connection-Pool" class="headerlink" title="Connection Pool"></a>Connection Pool</h3><p><img src="https://ahea.files.wordpress.com/2018/04/null9.png" alt=""> 다른 해결 방법인 Connection Pool을 만들어 사용 하는 것입니다. 미리 Pool을 만들어 놓고 사용자들이 http Request를 사용시엔 <img src="https://ahea.files.wordpress.com/2018/04/null10.png" alt=""> 이런 식으로 3way-handshake와 4way-handshake가 사라지기 때문에 TCP 맺고 끊음에 대한 오버헤드가 사라지게 됩니다. <img src="https://ahea.files.wordpress.com/2018/04/null11.png" alt=""> 그리고 계속 연결 상태 이므로 로컬 포트도 고정적으로 사용하게 되어서 고갈을 방지 할 수 있습니다. <img src="https://ahea.files.wordpress.com/2018/04/2018-ec84b8ebafb8eb8298-serverec9790ec849c-eba78ceb82a8ec9d84-ecb694eab5aced9598eba9b4-ec9588eb9098eb8a94-eab1b8eab98c-10.png" alt="2018 세미나 - Server에서 만남을 추구하면 안되는 걸까 (10)"> 사과 구매를 할때에도 인사를 한번만 할수 있으므로 인사(TCP 연결과 종료)할 수 있으므로 오버헤드를 감소 할수 있습니다.</p><h1 id="2차-웹서비스-Nginx를-추가-해보자"><a href="#2차-웹서비스-Nginx를-추가-해보자" class="headerlink" title="2차 웹서비스 Nginx를 추가 해보자"></a>2차 웹서비스 Nginx를 추가 해보자</h1><p>실질적으로 외부에 서비스하는 웹서비스들은 대부분 앞에 Web Server를 두게 되는데 그이유는 크게 Virtual Host, resource cache, Route등의 이유가 있어 약간의 지연이 있어도 3tier(WebServer-App-DB)로 구성을 하게 됩니다. <img src="https://ahea.files.wordpress.com/2018/04/null12.png" alt=""> 그런데 바로 추가시엔 위와 동일한 현상이 발생하게 됩니다. <img src="https://ahea.files.wordpress.com/2018/04/2018-ec84b8ebafb8eb8298-serverec9790ec849c-eba78ceb82a8ec9d84-ecb694eab5aced9598eba9b4-ec9588eb9098eb8a94-eab1b8eab98c-2.png" alt="2018 세미나 - Server에서 만남을 추구하면 안되는 걸까 (2)"> 다시 나타난 2가지 문제점</p><ol><li>TCP 연결과 종료에 대한 오버헤드</li><li>local port에 대한 고갈</li></ol><p><img src="https://ahea.files.wordpress.com/2018/04/2018-ec84b8ebafb8eb8298-serverec9790ec849c-eba78ceb82a8ec9d84-ecb694eab5aced9598eba9b4-ec9588eb9098eb8a94-eab1b8eab98c-3.png" alt="2018 세미나 - Server에서 만남을 추구하면 안되는 걸까 (3)"> <img src="https://ahea.files.wordpress.com/2018/04/null13.png" alt=""> Nginx가 Cilent이며 Flask가 Server인 입장이 되어 위와 동일한 현상이 발생하게 됩니다. 이 문제점도 동일하게 해결법이 2가지가 있습니다.</p><ol><li>net.ipv4.tcp_tw_reuse 활성화</li><li>Keepalive Connections</li></ol><h2 id="Keepalive-Connections-추가"><a href="#Keepalive-Connections-추가" class="headerlink" title="Keepalive Connections 추가"></a>Keepalive Connections 추가</h2><p><img src="https://ahea.files.wordpress.com/2018/04/2018-ec84b8ebafb8eb8298-serverec9790ec849c-eba78ceb82a8ec9d84-ecb694eab5aced9598eba9b4-ec9588eb9098eb8a94-eab1b8eab98c-4.png" alt="2018 세미나 - Server에서 만남을 추구하면 안되는 걸까 (4)"> nginx 설정에서 keepliave만 추가 해주면 됩니다. 자세한 설정은 기본 예제도 많으므로 nginx example을 참조해서 keepalive만 추가 해 줍시다. <img src="https://ahea.files.wordpress.com/2018/04/null14.png" alt=""> 위와 같은 구성도가 되며 Nginx에서 Keepalive Connections를 만들어 관리하게 됩니다. 참고로 time_out 값도 줄수 있어 한번 연결 후에는 몇초 후에 Keepalive를 없앨지 정할 수 있습니다. keepalive를 추가 할때와 안할때의 플로우는 아래와 같습니다. <img src="https://ahea.files.wordpress.com/2018/04/2018-ec84b8ebafb8eb8298-serverec9790ec849c-eba78ceb82a8ec9d84-ecb694eab5aced9598eba9b4-ec9588eb9098eb8a94-eab1b8eab98c-5.png" alt="2018 세미나 - Server에서 만남을 추구하면 안되는 걸까 (5)"> <img src="https://ahea.files.wordpress.com/2018/04/2018-ec84b8ebafb8eb8298-serverec9790ec849c-eba78ceb82a8ec9d84-ecb694eab5aced9598eba9b4-ec9588eb9098eb8a94-eab1b8eab98c-6.png" alt="2018 세미나 - Server에서 만남을 추구하면 안되는 걸까 (6)"> 보통 한번 http연결시 6~8번의 요청을 하게 된다고 하여 keepalive로 TCP 연결과 종료에 대한 오버헤드를 줄일 수 있습니다. Keepalive 설정 전후의 테스트 결과 입니다. 스트레스 테스트 툴은 <a href="https://www.joedog.org/siege-home/" target="_blank" rel="noopener">siege</a>를 사용 하였습니다. <img src="https://ahea.files.wordpress.com/2018/04/2018-ec84b8ebafb8eb8298-serverec9790ec849c-eba78ceb82a8ec9d84-ecb694eab5aced9598eba9b4-ec9588eb9098eb8a94-eab1b8eab98c-7.png" alt="2018 세미나 - Server에서 만남을 추구하면 안되는 걸까 (7)"> TPS가 200이나 차이가 났습니다. <img src="https://ahea.files.wordpress.com/2018/04/2018-ec84b8ebafb8eb8298-serverec9790ec849c-eba78ceb82a8ec9d84-ecb694eab5aced9598eba9b4-ec9588eb9098eb8a94-eab1b8eab98c-8.png" alt="2018 세미나 - Server에서 만남을 추구하면 안되는 걸까 (8)"> netstat를 통해 테스트 후의 time_wait소켓을 살펴보니 8300개의 차이가 발생 하였습니다.</p><h1 id="최종-정리"><a href="#최종-정리" class="headerlink" title="최종 정리"></a>최종 정리</h1><ul><li>서비스 대 서비스로 연결시에는 Connection Pool을 고려해 보자!</li><li>Nginx 사용시 Keepalive사용을 고려해 보자!</li><li>time_wait소켓이 많다는건 나쁘진 않지만 지나치게 많을 경우 살펴 보자!</li></ul><p>출처</p><ul><li>책 ‘리눅스 커널 이야기’ 강진우 지음</li><li>nginx keepalive - <a href="https://www.nginx.com/blog/http-keepalives-and-web-performance/" target="_blank" rel="noopener">https://www.nginx.com/blog/http-keepalives-and-web-performance/</a></li><li>TCP Flags - <a href="http://www.dbguide.net/knowledge.db?cmd=view&amp;boardUid=183652&amp;boardConfigUid=21" target="_blank" rel="noopener">http://www.dbguide.net/knowledge.db?cmd=view&amp;boardUid=183652&amp;boardConfigUid=21</a></li></ul>]]></content>
      
      
      <categories>
          
          <category> 공개스터디 </category>
          
      </categories>
      
      
    </entry>
    
    <entry>
      <title>2018 세미나 - Server에서 만남을 추구하면 안되는 걸까(슬라이드)</title>
      <link href="/2018/04/16/2018-ec-84-b8-eb-af-b8-eb-82-98-server-ec-97-90-ec-84-9c-eb-a7-8c-eb-82-a8-ec-9d-84-ec-b6-94-ea-b5-ac-ed-95-98-eb-a9-b4-ec-95-88-eb-90-98-eb-8a-94-ea-b1-b8-ea-b9-8c/"/>
      <url>/2018/04/16/2018-ec-84-b8-eb-af-b8-eb-82-98-server-ec-97-90-ec-84-9c-eb-a7-8c-eb-82-a8-ec-9d-84-ec-b6-94-ea-b5-ac-ed-95-98-eb-a9-b4-ec-95-88-eb-90-98-eb-8a-94-ea-b1-b8-ea-b9-8c/</url>
      
        <content type="html"><![CDATA[<p>일단은 슬라이드 자료만 공유 하겠습니다. 추 후 글 작성을 통해 내용을 보충 하도록 하겠습니다. <a href="https://docs.google.com/presentation/d/1KTl5abLuOZ0uWNAKlmyiQpIIRD-37utcNjVwGU-HtMw/edit?usp=sharing" target="_blank" rel="noopener">https://docs.google.com/presentation/d/1KTl5abLuOZ0uWNAKlmyiQpIIRD-37utcNjVwGU-HtMw/edit?usp=sharing</a></p>]]></content>
      
      
      <categories>
          
          <category> 미분류 </category>
          
      </categories>
      
      
    </entry>
    
    <entry>
      <title>2017 해커톤 - 랜덤 데이터 생성</title>
      <link href="/2017/11/24/2017-ed-95-b4-ec-bb-a4-ed-86-a4-eb-9e-9c-eb-8d-a4-eb-8d-b0-ec-9d-b4-ed-84-b0-ec-83-9d-ec-84-b1/"/>
      <url>/2017/11/24/2017-ed-95-b4-ec-bb-a4-ed-86-a4-eb-9e-9c-eb-8d-a4-eb-8d-b0-ec-9d-b4-ed-84-b0-ec-83-9d-ec-84-b1/</url>
      
        <content type="html"><![CDATA[<p>안녕하세요 아해팀 김종인 입니다. 이번 포스팅에서는 더미 데이터 생성에서 랜덤 데이터 생성을 어떻게 진행해서 목표에 도달 했는지에 대해서 말씀드리고 싶어 작성 하게 되었습니다. 저희는 데이터 속성에 대해서 생각을 해 보았습니다. 그러면서 <strong>확장성과 정확성</strong>을 잡기 위한 방법을 생각해보기로 했죠. 그와 중에 흔히 사용하던 정규 표현식에 대해서 떠올려 봤습니다. 다들 써보셔서 아시겠지만 정규표현식은 <strong>원하는 조건</strong>을 작성하면 입력 데이터에 대한 검색과 치환 기능을 하게 됩니다. 다른 개발자들도 많이 사용해본 <strong>정규표현식</strong>을 이용해서 랜덤데이터를 생성 하면 <strong>학습비용을 줄일수</strong> 있으므로 괜찮을 거라 생각 되어 찾아보기로 하였습니다. 검색을 해서 찾은 <a href="https://github.com/bluezio/xeger" target="_blank" rel="noopener">xeger</a>이라는 라이브러리를 찾게 되었고 예제와 설명을 보니 저희가 원하던 랜덤 데이터 생성을 해주는 프로젝트 였습니다. String regex = “[ab]{4,6}c”; Xeger generator = new Xeger(regex); String result = generator.generate(); assert result.matches(regex); 위의 예제를 보시면 “[ab]{4,6}c” 정규식에 대한 랜덤 데이터를 생성하게 됩니다.  이 정규식을 해석 하자면 a와b만으로 4~6자리의 데이터와 맨마지막에 c를 붙이라는 의미 입니다. 해당 정규식조건을 xeger에서 제공하는 객체에 넣어 주고 generate함수를 호출하면 조건에 맞는 데이터를 랜덤으로 생성하게 됩니다. 위의 xeger을 활용해서</p><ul><li>전화번호 정규식</li><li>이름 정규식</li><li>주민등록번호 정규식</li><li>이메일 정규식</li></ul><p>등 원하는 정규식을 만들면 조건에 맞는 랜덤 데이터를 생성 함으로 써 확장성과 정확성 거기에 덤으로 학습비용 까지 줄이게 되어 되었습니다.</p>]]></content>
      
      
      <categories>
          
          <category> 미분류 </category>
          
      </categories>
      
      
    </entry>
    
    <entry>
      <title>2017 해커톤 – Front</title>
      <link href="/2017/11/22/2017-ed-95-b4-ec-bb-a4-ed-86-a4-front/"/>
      <url>/2017/11/22/2017-ed-95-b4-ec-bb-a4-ed-86-a4-front/</url>
      
        <content type="html"><![CDATA[<p>안녕하세요 아해 팀 new멤버 김민수입니다. 아해 팀에 들어와서 처음으로 한 활동이 해커톤이었고, 생애 첫 해커톤인 까닭에 긴장과 설레는 마음을 가지고 임했었네요. 이번 해커톤을 하기 전 기대했던 것은 관심 있던 기술들을 써보고, 다른 사람들의 코드를 봄으로서 안목을 넓히자는 것이었습니다. 저는 백엔드의 <a href="https://ahea.wordpress.com/2017/10/12/2017-%ED%95%B4%EC%BB%A4%ED%86%A4-1%EC%9E%A5-intro-export/" target="_blank" rel="noopener">Export</a> 부분과 프론트엔드를 맡아서 프로젝트를 진행했습니다. 프론트엔드는 Angular4를 사용했습니다. 지금부터 프론트엔드 작업내용과 이슈를 공유하겠습니다. 아래는 저희 프로젝트 화면입니다. <img src="https://ahea.files.wordpress.com/2017/11/eca084ecb2b4ed9994eba9b4.png" alt="전체화면"> 보시는 바와 같이 로직은 Field Name과 Type을 필요한 만큼 동적으로 생성하여 값을 넣고, 원하는 추출 타입과 수를 정한 뒤 Preview를 클릭하면 서버에서 데이터를 가져와 보여줍니다. 먼저, Angular는 <a href="https://ko.wikipedia.org/wiki/%EC%BB%B4%ED%8F%AC%EB%84%8C%ED%8A%B8_%EA%B8%B0%EB%B0%98_%EC%86%8C%ED%94%84%ED%8A%B8%EC%9B%A8%EC%96%B4_%EA%B3%B5%ED%95%99" target="_blank" rel="noopener">Component-Based Development</a>(이하 CBD)이기 때문에 Component로 나눠서 생각을 해보겠습니다. <img src="https://ahea.files.wordpress.com/2017/11/component.png" alt="component"> 총 4개의 Component로 구성되어있습니다.</p><ul><li>main : 전체와 Header를 나타내고 있고, 최상위 Component입니다.</li><li>form : Field Name, Type, rows, exportType의 값을 서버로 전송하는 역할을 합니다.</li><li>fields-wrapper : field들을 동적으로 생성 및 삭제하는 역할을 합니다.</li><li>field : Field Name과 Type 값을 가지고 있습니다. </li></ul><p>제가 맡은 Field와 이것을 감싸고 있는 Wrapper에 대해 소개 드리겠습니다. <img src="https://ahea.files.wordpress.com/2017/11/wrapper.png" alt="wrapper"> 로직에서도 Component의 구조가 명확히 나타나네요. wrapper 안의 field의 구조로 말이죠. field를 생성, 삭제하는 로직을 설명하겠습니다. <ng-container>태그를 보시면 “rows”라는 Array를 루프 돌면서 field를 생성하는 역할을 하고 있습니다. 디폴트로 rows의 개수가 1개이기 때문에 최초에는 1개의 field만 생성됩니다. field를 생성(Add another field를 클릭) 하기 위해서는 rows.push()를 통해 Array에 값만 하나 넣어주면 됩니다. 삭제하기 위해서는 Array에서 빼주기만 하면 되겠죠? 간단한 로직이지만 이것을 통하여 CBD의 특성을 이해하게 되었고, CBD 기반 Angular의 강력함을 알았습니다. 만약, jQuery로 짰을 경우 HTML을 스크립트에서 만들고, 해당하는 selector를 찾아서 append(),  remove() 하고, 값이 존재하면 상황에 맞게 핸들링을 해줘야 합니다. 그러나 CBD를 활용하여 Component만 설계해 놓으면 추가, 삭제는 Array의 push(), splice()로 값이 필요할 경우는 [ ]를 통한 바인딩으로 간단하게 처리할 수 있습니다. 그러던 중 잘 되어가던 프로젝트에 갑자기 기술적인 큰 이슈가 생겼습니다.  자식 컴포넌트에서 부모 컴포넌트로 데이터 전달하는 부분인데요. 4개의 Component 모두가 부모/자식 관계를 유지하고 있었고, 서버에 값들을 전달하기 위해서는 데이터를 부모 Component인 form으로 전달을 해줘야 합니다. 그러나 해당 부분에 대해 잘 알지도 못하고, 조급한 탓에 약 밤 11시부터 새벽 3시까지 고생을 하며  구현을 했습니다. 구현을 하긴 했지만  [(ngModel)] 양방향 바인딩과 @Input을 이용하여 억지로 구현을 했고, 급기야 잘 나눠진 부모/자식 Component를 합치기까지 했습니다. 최근 Angular를 할 기회가 생겨 위의 문제에 대해 해결방안을 찾아보니 <a href="https://angular.io/api/core/EventEmitter" target="_blank" rel="noopener">EventEmitter</a>를 이용하면 간단하게 해결할 수 있는 문제라는 것을 알게 되었습니다. 이번 해커톤을 통해 많은 것을 배우고 느꼈는데요.</ng-container></p><ol><li>조급하면 시선이 좁아지니, 여유를 가져야 한다.</li><li>알지 못하거나, 새로운 기술을 사용함으로써 다양한 안목이 생길 수 있다.</li><li>무작정 코딩하기보다는 클래스의 역할과 책임을 정의하는 설계를 통해  OOP를 잘 활용해야 한다.</li></ol><p>이런 좋은 기회와 경험을 준 아해 팀원 분들께 감사의 말씀을 드립니다.</p>]]></content>
      
      
      <categories>
          
          <category> 미분류 </category>
          
      </categories>
      
      
    </entry>
    
    <entry>
      <title>2017 해커톤 -  더미데이터 생성</title>
      <link href="/2017/11/05/2017-ed-95-b4-ec-bb-a4-ed-86-a4-eb-8d-94-eb-af-b8-eb-8d-b0-ec-9d-b4-ed-84-b0-ec-83-9d-ec-84-b1/"/>
      <url>/2017/11/05/2017-ed-95-b4-ec-bb-a4-ed-86-a4-eb-8d-94-eb-af-b8-eb-8d-b0-ec-9d-b4-ed-84-b0-ec-83-9d-ec-84-b1/</url>
      
        <content type="html"><![CDATA[<p>안녕하세요 아해팀 최경운입니다. 이번 해커톤을 진행하면서 느낀점과 경험을 솔직하게 공유하고자 합니다. 저는 Core쪽에서 더미데이터를 생성하는 부분의 설계를 맡았는데요. 프로젝트의 궁극적 목적은 ‘이름, 날짜, 성별, 나이, 전화번호를 한국식으로 생성해줘야 한다’ 였습니다. 저희가 해커톤 목표로 했었던 가장 중요한 비지니스 로직을 가지고 있는 부분입니다. 샘플데이터를 만들기 전에 저희는 샘플데이터를 생성 하는 부분을 크게 4가지로 나누었습니다.</p><ol><li>랜덤으로 생성.</li><li>주어진 값내에서 생성.</li><li>db에 있는 값을 생성.</li><li>날짜를 생성.</li></ol><p>1. 랜덤으로 생성되는것은 어떤값을 랜덤으로 생성합니다.</p><p>2. 주어진 값내에서 생성은 예를 들어 select 박스내에서 남,여를 선택하는 부분이 있을때 이 선택지 안에서 샘플데이터를 생성하는 부분입니다.</p><p>3. db에 있는 값을 생성하는 부분은 샘플데이터를 미리 db에 넣어놓고 db에서 값을 가져오는 부분입니다.</p><p>4. 날짜를 생성하는 부분은 말 그대로 날짜를 생성하는 부분 입니다. 저희는 초기 프로토타입에서는 이 4가지 방법을 사용하면 모든 데이터를 생성 할 수 있다고 생각했습니다. 이름을 생성하는 부분은 의미없이 랜덤 한 값을 생성 하면 (ex&gt;핧닥앝) 그 데이터는 전혀 의미 없고 샘플데이터로 가치가 없다고 생각해서 랜덤으로 생성하기 보다는 db에 있는 값을 생성하는 쪽으로 결정했습니다. 시간이 많았더라면 형태소 결합으로 그럴듯한 이름을 생성 할 수 있었겟지만 시간이 부족한 해커톤이기 때문에 이 방법을 선택 했습니다. 전화번호를 생성해 줄때 임의의 숫자로 랜덤으로 생성하는것은 단순 010-XXXX-XXXX로 만들면 되나 저희는 여기서 전화번호 생성시 조건을 추가 할 수 있게 설계했습니다. 예를 들면 특정 010 다음에 나오는 숫자는 1234로 고정한다. 라고 조건을 줄 수 있도록 했습니다. 이런 조건들은 나중에 지역번호나 어떤 특정 테스트 데이터를 추가 할때 사용자가 편하게 쓸 수 있는 부분이라고 생각했습니다. 또한 이 조건들은 동적으로 바뀔 수 있는 부분인데 만약 어떤 조건이 추가 될때 마다 if문을 추가 하게 된다면 어떤 조건을 추가 할때 마다 소스 수정이 있어야 하므로 이 부분을 유동적으로 해결하기 위해 많은 고민을 했습니다. 저희는 정규표현식을 사용해서 조건을 검사 할 수 있도록 했는데, 정규표현식 없이 생성한다면 임의의 값으로 생성이 되고 사용자가 어떤 조건을 넣고 싶다면 이 정규표현식을 통해서 원하는 조건대로 샘플데이터를 생성 할 수 있습니다. 이때 Xeger이라는 것을 사용했는데 자세한 내용은 다음 링크에 잘 설명 되어 있습니다. <a href="https://ahea.wordpress.com/2017/08/15/2017%ED%95%B4%EC%BB%A4%ED%86%A4xeger%EB%9D%BC%EC%9D%B4%EB%B8%8C%EB%9F%AC%EB%A6%AC%EC%9D%98-%EC%A0%95%EA%B7%9C%ED%91%9C%ED%98%84%EC%8B%9D%EC%97%90-%EB%A7%9E%EC%B6%98-%EB%9E%A8%EB%8D%A4-%EB%8D%B0/" target="_blank" rel="noopener">https://ahea.wordpress.com/2017/08/15/2017해커톤xeger라이브러리의-정규표현식에-맞춘-램덤-데/</a> 날짜를 표현하는 부분도 사용자마다 원하는 formatting이 다르다고 생각해서 사용자가 formatting 형식을 입력한다면 그 형식에 맞게 나타나도록 설계 했습니다. dummy를 생성하는데 random이 아닌 secureRandom을 사용했는데 secureRandom은 Random을 상속 받는 클래스로 strong random number generator을 하는데 단순 더미인데 괜히 썻나 싶기도 하고 모르는걸 한번 써봤다라는거에 의의를 뒀습니다. Build 쪽은 이렇게 완성이 되었는데, export 에 데이터를 어떻게 넘겨주냐 이게 문제가 되었습니다. 저는 vo로 넘겨준다고 했고, export 쪽에서는 map으로 받고 싶어했습니다. map으로 받고 싶어 하는 담당자는 우리가 하나의 서비스를 만드는거였지만 모듈을 나눴고, 모듈간에 있어서 vo라는게 생기면서 결합도가 생기는 부분 때문에 map으로 데이터를 전달 받고 싶어 했습니다. 제 의견은 어차피 하나의 서비스이고 vo로 하면 map으로 했을때 보다 코드가 짧아지고 map으로 다시 감싸고 풀고 이런 번거로운 작업이 없기 때문에 굳이 map으로 할 필요가 없다가 제 생각이었습니다. 결국은 제 의견을 받아들여서 vo로 쓰게 되었는데, 결정되기 전까지 격렬한 토론을 했습니다. 해커톤이 끝난 후에 다음 링크를 봤는데 <a href="https://www.slideshare.net/JavaCommunityOrg/t3s1-vo" target="_blank" rel="noopener">https://www.slideshare.net/JavaCommunityOrg/t3s1-vo</a> 다시 돌아간다고 해도 map은 먼가 쓰기 거북한 느낌입니다. 3일 동안 해커톤하면서 목이 아플정도로 토론을 많이 했는데 시간이 많이 지나서 기억 나는 부분이 몇가지 없네요.. 마지막으로 새벽에 거의 완성되서 시연하는 모습을 영상으로 올립니다.  <a href="https://www.youtube.com/watch?v=oKrzGK2DnYw&amp;feature=youtu.be" target="_blank" rel="noopener">https://www.youtube.com/watch?v=oKrzGK2DnYw&amp;feature=youtu.be</a></p>]]></content>
      
      
      <categories>
          
          <category> 해커톤 </category>
          
      </categories>
      
      
    </entry>
    
    <entry>
      <title>2017 해커톤 - 1장 intro, export</title>
      <link href="/2017/10/12/2017-ed-95-b4-ec-bb-a4-ed-86-a4-1-ec-9e-a5-intro-export/"/>
      <url>/2017/10/12/2017-ed-95-b4-ec-bb-a4-ed-86-a4-1-ec-9e-a5-intro-export/</url>
      
        <content type="html"><![CDATA[<p>안녕하세요 아해팀 노성현입니다</p><p>이번 포스팅에서는 아해팀의 가장 중요한 행사인 해커톤을 지난 8월에 진행하였기에 내용을 공유하고자 합니다</p><p>해당 포스팅은 기술문서는 아니기 때문에 편하고 가볍게 작성되었습니다</p><p>뭘 배우시려면 다른 기술 포스팅을 보시길~ 권장합니다</p><p>매년 아해팀은 아이디어를 하나 선정하여 하루이틀동안 모여 소프트웨어를 통해 해결해보는 해커톤 행사를 진행하였습니다</p><p>올해도 어김없이 해커톤을 진행하였는데요</p><p>저희의 처음 계획은 3월에 진행했던 아해팀의 1차 공개세미나와 7월에 진행하려고 했던 2차 공개세미나에서 발표한 기술들과 평소 관심 있어하는 여러가지 기술들을 조합하여 해커톤에서 사용하려고 했습니다.</p><p>나름 성공적이였다고 기억되는 1차 세미나에서는 Reactive, Spring Batch, Spring과 Reflection과 같은 기술들을 공유했었습니다</p><p>포스팅 작성자인 제가 발표했던 Reactive같은 경우에는 얼마 뒤 토비님이 Spring Camp에서 발표할 예정이였었는데 의외로 나름 관심을 많이 가져주셨습니다 (감사합니다 ^^)</p><p>1차 세미나를 통해 팀에 가입해주신 분들도 생기고 2차 스터디 밑 세미나를 진행하였습니다.</p><p>잡혔던 주제를 보면 Spring이 올라가는 원리, 빈이 등록되는 원리같은 스프링 기본도 있었고요, 자바 가비지와 같은 나름 기본적이면서 어려운 것도 있었고, 하둡과 빅데이터를 설명해주는 세미나 등으로 해서 다양한 주제들이 있었습니다만~</p><p>발표 일주일 전까지 많은 분들이 신청을 해주시지 않아서 아쉽게 취소가 되버렸습니다</p><p>(후일담을 말씀드리면 취소 한 다음날부터 어떻게 신청해야 하냐는 문의 메일과 문자가 저에게 쏟아졌습니다… 그냥 할걸 그랬어요)</p><p>신청해주셨던 분들에게 문자와 메일로 사과를 드렸지만 다시한번 여기서 세미나 취소에 대해 사과 드리고요</p><p>(돈도 내셨는데… 죄송합니다)</p><p>다음에 팀의 행사가 잡힐경우 어떤 식으로든 꼭 초대를 하도록 하겠습니다</p><p>행사가 취소되여 신청자분들에게는 아쉬움이 남으셨겠지만</p><p>발표가 예정되어 있던 팀원들은 엄청난 긴장감에서 해방되며 몇주동안 발표준비에 쌓여있던 스트레스를 덜어내는 효과가 있었습니다</p><p>이때다 싶어서 얼마 지나지 않아 바로 해커톤 일정을 잡았고 (갑작스럽게 잡힌 해커톤 행사에 당황한 멤버들…)</p><p>해커톤 준비를 시작하게 되었습니다</p><p>가장 중요하게 결정해야 했던것은 해커톤에서 무엇을 만들지 ‘주제’였는데요</p><p>행아웃 회의를 통해 주제를 결정했습니다</p><p>저희 주제는 더미데이터 만들기 입니다</p><p>저같은 경우 개발하면서 테이블을 생성하면 예를 들면 회원 테이블을 생성하면 더미데이터를 넣고 싶은데 user1, user2/ 이름1, 이름2 이런식의 데이터를 넣어놓는게 싫었습니다</p><p>그래서 더미데이터를 10개면 19개의 sql문으로 만들어주던지, 또는 json이나 xml로 만들어주자는 것을 주제로 잡게 되었습니다</p><p>(사실 요 주제는 제가 냈는데 저는 사실 이것을 이용해서 뭐가 될지는 모르지만 ‘다른 어떤 주제’를 잡고 그곳에 ‘더미데이터를 넣어주눈것’ 두가지를 다 하자고 했다가 완강한 반대 때매 이것만 했다능…)</p><p>장소와 시간은 미리 정했는데요</p><p>장소는 작년과 같은 곳으로서 에어비엔비를 통해 예약했는데</p><p><a href="https://www.airbnb.co.kr/rooms/10581141" target="_blank" rel="noopener">https://www.airbnb.co.kr/rooms/10581141</a></p><p>작년에는 에어컨이 없어서 엄청 더웠는데 올해는 에어컨이 있어서 시원했어요</p><p><img src="/shard/s264/res/8927d138-fc56-4a88-b919-2fe61f98c642" alt=""><img src="https://www.evernote.com/shard/s264/res/8927d138-fc56-4a88-b919-2fe61f98c642" alt=""></p><p><img src="/shard/s264/res/31697b24-c285-4ff7-9521-ca0d83ae88e8" alt=""><img src="https://www.evernote.com/shard/s264/res/31697b24-c285-4ff7-9521-ca0d83ae88e8" alt=""></p><p><img src="/shard/s264/res/284d1613-309d-4a58-b81f-79379339b5a9" alt=""><img src="https://www.evernote.com/shard/s264/res/284d1613-309d-4a58-b81f-79379339b5a9" alt=""></p><p>화이트보드, 빔프로젝터, 넓은 책상, 엄청 많은 침대</p><p>올해 처음 해커톤에 참가하는 맴버들도 맘에 들어하신거 같죠~?</p><p>날짜는 8월 13,14,15 이렇게 2박 3일로 진행했는데요</p><p>작년에는 짧아서 힘들었는데 올해는 하루 더 했다고 후반에 약간 루즈해진 느낌도 있었습니다</p><p>올해는 좀 재미있게 해보려고 루미큐브같은 보드게임을 좀 들고가볼까 했는데 깜빡하고 안들고 갔네요</p><p>올해는 총 5명이 진행하게 되었는데요, 아쉽게 송호훈님께서 참석하지 못하셨습니다 ( 우리팀 아키텍트가 빠지게 되다니… 너무 아쉬웠습니다)</p><p>작년에 비해서 달라진게 있다면 개발자 수준도 올해 굉장히 높았고</p><p>해커톤을 몇번 해보면서 노련해졌다고 할까…. 미리 준비도 많이 했고요</p><p>개발환경이나 기본 프레임워크 세팅은 미리 준비하였고 그렇게 첫날이 시작되었습니다</p><p>첫날목표</p><p>기능 및 목표 정의</p><p>다시한번 아이디어를 말씀 드리면 더미데이터를 만들어준다 입니다</p><p>그렇다면 이번 해커톤은 얼마만큼의 기능을 넣을것인가를 토론했고</p><p>이름, 날짜, 성별, 나이 같은 회원데이터를 만들게 하자 라는 목표를 정의하게 되었습니다</p><p>Core개발</p><p>- Export    ‘더미데이터를 원하는 타입(query, JSon, xml)에 맞게 변형</p><p>- Builder    ‘더미데이터를 생성(이름, 날짜, 성별, 나이)</p><p>- Command    ‘명령</p><p><img src="/shard/s264/res/250e2ff3-5081-4c2c-916d-d324a2915be4" alt=""><img src="https://www.evernote.com/shard/s264/res/250e2ff3-5081-4c2c-916d-d324a2915be4" alt=""></p><p>모듈을 크게 저렇게 3개로 나누고 파트를 나눴는데요</p><p>Builder : 김영민, 김종인, 최경운</p><p>Export : 김민수, 노성현</p><p>저같은 경우에는 Export 파트로 가게 되었죠</p><p>Export파트에서 가장 먼저한것은 구조를 먼저 설계하는 것이였는데요</p><p>요구사항은 json,xml,query로 더미데이터를 만들어줘야 한다 였습니다</p><p>저는 여기에 조금더 붙여서 다른데이터 타입을 추가하는데에 있어 유연하게 설계해야 한다였습니다</p><p>그래서 저희는 다음과 같은 구조를 만들어봤는데요</p><p><img src="/shard/s264/res/6219f04d-0877-4988-b2e8-b06cb57dc536" alt=""><img src="https://www.evernote.com/shard/s264/res/6219f04d-0877-4988-b2e8-b06cb57dc536" alt=""></p><p>Exporter라는 최상위 인터페이스가 있고 데이터 타입에 맞게 상속받도록 구조를 만들었습니다</p><p>그리고 실제 데이터구현라이브러리에 따라 구현체를 구현할수 있도록 할수 있는 구조를 만들었는데요</p><p>이부분 진행하면서 사실 저는 android의 이미지 로드라이브러리로 유명했었던 volley의 구조를 참고 했는데요</p><p><img src="/shard/s264/res/a97ff39f-1cbe-4289-915e-30810deec776" alt=""><img src="https://www.evernote.com/shard/s264/res/a97ff39f-1cbe-4289-915e-30810deec776" alt=""></p><p>Volley의 Request의 경우 요청하려는 타입에 따라 하위 구현체를 만들어 낼수 있는데요, 요걸 참고해서 의견을 냈고 수용되어서 진행하게 되었죠 (안드로이드 개발 안하시더라도 volley의 아키텍쳐는 꼭 한번 보시길)</p><p>json의 경우 구현체를 gson, xml의 경우 Dom4J, Sql의 경우 SqlBuilder라는 라이브러리 구현체를 사용하여 구현하게 되었습니다</p><p>아해팀이 작성한 참고기술포스팅</p><p><a href="https://ahea.wordpress.com/2017/08/15/2017-%ED%95%B4%EC%BB%A4%ED%86%A4sqlbuilder%EB%A5%BC-%EC%9D%B4%EC%9A%A9%ED%95%98%EC%97%AC-sqlexport-%EA%B0%9C%EB%B0%9C/" target="_blank" rel="noopener">https://ahea.wordpress.com/2017/08/15/2017-%ED%95%B4%EC%BB%A4%ED%86%A4sqlbuilder%EB%A5%BC-%EC%9D%B4%EC%9A%A9%ED%95%98%EC%97%AC-sqlexport-%EA%B0%9C%EB%B0%9C/</a></p><p><a href="https://ahea.wordpress.com/2017/08/15/2017%ED%95%B4%EC%BB%A4%ED%86%A4-dom4j%EB%A5%BC-%EC%9D%B4%EC%9A%A9%ED%95%98%EC%97%AC-xml-export/" target="_blank" rel="noopener">https://ahea.wordpress.com/2017/08/15/2017%ED%95%B4%EC%BB%A4%ED%86%A4-dom4j%EB%A5%BC-%EC%9D%B4%EC%9A%A9%ED%95%98%EC%97%AC-xml-export/</a></p>]]></content>
      
      
      <categories>
          
          <category> 해커톤 </category>
          
      </categories>
      
      
    </entry>
    
    <entry>
      <title>[2017해커톤] 파라미터가 여러개를@RequestBody를 이용하여 받기</title>
      <link href="/2017/08/15/2017-ed-95-b4-ec-bb-a4-ed-86-a4-ed-8c-8c-eb-9d-bc-eb-af-b8-ed-84-b0-ea-b0-80-ec-97-ac-eb-9f-ac-ea-b0-9c-eb-a5-bcrequestbody-eb-a5-bc-ec-9d-b4-ec-9a-a9-ed-95-98-ec-97-ac-eb-b0-9b-ea-b8-b0/"/>
      <url>/2017/08/15/2017-ed-95-b4-ec-bb-a4-ed-86-a4-ed-8c-8c-eb-9d-bc-eb-af-b8-ed-84-b0-ea-b0-80-ec-97-ac-eb-9f-ac-ea-b0-9c-eb-a5-bcrequestbody-eb-a5-bc-ec-9d-b4-ec-9a-a9-ed-95-98-ec-97-ac-eb-b0-9b-ea-b8-b0/</url>
      
        <content type="html"><![CDATA[<p>이슈 : request에서 RequestBody 요청 받을 파라미터가 여러개.</p><p>@RequestBody - body에 있는 데이터를 읽는 부분.</p><p>The body of the request is passed through an <a href="https://docs.spring.io/spring-framework/docs/current/javadoc-api/org/springframework/http/converter/HttpMessageConverter.html" title="interface in org.springframework.http.converter" target="_blank" rel="noopener">HttpMessageConverter</a> to resolve the method argument depending on the content type of the request.</p><p>컨트롤러에서 파라미터 마다 requestBody를 써줬는데 requestbody는 하나 이상 쓸 수가 없음. 그래서 해결책은 VO를 하나 만들어서 그 안에 필요한 파라미터들을 집어 넣음.</p><p><img src="https://ahea.files.wordpress.com/2017/08/e18486e185aee1848ce185a6.jpeg" alt="무제.jpeg"></p><p>컨트롤러 테스트를 위해 json형식으로 넘겨줘야했는데, 내가 만든 객체에 맞는 json형식을 만드는데 어려웠음. 하나하나 만들고 실패하다가 방법을 찾은게 gson을 사용해서 객체를 넘기면 json형으로 나와서 테스트 객체를 만들고 그것을 gson.toJson을 사용해서 테스트 함.</p><p>나오는 형식대로 controller에서 테스틀하니 잘 들어가는것을 확인 함.</p><p>gson에 대한 간단한 설명은 A Java serialization/deserialization library to convert Java Objects into JSON and back.</p><p><a href="https://github.com/google/gson" target="_blank" rel="noopener">https://github.com/google/gson</a> 에 잘 나와 있다.</p>]]></content>
      
      
      <categories>
          
          <category> 해커톤 </category>
          
      </categories>
      
      
    </entry>
    
    <entry>
      <title>[2017 해커톤]SqlBuilder를 이용하여 SqlExport 개발</title>
      <link href="/2017/08/15/2017-ed-95-b4-ec-bb-a4-ed-86-a4sqlbuilder-eb-a5-bc-ec-9d-b4-ec-9a-a9-ed-95-98-ec-97-ac-sqlexport-ea-b0-9c-eb-b0-9c/"/>
      <url>/2017/08/15/2017-ed-95-b4-ec-bb-a4-ed-86-a4sqlbuilder-eb-a5-bc-ec-9d-b4-ec-9a-a9-ed-95-98-ec-97-ac-sqlexport-ea-b0-9c-eb-b0-9c/</url>
      
        <content type="html"><![CDATA[<p><img src="https://ahea.files.wordpress.com/2017/08/ecbaa1ecb2983.png" alt="캡처"> Map을 SQL로 변환하기 위해 SqlBuilder를 사용하였습니다. 1. 테이블이름을 파라미터로한 InsertQuery 생성자를 이용하여 객체를 생성합니다. 2. 반복문을 돌며 addCustomColumn(String, String) 이용하여 column과 value값을 넣어줍니다.</p><p> ex ) INSERT INTO table_name(column1) VALUES(value1), INSERT INTO table_name(column1, column2) VALUES(value1, value2), …</p><p>3. validate()는 쿼리의 열과 테이블이 실제로 의미가 있는지를 확인해줍니다. 참고문헌 - <a href="http://openhms.sourceforge.net/sqlbuilder/index.html" target="_blank" rel="noopener">http://openhms.sourceforge.net/sqlbuilder/index.html</a></p>]]></content>
      
      
      <categories>
          
          <category> 해커톤 </category>
          
      </categories>
      
      
    </entry>
    
    <entry>
      <title>[2017해커톤] Dom4J를 이용하여 Xml Export</title>
      <link href="/2017/08/15/2017-ed-95-b4-ec-bb-a4-ed-86-a4-dom4j-eb-a5-bc-ec-9d-b4-ec-9a-a9-ed-95-98-ec-97-ac-xml-export/"/>
      <url>/2017/08/15/2017-ed-95-b4-ec-bb-a4-ed-86-a4-dom4j-eb-a5-bc-ec-9d-b4-ec-9a-a9-ed-95-98-ec-97-ac-xml-export/</url>
      
        <content type="html"><![CDATA[<p>[해커톤]Dom4J를 이용하여 XML Export개발</p><pre><code> @Override public String export(Map&lt;String, Object&gt; data, Map option) {     String rootElement = (String) option.get(&quot;rootElement&quot;);     String recordElement = (String) option.get(&quot;recordElement&quot;);     Document document = DocumentHelper.createDocument();     Element root = document.addElement( rootElement );     Element element = root.addElement( recordElement );     data.keySet().forEach(s -&gt;</code></pre><p> element.addElement(s).addText((String) data.get(s)));</p><pre><code>     return document.asXML(); }</code></pre><p>@Override</p><pre><code> public String export(List&lt;Map&lt;String, Object&gt;&gt; datas, Map</code></pre><p> option) {</p><pre><code>     String rootElement = (String) option.get(&quot;rootElement&quot;);     String recordElement = (String) option.get(&quot;recordElement&quot;);     Document document = DocumentHelper.createDocument();     Element root = document.addElement( rootElement );     datas.forEach(data -&gt; {         Element element = root.addElement( recordElement );         data.keySet().stream().forEach(s -&gt;</code></pre><p> element.addElement(s).addText(data.get(s).toString()));<br>         } );</p><pre><code>     return document.asXML();</code></pre><p>} Map을 xml로 변환하기 위해 Dom4J라이브러리를 사용하였습니다 1. DocumentHelper.createDocument()를이용하여Document객체를생성합니다. 2. 생성된 Document 에 addElement( string ) 를 통해 가장 상위 태그를 추가하게 됩 니다. 이떄 넘기는 String 파라미터가 태그명이 됩니다 3. Map의 데이터를 xml로 옮기기 위해서는 map을 for-each를 돌려야 하는데 맵은 keyset 을 통해 key 와 value 를 loop 를 돌릴수 있었습니다. row하나를 추가 하기 위 해 rootElement 에 addElement 를 하여 item을 추가하고 추가된 element 에 for- each 를 돌려서 나오는 맵 데이터를 하나씩 추가합니다 4. document에asXML()메소드를통해String으로리턴합니다</p>]]></content>
      
      
      <categories>
          
          <category> 미분류 </category>
          
      </categories>
      
      
    </entry>
    
    <entry>
      <title>[2017해커톤] Chain Of Responsibility pattern</title>
      <link href="/2017/08/15/2017-ed-95-b4-ec-bb-a4-ed-86-a4-chain-of-responsibility-pattern/"/>
      <url>/2017/08/15/2017-ed-95-b4-ec-bb-a4-ed-86-a4-chain-of-responsibility-pattern/</url>
      
        <content type="html"><![CDATA[<p>필요 기능</p><ol><li>사용자가 입력한 조건으로 데이터가 생성 되게 만드는 기능</li><li>해당 데이터의 조건은 여러가지 일 수도 있다.</li></ol><p>현재 프로젝트에서 Filter가 실행되는 곳은 TypeHandler의 handle함수이다. 처음 handle에서 어떤 Filter를 사용할지 판단하여 선택하는 방식으로 하게 되었는데 결합이 강해져 결합을 약하게 만들기 위해 사용하게 되었다. FilterManager를 통해 FilterChain을 관리하고, FilterChain은 Filter들을 실행하고, 실행할 Filter들을 추가한다. FilterSelect는 CharacterFilter, NumberFilter 등을 선택한다.   <img src="https://ahea.files.wordpress.com/2017/08/ec8aa4ed81aceba6b0ec83b7-2017-08-15-01-15-05.png" alt="스크린샷 2017-08-15 01.15.05.png">  </p><p>public class FilterManager {</p><pre><code>FilterChain filterChain;public FilterManager() {    filterChain = new FilterChain();}public void setFilter(Filter filter) {    filterChain.addFilter(filter);}public Boolean filter(Object value){    return filterChain.execute(value);}</code></pre><p>}</p><p>public class FilterChain {</p><pre><code>private List&lt;Filter&gt; filters = new ArrayList&lt;Filter&gt;();public void addFilter(Filter filter) {    filters.add(filter);}public boolean execute(Object value) {    int index = 0;    for (Filter filter : filters) {        if( !filter.filter(value) ) {            return true;        }    }    return false;}</code></pre><p>}</p><p>public class CharacterFilter implements Filter<string> {</string></p><pre><code>Predicate&lt;String&gt; condition;public CharacterFilter(Predicate&lt;String&gt; condition) {    this.condition = condition;}@Overridepublic Boolean filter(String value) {    return condition.test(value);}</code></pre><p>}</p><p>public class NumberFilter implements Filter<integer> {</integer></p><pre><code>Predicate&lt;Integer&gt; condition;public NumberFilter(Predicate&lt;Integer&gt; condition) {    this.condition = condition;}@Overridepublic Boolean filter(Integer value) {    return condition.test(value);}</code></pre><p>}</p><p>public class FilterSelect {</p><pre><code>public FilterManager selectFilter(FieldCategory fieldCategory){    ......        Filter filter = null;        if(type.equals(CategoryType.Repo)){            filterManager.setFilter( addRepoFilter(condition) );        }else if(type.equals(CategoryType.Random)){            filterManager.setFilter( addRandomFilter(condition) );        }else if(type.equals(CategoryType.Select)){</code></pre><p>//                filterManager.setFilter( addSelectFilter() );<br>            }else if(type.equals(CategoryType.Date)){<br>//                filterManager.setFilter( addDateFilter() );<br>            }else {<br>                throw new RuntimeException(“category type error”);<br>            }<br>        ……<br>        return filterManager;<br>    }</p><pre><code>private Filter addRepoFilter(String condition){    ......    Filter filter = null;    if(sign.equals(&quot;first&quot;)){        filter = new CharacterFilter(o -&gt; o.startsWith(comparison));    }else if(sign.equals(&quot;middle&quot;)){        filter = new CharacterFilter(o -&gt; o.contains(comparison));    }else if(sign.equals(&quot;last&quot;)){        filter = new CharacterFilter(o -&gt; o.endsWith(comparison));    }else {        throw new RuntimeException(&quot;sign error&quot;);    }    return filter;}private Filter addRandomFilter(String condition){    ......    Filter filter = null;    if(sign.equals(&quot;&lt;&quot;)){        filter = new NumberFilter(o -&gt; o &lt; comparison);    }else if(sign.equals(&quot;&lt;=&quot;)){        filter = new NumberFilter(o -&gt; o &lt; comparison);    }else if(sign.equals(&quot;&gt;&quot;)){        filter = new NumberFilter(o -&gt; o &gt; comparison);    }else if(sign.equals(&quot;&gt;=&quot;)){        filter = new NumberFilter(o -&gt; o &gt;= comparison);    }else if(sign.equals(&quot;==&quot;)){        filter = new NumberFilter(o -&gt; o == comparison);    }else if(sign.equals(&quot;!=&quot;)){        filter = new NumberFilter(o -&gt; o != comparison);    }else {        throw new RuntimeException(&quot;sign error&quot;);    }    return filter;}</code></pre><p>}</p><p>public class TypeHandler {</p><pre><code>public List&lt;List&lt;ResultData&gt;&gt; handle(List&lt;FieldCategory&gt; fieldCategoryList, Integer rowNumber){    ......            if(fieldCategory.getConditions() != null){                //filter insert                FilterSelect filterSelect = new FilterSelect();                FilterManager filterManager = filterSelect.selectFilter(fieldCategory);                filterManager.filter(value);            }           ......}</code></pre><p>}</p><p>참고 자료 : <a href="http://wildpup.cafe24.com/archives/596" target="_blank" rel="noopener">http://wildpup.cafe24.com/archives/596</a> <a href="http://solarisailab.com/archives/1330" target="_blank" rel="noopener">http://solarisailab.com/archives/1330</a></p>]]></content>
      
      
      <categories>
          
          <category> 미분류 </category>
          
      </categories>
      
      
    </entry>
    
    <entry>
      <title>[2017해커톤] Spring Boot / MariaDB 설정</title>
      <link href="/2017/08/15/2017-ed-95-b4-ec-bb-a4-ed-86-a4-spring-boot-mariadb-ec-84-a4-ec-a0-95/"/>
      <url>/2017/08/15/2017-ed-95-b4-ec-bb-a4-ed-86-a4-spring-boot-mariadb-ec-84-a4-ec-a0-95/</url>
      
        <content type="html"><![CDATA[<h1 id="해커톤-Spring-Boot-MariaDB-설정"><a href="#해커톤-Spring-Boot-MariaDB-설정" class="headerlink" title="[해커톤] Spring Boot / MariaDB 설정"></a>[해커톤] Spring Boot / MariaDB 설정</h1><p>pom.xml에 다음과 같이 설정 [code lang=text] <dependency> <groupid>mysql</groupid> <artifactid>mysql-connector-java</artifactid> <scope>runtime</scope> </dependency> <dependency> <groupid>org.mariadb.jdbc</groupid> <artifactid>mariadb-java-client</artifactid> <version>1.1.7</version> </dependency> [/code] application.properties에 다음과 같이 설정 [code lang=text] <br>spring.datasource.platform=mysql spring.datasource.url=jdbc:mariadb://192.168.219.154:3306/ahea spring.datasource.username=root spring.datasource.password=0000 spring.datasource.driverclassName=org.mariadb.jdbc.Driver [/code]</p>]]></content>
      
      
      <categories>
          
          <category> 미분류 </category>
          
      </categories>
      
      
    </entry>
    
    <entry>
      <title>[2017해커톤] Spring cross domain 이슈 처리</title>
      <link href="/2017/08/15/2017-ed-95-b4-ec-bb-a4-ed-86-a4-spring-cross-domain-ec-9d-b4-ec-8a-88-ec-b2-98-eb-a6-ac/"/>
      <url>/2017/08/15/2017-ed-95-b4-ec-bb-a4-ed-86-a4-spring-cross-domain-ec-9d-b4-ec-8a-88-ec-b2-98-eb-a6-ac/</url>
      
        <content type="html"><![CDATA[<h1 id="해커톤-Spring-Boot-Cross-Domain-이슈"><a href="#해커톤-Spring-Boot-Cross-Domain-이슈" class="headerlink" title="[해커톤] Spring Boot / Cross Domain 이슈"></a>[해커톤] Spring Boot / Cross Domain 이슈</h1><p>해결법 1. @CrossOrigin [code lang=text] @RequestMapping(value = Constant.URI_CATEGORY_TYPE_API) @CrossOrigin public String getCategoryType(){ List<enum> categoryType = new ArrayList&lt;&gt;(); categoryType.add(CategoryType.Date); categoryType.add(CategoryType.Random); categoryType.add(CategoryType.Repo); return categoryType.toString(); } [/code] 해결법 2. JavaConfig [code lang=text] @Configuration public class WebConfiguration { @Bean public WebMvcConfigurer corsConfigurer() { return new WebMvcConfigurerAdapter() { @Override public void addCorsMappings(CorsRegistry registry) { registry.addMapping(“/**”); } }; } } [/code] 참고 <a href="https://spring.io/guides/gs/rest-service-cors/" target="_blank" rel="noopener">https://spring.io/guides/gs/rest-service-cors/</a> <a href="https://spring.io/blog/2015/06/08/cors-support-in-spring-framework" target="_blank" rel="noopener">https://spring.io/blog/2015/06/08/cors-support-in-spring-framework</a></enum></p>]]></content>
      
      
      <categories>
          
          <category> 미분류 </category>
          
      </categories>
      
      
    </entry>
    
    <entry>
      <title>[2017해커톤]Xeger라이브러리의 정규표현식에 맞춘 램덤 데이터 생성</title>
      <link href="/2017/08/15/2017-ed-95-b4-ec-bb-a4-ed-86-a4xeger-eb-9d-bc-ec-9d-b4-eb-b8-8c-eb-9f-ac-eb-a6-ac-ec-9d-98-ec-a0-95-ea-b7-9c-ed-91-9c-ed-98-84-ec-8b-9d-ec-97-90-eb-a7-9e-ec-b6-98-eb-9e-a8-eb-8d-a4-eb-8d-b0/"/>
      <url>/2017/08/15/2017-ed-95-b4-ec-bb-a4-ed-86-a4xeger-eb-9d-bc-ec-9d-b4-eb-b8-8c-eb-9f-ac-eb-a6-ac-ec-9d-98-ec-a0-95-ea-b7-9c-ed-91-9c-ed-98-84-ec-8b-9d-ec-97-90-eb-a7-9e-ec-b6-98-eb-9e-a8-eb-8d-a4-eb-8d-b0/</url>
      
        <content type="html"><![CDATA[<p>String regex = “[ab]{4,6}c”;</p><p>Xeger generator = new Xeger(regex);</p><p>String result = generator.generate();</p><p>assert result.matches(regex);</p><ol><li>램덤 데이터를 원하는 정규표현식을 작성합니다.</li><li>Xeger 객체를 만 듭니다.</li><li>generate() 메서드를 통해 데이터를 만들며</li><li>String의 정규표현식 판별 메소드 matches로 정규표현식에 맞는 데이터가 생성되었는지 확인 합니다.</li><li>위의 예제는 자릿수 4~6자리의 a나 b의 문자로 채워지는 문자열을 만드는 예제 입니다.</li></ol>]]></content>
      
      
      <categories>
          
          <category> 미분류 </category>
          
      </categories>
      
      
    </entry>
    
    <entry>
      <title>[2017해커톤]Docker 를 활용한 MariaDB 컨테이너 띄우기</title>
      <link href="/2017/08/15/docker-eb-a5-bc-ed-99-9c-ec-9a-a9-ed-95-9c-mariadb-ec-bb-a8-ed-85-8c-ec-9d-b4-eb-84-88-eb-9d-84-ec-9a-b0-ea-b8-b0/"/>
      <url>/2017/08/15/docker-eb-a5-bc-ed-99-9c-ec-9a-a9-ed-95-9c-mariadb-ec-bb-a8-ed-85-8c-ec-9d-b4-eb-84-88-eb-9d-84-ec-9a-b0-ea-b8-b0/</url>
      
        <content type="html"><![CDATA[<p><img src="https://ahea.files.wordpress.com/2017/08/1444_iwkb1js2dj.png" alt=""></p><ol><li>Kitematic 에서 MariaDB을 찾아 Create버튼을 클릭 합니다.</li></ol><p><img src="https://ahea.files.wordpress.com/2017/08/1444_krgq1cjm4o.png" alt=""></p><ol start="2"><li>자동으로 Image를 다운받아 컨테이너까지 띄워지고 원하는 호스트 포트를 지정해 주시고</li></ol><p><img src="https://ahea.files.wordpress.com/2017/08/1444_tfoloaupma.png" alt=""></p><ol start="3"><li>환경 변수에는 root 비밀번호를 설정 합니다.(MYSQL_ROOT_PASSWORD)</li></ol><p><img src="https://ahea.files.wordpress.com/2017/08/1444_aevjvafbqe.png" alt=""></p><ol start="4"><li>호스트의 볼륨과의 연결을 통해 DB에 쌓이는 데이터파일을 호스트PC의 지정 디렉토리에 저장 할수 있게 설정할수 있습니다.</li></ol>]]></content>
      
      
      <categories>
          
          <category> 미분류 </category>
          
      </categories>
      
      
    </entry>
    
    <entry>
      <title>자바개발자가 알아야 할 jvm과 garbage collection – 2</title>
      <link href="/2017/07/26/ec-9e-90-eb-b0-94-ea-b0-9c-eb-b0-9c-ec-9e-90-ea-b0-80-ec-95-8c-ec-95-84-ec-95-bc-ed-95-a0-jvm-ea-b3-bc-garbage-collection-2/"/>
      <url>/2017/07/26/ec-9e-90-eb-b0-94-ea-b0-9c-eb-b0-9c-ec-9e-90-ea-b0-80-ec-95-8c-ec-95-84-ec-95-bc-ed-95-a0-jvm-ea-b3-bc-garbage-collection-2/</url>
      
        <content type="html"><![CDATA[<p>이전글 : <a href="https://ahea.wordpress.com/2017/05/25/자바개발자가-알아야-할-jvm과-garbage-collection/" target="_blank" rel="noopener">https://ahea.wordpress.com/2017/05/25/자바개발자가-알아야-할-jvm과-garbage-collection/</a> 자바의 메모리 구조를 살펴보자면 다음과 같습니다. <img src="https://ahea.files.wordpress.com/2017/07/439980e1-fe4f-4557-9eb0-31b2b6bead88.png" alt="439980E1-FE4F-4557-9EB0-31B2B6BEAD88.png"> heap 메모리는 young 영역과 old 영역으로 구분 되고 Young 영역은 3개의 영역으로 나뉜다. - Eden 영역, Survivor 영역 2개 perm gen은  아래와 같은 정보가 포함되있다. <a href="https://yckwon2nd.blogspot.kr/2014/04/garbage-collection.html" target="_blank" rel="noopener">https://yckwon2nd.blogspot.kr/2014/04/garbage-collection.html</a> 여기 참조.</p><p>1. Class 의 Meta정보 (pkg path 정보라고 보면 됨, text 정보)</p><p>2. Method의  Meta 정보</p><p>3. Static Object</p><p>4. 상수화된 String Object</p><p>5. Class와 관련된 배열 객체 Meta 정보</p><p>6. JVM 내부적인 객체들과 최적화컴파일러(JIT)의 최적화 정보</p><p>perm gen 설명</p><p>The permanent generation is special because it holds meta-data describing user classes (classes that are not part of the Java language). Examples of such meta-data are objects describing classes and methods and they are stored in the Permanent Generation. Applications with large code-base can quickly fill up this segment of the heap which will causejava.lang.OutOfMemoryError: PermGen no matter how high your -Xmx and how much memory you have on the machine.</p><p>프로젝트가 커지면 perm gen이 커서 에러가 나는데 이떄는 MaxPermSize를 jvm 옵션에 줘서 크게 하면 해결된다. java8에서는 고질적인 perm gen space error를 해결하기 위해서 perm 영역을 없애버렸다 그래서  -XX:MaxPermSize 설정이 사라지고 -XX:MaxMetaspaceSize 로 바뀌게 되었다. 각각 jvm default 값도 있는데 귀찬아서 패스. <img src="https://ahea.files.wordpress.com/2017/07/2.png" alt="2"><img src="https://ahea.files.wordpress.com/2017/07/3.png" alt="3"><img src="https://ahea.files.wordpress.com/2017/07/4.png" alt="4"><img src="https://ahea.files.wordpress.com/2017/07/5.png" alt="5"> 이 사진은 오라클 홈페이지에 나와있는 사진인데, 설명은 naver d2에 있는게 잘 되있어서 참고했다. 새로 생성한 객체는 Eden에 생성된다. Eden 영역에서 GC가 한 번 발생한 후 살아남은 객체는 Survivor 영역 중 하나로 이동된다.(age +1 되고 minor gc 발생) Eden 영역에서 GC가 발생하면 이미 살아남은 객체가 존재하는 Survivor 영역으로 객체가 계속 쌓인다.(객체가 나이를 계속 먹어감) 하나의 Survivor 영역이 가득 차게 되면 그 중에서 살아남은 객체를 다른 Survivor 영역으로 이동한다. 그리고 가득 찬 Survivor 영역은 아무 데이터도 없는 상태로 된다. 이 과정을 반복하다가 계속해서 살아남아 있는 객체는 Old 영역으로 이동하게 된다. old영역이 가득 차면 full gc 발생(major gc) Old - mark sweep compact <strong>알고리즘</strong> Old 영역의 GC는 mark-sweep-compact 알고리즘 사용한다. 알고리즘의 첫 단계는 Old 영역에 살아 있는 객체를 식별(Mark) 힙(heap)의 앞 부분부터 확인하여 살아 있는 것만 남김 (Sweep) 각 객체들이 연속되게 쌓이도록 힙의 가장 앞 부분부터 채워서 객체가 존재하는 부분과 객체가 없는 부분으로 나눈다(Compaction) 논외로 gc가 발생하게 되면 stop the world(stw)라고 해서 gc가 메모리 정리를 위해서 어플리케이션 실행을 중지 시키는데 gc를 돌리는 thread 만 빼고 모든 thread 를 정지 시킨다. 만약에 gc를 튜닝한다면 stw의 시간을 줄이는것을 목표로 한다. 말로 ppt를 보며 설명하면 쉬운데 글로 막상 글로 정리할려고 하니 잘 정리가 안된다…</p>]]></content>
      
      
      <categories>
          
          <category> java </category>
          
      </categories>
      
      
    </entry>
    
    <entry>
      <title>ahea study – 20170702 스터디 모임</title>
      <link href="/2017/07/19/ahea-study-20170702-ec-8a-a4-ed-84-b0-eb-94-94-eb-aa-a8-ec-9e-84/"/>
      <url>/2017/07/19/ahea-study-20170702-ec-8a-a4-ed-84-b0-eb-94-94-eb-aa-a8-ec-9e-84/</url>
      
        <content type="html"><![CDATA[<p>게을러서 늦어진 늦은 후기 입니다.. 일단 공개세미나 2회차가 잡혔습니다. 저번에 발표했을때 공간이 아쉬웠다라는 피드백을 많이 받아서 좋은곳으로 발표장소를 잡았습니다. 무려 강남! <a href="https://onoffmix.com/event/106437" target="_blank" rel="noopener">https://onoffmix.com/event/106437</a> 링크는 여기 많이들 오세요~ <img src="https://ahea.files.wordpress.com/2017/07/eca09cebaaa9-ec9786ec9d8c.png" alt="제목 없음"> 발표자와 주제는 다음과 같습니다. 이번에 새로 들어오신 두분께서 스터디 발표를 해주시게 되었습니다. 분야가 다른사람들과 이야기 하다보면서 점점 개발자로 성장해가지는것 같습니다. <img src="https://ahea.files.wordpress.com/2017/07/eca09cebaaa9-ec9786ec9d8c1.png" alt="제목 없음1"> 미리 발표자료를 만들고 다같이 모여 발표를 하며 피드백을 받고 어느 부분을 더 보강했으면 좋겟다라고 의견을 나누게 됩니다. 이번에 스터디는 발표를 4명이서 하지만 스터디는 모든 인원이 참석해서 진행했습니다. <img src="https://ahea.files.wordpress.com/2017/07/20170702_161721.jpg" alt="20170702_161721"> <img src="https://ahea.files.wordpress.com/2017/07/kakaotalk_20170719_185158156.jpg" alt="KakaoTalk_20170719_185158156"> 긴 시간 스터디가 끝난 후 밥먹으러 이동~ <img src="https://ahea.files.wordpress.com/2017/07/kakaotalk_20170718_155056920.jpg" alt="KakaoTalk_20170718_155056920"> 소고기 무한 리필집에가서 밥먹으며 이런저런 이야기를 나누며 개발자 인맥을 만들고 있습니다. <img src="https://ahea.files.wordpress.com/2017/07/3.jpg" alt="3"> “혼자 가면 빨리 갈 수 있지만, 함께 가면 멀리 갈 수 있다.”  함께 오니 어느새 여기까지 왔네요. 개발자인데 부담없이 스터디 하고 싶으신 분들 환영합니다.</p>]]></content>
      
      
      <categories>
          
          <category> 공개스터디 </category>
          
      </categories>
      
      
    </entry>
    
    <entry>
      <title>Docker 에서 Hadoop 워드 카운트 예제를 돌려보자!</title>
      <link href="/2017/07/18/docker-ec-97-90-ec-84-9c-hadoop-ec-9b-8c-eb-93-9c-ec-b9-b4-ec-9a-b4-ed-8a-b8-ec-98-88-ec-a0-9c-eb-a5-bc-eb-8f-8c-eb-a0-a4-eb-b3-b4-ec-9e-90/"/>
      <url>/2017/07/18/docker-ec-97-90-ec-84-9c-hadoop-ec-9b-8c-eb-93-9c-ec-b9-b4-ec-9a-b4-ed-8a-b8-ec-98-88-ec-a0-9c-eb-a5-bc-eb-8f-8c-eb-a0-a4-eb-b3-b4-ec-9e-90/</url>
      
        <content type="html"><![CDATA[<h1 id="들어가기…"><a href="#들어가기…" class="headerlink" title="들어가기…"></a>들어가기…</h1><p>본 내용은 먼저 Kitematic을 설치 하셔야 하고 설치가 귀찮으시면 Kitematic부분을 CLI로 따라하셔도 무방 합니다. <img src="https://ahea.files.wordpress.com/2017/07/a.png" alt="a.png"> Kitematic을 실행 하신 후 image 검색에 ‘<strong>hadoop</strong>‘을 검색 합니다. 이중에서 자신이 원하는 image를 create버튼 클릭 하시면 로컬에 image가 다운로드 됩니다. (cli에서는 docker pull 사용) <img src="https://ahea.files.wordpress.com/2017/07/b.png" alt="b.png"> create클릭 후 곧바로 image를 다운로드 하며 다운로드 후 컨테이너까지 생성(docker run) 해줍니다. <img src="https://ahea.files.wordpress.com/2017/07/b2.png" alt="b.png"> 컨테이너 까지 생성이 되면 가운데엔 log가 나오며 오른쪽엔 호스트와 컨테이너간의 포트 매핑된 모습을 볼수 있습니다. <img src="https://ahea.files.wordpress.com/2017/07/c.png" alt="c.png"> <img src="https://ahea.files.wordpress.com/2017/07/d.png" alt="d.png"> 톱니바퀴 클릭후 <strong>호스트포트:컨테이너포트</strong> 매핑된걸 클릭하시면 연결된 웹페이지도 열리므로 나중에 어떤 포트가 열려 있는지 확인 하시면 좋을거 같습니다. <img src="https://ahea.files.wordpress.com/2017/07/e.png" alt="e.png"> 위에 있는 EXEC버튼을 클릭 하시면 <img src="https://ahea.files.wordpress.com/2017/07/f.png" alt="f.png"> 각 OS에 맞는 CLI가 나옵니다. 여기서 부턴 컨테이너OS에 맞는 명령어를 치시면 컨테이너의 기능을 사용 하실수 있습니다. 본격적으로 hadoop 워드카운트 예제를 실행해 보겠습니다.</p><h1 id="Hadoop-워드-카운트-예제"><a href="#Hadoop-워드-카운트-예제" class="headerlink" title="Hadoop 워드 카운트 예제"></a>Hadoop 워드 카운트 예제</h1><p>hadoop 워드 카운트 예제는</p><ol><li>예제용 데이터 생성</li><li>예제용 데이터 HDFS에 삽입</li><li>워드 카운트 예제 실행</li><li>결과 확인</li></ol><p>순으로 실행할 예정 입니다. <img src="https://ahea.files.wordpress.com/2017/07/g.png" alt="g.png"> 하듑 명령어 실행의 편의성을 위해 PATH환경 변수를 추가 해 줍니다. <img src="https://ahea.files.wordpress.com/2017/07/h.png" alt="h.png"> 예제에 쓰일 테스트 데이터를 저장 합니다(Hello Hadoop, Hello Docker) <img src="https://ahea.files.wordpress.com/2017/07/i.png" alt="i.png"> hdfs명령어를 통해 Hadoop File System에 디렉토리 생성 및 테스트 파일을 넣어주고 <img src="https://ahea.files.wordpress.com/2017/07/i1.png" alt="i.png"> <strong>hadoop jar /usr/local/hadoop/share/hadoop/mapreduce/sources/hadoop-mapre</strong> <strong> duce-examples-2.7.0-sources.jar org.apache.hadoop.examples.WordCount testdata output</strong> 를 실행 합니다. <img src="https://ahea.files.wordpress.com/2017/07/j.png" alt="j.png"> 워드 카운트 예제를 돌린 로그가 뜨고 <img src="https://ahea.files.wordpress.com/2017/07/k.png" alt="k.png"> hdfs dfs -cat 명령어를 통해 워드 카운트 예제 결과를 확인 할 수 있습니다. Hadoop MapReduce에 대해 알고 싶으신 분들은 공식 홈페이지를 참조하시면 좋을거 같습니다. <a href="http://hadoop.apache.org/docs/current/hadoop-mapreduce-client/hadoop-mapreduce-client-core/MapReduceTutorial.html" target="_blank" rel="noopener">http://hadoop.apache.org/docs/current/hadoop-mapreduce-client/hadoop-mapreduce-client-core/MapReduceTutorial.html</a></p>]]></content>
      
      
      <categories>
          
          <category> java </category>
          
      </categories>
      
      
        <tags>
            
            <tag> docker </tag>
            
            <tag> hadoop </tag>
            
            <tag> kitematic </tag>
            
            <tag> word count </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>How Tomcat load spring web framework #1</title>
      <link href="/2017/06/23/how-tomcat-load-spring-web-framework-1/"/>
      <url>/2017/06/23/how-tomcat-load-spring-web-framework-1/</url>
      
        <content type="html"><![CDATA[<h1 id="How-Tomcat-load-spring-web-framework"><a href="#How-Tomcat-load-spring-web-framework" class="headerlink" title="How Tomcat load spring web framework"></a>How Tomcat load spring web framework</h1><h2 id="environment"><a href="#environment" class="headerlink" title="environment"></a>environment</h2><ul><li>Base project</li><li>Eclipse -&gt; File -&gt; New -&gt; Other -&gt; Spring Getting Started Content -&gt; spring-mvc-showcase</li><li>Spring framework version : 4.2.2.RELEASE</li><li>Web Application Server : Apache Tomcat 8.0.36</li></ul><h2 id="Spring-web-framework-deployment"><a href="#Spring-web-framework-deployment" class="headerlink" title="Spring web framework deployment"></a>Spring web framework deployment</h2><p>Web application에서 artifact를 servlet container에 올리는 과정을 deployment라고 표현한다. [code lang=text] 11-Apr-2017 02:49:11.284 정보 [localhost-startStop-1] org.apache.catalina.startup.HostConfig.deployDirectory Deploying web application directory /Users/thdghgns/Documents/workspace/web-server/apache-tomcat-8.0.43/webapps/manager 11-Apr-2017 02:49:11.310 정보 [localhost-startStop-1] org.apache.catalina.startup.HostConfig.deployDirectory Deployment of web application directory /Users/thdghgns/Documents/workspace/web-server/apache-tomcat-8.0.43/webapps/manager has finished in 25 ms [/code]</p><h3 id="Deployment-Descriptor-web-xml"><a href="#Deployment-Descriptor-web-xml" class="headerlink" title="Deployment Descriptor (web.xml)"></a>Deployment Descriptor (web.xml)</h3><p>container/engine으로 배포되는 artifact에 대한 설정파일 Java Platform에서는 component, module, 또는 application이 어떻게 배포되어야 하는지에 대해 설명한다. deployment tool에게 module 또는 application이 특정한 container option, security setting으로 deploy할 것을 알려주고, 특정 설정 요구사항에 대해 설명해준다. XML은 deployment descriptor 파일 작성을 위해 사용된 문법이다. Web application에서 deployment descriptor는 <strong>web.xml</strong>이라고 불리며 web application root의 WEB-INF 디렉토리 하위에 위치해야 한다(<strong>$root/WEB-INF/web.xml</strong>) . Java EE application에서 deployment descriptor는 이름이 application.xml이어야 하며 application .ear file의 최상위 레벨의 META-INF 디렉토리 하위에 존재해야 한다. 참고자료 : 1. <a href="https://en.wikipedia.org/wiki/Deployment_descriptor" title="Wikipedia DD" target="_blank" rel="noopener">Wikipia</a> 2. <a href="https://docs.oracle.com/cd/E14571_01/web.1111/e13712/web_xml.htm#WBAPP502" title="Oracle weblogic" target="_blank" rel="noopener">Oracle Weblogic</a> 3. <a href="https://cloud.google.com/appengine/docs/standard/java/config/webxml" title="Google appengine" target="_blank" rel="noopener">Google Appengine</a> 4. <a href="http://myblog.opendocs.co.kr/archives/436" title="Opendocs" target="_blank" rel="noopener">Opendocs</a></p><h3 id="How-Tomcat-Load-Spring-sketch"><a href="#How-Tomcat-Load-Spring-sketch" class="headerlink" title="How Tomcat Load Spring (sketch)"></a>How Tomcat Load Spring (sketch)</h3><p><img src="https://s3-ap-northeast-1.amazonaws.com/thdghgns/HowTomcatLoadSpring.svg" alt="How Tomcat Load Spring (detail)"> 링크 : <a href="https://s3-ap-northeast-1.amazonaws.com/thdghgns/HowTomcatLoadSpring.svg" target="_blank" rel="noopener">How Tomcat Load Spring (sketch)</a></p><h3 id="ContextLoaderListener"><a href="#ContextLoaderListener" class="headerlink" title="ContextLoaderListener"></a>ContextLoaderListener</h3><h4 id="역할"><a href="#역할" class="headerlink" title="역할"></a>역할</h4><ol><li>Spring의 root WebApplicationContext의 시작/종료를 위한 Bootstrap listener.</li><li><code>ContextCleanupListener</code>와 같이 간단하게 ContextLoader에게 위임한다.</li></ol><p><code>ServletContextListener</code>를 구현함으로써 servlet context에 대해 발생하는 이벤트를 받을 수 있게된다.</p><ul><li>생성(초기화) : <code>public void contextInitialized(ServletContextEvent sce)</code>;</li><li>삭제 : <code>public void contextDestroyed(ServletContextEvent sce)</code></li></ul><h4 id="javadoc"><a href="#javadoc" class="headerlink" title="javadoc"></a>javadoc</h4><h5 id="org-springframework-web-context-ContextLoaderListener"><a href="#org-springframework-web-context-ContextLoaderListener" class="headerlink" title="org.springframework.web.context.ContextLoaderListener"></a>org.springframework.web.context.ContextLoaderListener</h5><p>[code lang=java] /*<em> </em> Bootstrap listener to start up and shut down Spring’s root {@link WebApplicationContext}. <em> Simply delegates to {@link ContextLoader} as well as to {@link ContextCleanupListener}. </em> <em> This listener should be registered after {@link org.springframework.web.util.Log4jConfigListener} </em> in {@code web.xml}, if the latter is used. <em> </em> As of Spring 3.1, {@code ContextLoaderListener} supports injecting the root web <em> application context via the {@link #ContextLoaderListener(WebApplicationContext)} </em> constructor, allowing for programmatic configuration in Servlet 3.0+ environments. <em> See {@link org.springframework.web.WebApplicationInitializer} for usage examples. </em> <em> @author Juergen Hoeller </em> @author Chris Beams <em> @since 17.02.2003 </em> @see #setContextInitializers <em> @see org.springframework.web.WebApplicationInitializer </em> @see org.springframework.web.util.Log4jConfigListener */ public class ContextLoaderListener extends ContextLoader implements ServletContextListener { [/code]</p><h5 id="javax-servlet-ServletContextListener"><a href="#javax-servlet-ServletContextListener" class="headerlink" title="javax.servlet.ServletContextListener"></a>javax.servlet.ServletContextListener</h5><p>[code lang=java] /*<em> </em> Implementations of this interface receive notifications about changes to the <em> servlet context of the web application they are part of. To receive </em> notification events, the implementation class must be configured in the <em> deployment descriptor for the web application. </em> <em> @see ServletContextEvent </em> @since v 2.3 */ public interface ServletContextListener extends EventListener { [/code] 참고 :</p><ul><li>[ContextLoaderListener](<a href="http://docs.spring.io/spring/docs/current/javadoc-api/org/springframework/web/context/ContextLoaderListener.html" target="_blank" rel="noopener">http://docs.spring.io/spring/docs/current/javadoc-api/org/springframework/web/context/ContextLoaderListener.html</a>)</li><li>[ServletContextListener](<a href="https://tomcat.apache.org/tomcat-8.5-doc/servletapi/javax/servlet/ServletContextListener.html" target="_blank" rel="noopener">https://tomcat.apache.org/tomcat-8.5-doc/servletapi/javax/servlet/ServletContextListener.html</a>)</li></ul><h4 id="web-xml-설정"><a href="#web-xml-설정" class="headerlink" title="web.xml 설정"></a>web.xml 설정</h4><p>[code lang=xml] org.springframework.web.context.ContextLoaderListener [/code]</p><h3 id="ContextLoader"><a href="#ContextLoader" class="headerlink" title="ContextLoader"></a>ContextLoader</h3><h4 id="역할-1"><a href="#역할-1" class="headerlink" title="역할"></a>역할</h4><ol><li>root application context의 실제 초기화 작업을 수행</li><li>web.xml에서 을 찾아서 context class type을 구분하여 `contextClass`로 설정.</li><li>web.xml에서 <code>contextConfigLocation</code>을 찾아서 context instance의 값으로 전달<ol><li>허용되는 value<ol><li>commas 또는 spaces로 구분되는 여러개의 파일 경로</li><li>Ant-style의 표현식(eg.”<code>WEB-INF/*Context.xml,WEB-INF/spring*.xml</code>“)</li><li>defualt : “<code>/WEB-INF/applicationContext.xml</code>“</li></ol></li><li>다중 값이 적용되기 때문에 순서에 따라 override가 됨.</li></ol></li></ol><p>참고 : <a href="http://docs.spring.io/spring/docs/current/javadoc-api/org/springframework/web/context/ContextLoader.html" target="_blank" rel="noopener">Spring framework javadoc - ContextLoader</a></p><h3 id="How-Tomcat-Load-Spring-detail"><a href="#How-Tomcat-Load-Spring-detail" class="headerlink" title="How Tomcat Load Spring (detail)"></a>How Tomcat Load Spring (detail)</h3><p><img src="https://s3-ap-northeast-1.amazonaws.com/thdghgns/SpringRootWebApplicationContextLoading.svg" alt="How Tomcat Load Spring (detail)"> 링크 : <a href="https://s3-ap-northeast-1.amazonaws.com/thdghgns/SpringRootWebApplicationContextLoading.svg" target="_blank" rel="noopener">How Tomcat Load Spring (detail)</a></p><ol><li>Web Application Server(tomcat)이 DD(web.xml)을 읽어서 Listener(<code>ClassLoaderListener</code>)를 등록</li><li>Web Application Server가 Servlet Context를 생성하면 servlet context 초기화 이벤트(ServletContextEvent)가 발생하고, 이벤트를 <code>ClassLoaderListener</code>가 이벤트를 받아서 <code>contextInitialized()</code>를 실행한다.<ol><li>이때 받은 <code>ServletContextEvent</code>에서 <code>ServletContext</code>를 꺼내고 보면 실제 context는 <code>org.apache.catalina.core.ApplicationContext</code>이다.</li></ol></li><li>현재 <code>context==null</code>이기 떄문에 context를 생성한다.<ol><li>별다른 설정이 없을 경우 <code>XmlWebApplicationContext</code>가 기본.</li></ol></li><li>context가 active가 아니고 root이기 때문에 parent==null이고 parent를 주려고 찾아도 없다.</li><li>ServletContext를 WebApplicationContext의 servlet context로 설정한다.</li><li>에 설정된 contextConfigLocation 설정 파일 위치를 읽어서 <code>StandardServletEnvironment</code>을 생성한다. <code>StandardServletEnvironment</code>는 내부적으로 <code>StandardEnvironment</code>를 확장하고, <code>StandardEnvironment</code>는 내부적으로 <code>AbstractEnvironment</code>를 확장한다.<ol><li>property source를 customize.<ol><li>servletConfigInitParams</li><li>servletContextInitParams</li><li>jndiProperties</li><li>systemProperties</li><li>systemEnvironment</li></ol></li><li>property source를 init(새로 만들고 replace)<ol><li>servletContextInitParams</li></ol></li><li>refresh()<ol><li>refresh 준비<ol><li>active로 변경</li><li>property source를 다시 init</li></ol></li><li>ConfigurableListableBeanFactory 획득. 없으면 생성<ol><li>XmlBeanDefinitionReader<ol><li>environment 설정</li><li>resource loader설정</li><li>entity resolver 설정</li><li>init</li></ol></li><li>reader로 xml resource에서 bean definition을 읽음.</li><li>bean을 읽고</li><li>resource 닫고</li></ol></li><li>postProcessBeanFactory</li><li>invokeBeanFactoryPostProcessors</li><li>registerBeanPostProcessors</li><li>initMessageSource</li><li>initApplicationEvntMulticaster</li><li>onRefresh -&gt; theme 설정</li><li>registerListeners</li><li>finishBeanFactoryInitialization<ol><li>bean 생성</li></ol></li></ol></li><li>Filter 등록<ol><li>등록할 때 <code>StandardServletEnvironment</code>를 다시 customize하면서 property source 다시 설정</li></ol></li><li>DispatcherServlet 등록<ol><li>servletContext 생성</li><li>등록할 때 <code>StandardServletEnvironment</code>를 다시 customize하면서 property source 다시 설정</li></ol></li></ol></li></ol><h2 id="ApplicationContext의-특성"><a href="#ApplicationContext의-특성" class="headerlink" title="ApplicationContext의 특성"></a>ApplicationContext의 특성</h2><h3 id="Application-Context-vs-Bean-Factory"><a href="#Application-Context-vs-Bean-Factory" class="headerlink" title="Application Context vs Bean Factory"></a>Application Context vs Bean Factory</h3><h4 id="역할-및-기능"><a href="#역할-및-기능" class="headerlink" title="역할 및 기능"></a>역할 및 기능</h4><p><img src="https://i.stack.imgur.com/TqcgB.jpg" alt=""></p><ul><li>Bean Factory :<ul><li>Bean instantiation/wiring</li></ul></li><li>Application Context :<ul><li>Bean instantiation/wiring</li><li>Automatic BeanPostProcessor registration</li><li>Automatic BeanFactoryPostProcessor registration</li><li>Convenient MessageSource access (for i18n)</li><li>ApplicationEvent publication</li></ul></li></ul><h3 id="Application-Context-Structure"><a href="#Application-Context-Structure" class="headerlink" title="Application Context Structure"></a>Application Context Structure</h3><p><img src="https://slipp.net/wiki/download/attachments/25527577/ApplicationContext_2.jpg?version=1&amp;modificationDate=1453340947000&amp;api=v2" alt="">### Application Context Inheritance<em> Root Web Application Context : <code>ContextLoader</code>가 생성한 Application Context</em> DispatcherServlet Web Application Context : <code>Root Web Application Context</code>를 부모로 하는 child application context&gt; parent에서는 child를 바라보지 못하고, child는 parent를 바라볼 수 있다.&gt; 그래서 parent는 child context에 정의된 bean을 사용할 수 없고, child는 parent에 정의된 bean을 사용한다. 이때 한 parent에 속하는 child는 parent의 bean을 공유한다.<img src="http://www.deroneriksson.com/deroneriksson-resources/tutorials/java/spring/introduction-to-the-spring-framework/configuring-root-web-application-context-in-spring-web-application/application-context-inheritance.png" alt="Application Context Inheritance">&gt; BeanPostProcessors, BeaFactoryPostProcessors는 child에게 상속되지 않는다. 이유는 scope가 <code>per-container</code>이기 때문이다.<a href="https://docs.spring.io/spring/docs/current/spring-framework-reference/htmlsingle/#beans-factory-extension-bpp" target="_blank" rel="noopener">참고자료 : 7.8.1 Customizing beans using a BeanPostProcessor</a>### Root Web Application Context vs DispatcherServlet Web Application Context일반적으로 Root Applicaion Context에는 Services, DAOs와 같은 bean이 정의되고, DispatcherServlet Web Applicaion Context에는 servlet을 사용하는 Controller bean이 등록된다.<img src="http://www.deroneriksson.com/deroneriksson-resources/tutorials/java/spring/introduction-to-the-spring-framework/configuring-root-web-application-context-in-spring-web-application/root-web-application-context-vs-dispatcherservlet-web-application-context.png" alt="root context vs servlet context"></p><h3 id="Application-Context-Inheritance"><a href="#Application-Context-Inheritance" class="headerlink" title="Application Context Inheritance"></a>Application Context Inheritance</h3><ul><li>Root Web Application Context : <code>ContextLoader</code>가 생성한 Application Context</li><li>DispatcherServlet Web Application Context : Root Web Application Context를 부모로 하는 child application context</li></ul><p>parent에서는 child를 바라보지 못하고, child는 parent를 바라볼 수 있다. 그래서 parent는 child context에 정의된 bean을 사용할 수 없고, child는 parent에 정의된 bean을 사용한다. 이때 한 parent에 속하는 child는 parent의 bean을 공유한다. <img src="http://www.deroneriksson.com/deroneriksson-resources/tutorials/java/spring/introduction-to-the-spring-framework/configuring-root-web-application-context-in-spring-web-application/application-context-inheritance.png" alt=""> BeanPostProcessors, BeaFactoryPostProcessors는 child에게 상속되지 않는다. 이유는 scope가 ‘per-container’이기 때문이다. <a href="https://docs.spring.io/spring/docs/current/spring-framework-reference/htmlsingle/#beans-factory-extension-bpp" target="_blank" rel="noopener">참고자료 : 7.8.1 Customizing beans using a BeanPostProcessor</a></p><h3 id="Root-Web-Application-Context-vs-DispatcherServlet-Web-Application-Context"><a href="#Root-Web-Application-Context-vs-DispatcherServlet-Web-Application-Context" class="headerlink" title="Root Web Application Context vs DispatcherServlet Web Application Context"></a>Root Web Application Context vs DispatcherServlet Web Application Context</h3><p>일반적으로 Root Applicaion Context에는 Services, DAOs와 같은 bean이 정의되고, DispatcherServlet Web Applicaion Context에는 servlet을 사용하는 Controller bean이 등록된다. <img src="http://www.deroneriksson.com/deroneriksson-resources/tutorials/java/spring/introduction-to-the-spring-framework/configuring-root-web-application-context-in-spring-web-application/root-web-application-context-vs-dispatcherservlet-web-application-context.png" alt=""> 참고자료 : <a href="http://www.deroneriksson.com/tutorial-categories/java/spring/introduction-to-the-spring-framework" target="_blank" rel="noopener">deroneriksson.com</a></p>]]></content>
      
      
      <categories>
          
          <category> 미분류 </category>
          
      </categories>
      
      
    </entry>
    
    <entry>
      <title>How Tomcat load spring web framework #1 (Root Applicaion Context의 생성)</title>
      <link href="/2017/06/23/how-tomcat-load-spring-web-framework-1-root-applicaion-context-ec-9d-98-ec-83-9d-ec-84-b1-trashed/"/>
      <url>/2017/06/23/how-tomcat-load-spring-web-framework-1-root-applicaion-context-ec-9d-98-ec-83-9d-ec-84-b1-trashed/</url>
      
        <content type="html"><![CDATA[<h1 id="How-Tomcat-load-spring-web-framework"><a href="#How-Tomcat-load-spring-web-framework" class="headerlink" title="How Tomcat load spring web framework"></a>How Tomcat load spring web framework</h1><h2 id="environment"><a href="#environment" class="headerlink" title="environment"></a>environment</h2><ul><li>Base project</li><li>Eclipse -&gt; File -&gt; New -&gt; Other -&gt; Spring Getting Started Content -&gt; spring-mvc-showcase</li><li>Spring framework version : 4.2.2.RELEASE</li><li>Web Application Server : Apache Tomcat 8.0.36</li></ul><h2 id="Spring-web-framework-deployment"><a href="#Spring-web-framework-deployment" class="headerlink" title="Spring web framework deployment"></a>Spring web framework deployment</h2><p>Web application에서 artifact를 servlet container에 올리는 과정을 deployment라고 표현한다. [code lang=text] 11-Apr-2017 02:49:11.284 정보 [localhost-startStop-1] org.apache.catalina.startup.HostConfig.deployDirectory Deploying web application directory /Users/thdghgns/Documents/workspace/web-server/apache-tomcat-8.0.43/webapps/manager 11-Apr-2017 02:49:11.310 정보 [localhost-startStop-1] org.apache.catalina.startup.HostConfig.deployDirectory Deployment of web application directory /Users/thdghgns/Documents/workspace/web-server/apache-tomcat-8.0.43/webapps/manager has finished in 25 ms [/code]</p><h3 id="Deployment-Descriptor-web-xml"><a href="#Deployment-Descriptor-web-xml" class="headerlink" title="Deployment Descriptor (web.xml)"></a>Deployment Descriptor (web.xml)</h3><p>container/engine으로 배포되는 artifact에 대한 설정파일 Java Platform에서는 component, module, 또는 application이 어떻게 배포되어야 하는지에 대해 설명한다. deployment tool에게 module 또는 application이 특정한 container option, security setting으로 deploy할 것을 알려주고, 특정 설정 요구사항에 대해 설명해준다. XML은 deployment descriptor 파일 작성을 위해 사용된 문법이다. Web application에서 deployment descriptor는 <strong>web.xml</strong>이라고 불리며 web application root의 WEB-INF 디렉토리 하위에 위치해야 한다(<strong>$root/WEB-INF/web.xml</strong>) . Java EE application에서 deployment descriptor는 이름이 application.xml이어야 하며 application .ear file의 최상위 레벨의 META-INF 디렉토리 하위에 존재해야 한다. 참고자료 : 1. <a href="https://en.wikipedia.org/wiki/Deployment_descriptor" title="Wikipedia DD" target="_blank" rel="noopener">Wikipia</a> 2. <a href="https://docs.oracle.com/cd/E14571_01/web.1111/e13712/web_xml.htm#WBAPP502" title="Oracle weblogic" target="_blank" rel="noopener">Oracle Weblogic</a> 3. <a href="https://cloud.google.com/appengine/docs/standard/java/config/webxml" title="Google appengine" target="_blank" rel="noopener">Google Appengine</a> 4. <a href="http://myblog.opendocs.co.kr/archives/436" title="Opendocs" target="_blank" rel="noopener">Opendocs</a></p><h3 id="How-Tomcat-Load-Spring-sketch"><a href="#How-Tomcat-Load-Spring-sketch" class="headerlink" title="How Tomcat Load Spring (sketch)"></a>How Tomcat Load Spring (sketch)</h3><p><img src="https://s3-ap-northeast-1.amazonaws.com/thdghgns/HowTomcatLoadSpring.svg" alt="How Tomcat Load Spring (detail)"> 링크 : <a href="https://s3-ap-northeast-1.amazonaws.com/thdghgns/HowTomcatLoadSpring.svg" target="_blank" rel="noopener">How Tomcat Load Spring (sketch)</a></p><h3 id="ContextLoaderListener"><a href="#ContextLoaderListener" class="headerlink" title="ContextLoaderListener"></a>ContextLoaderListener</h3><h4 id="역할"><a href="#역할" class="headerlink" title="역할"></a>역할</h4><ol><li>Spring의 root WebApplicationContext의 시작/종료를 위한 Bootstrap listener.</li><li><code>ContextCleanupListener</code>와 같이 간단하게 ContextLoader에게 위임한다.</li></ol><p><code>ServletContextListener</code>를 구현함으로써 servlet context에 대해 발생하는 이벤트를 받을 수 있게된다.</p><ul><li>생성(초기화) : <code>public void contextInitialized(ServletContextEvent sce)</code>;</li><li>삭제 : <code>public void contextDestroyed(ServletContextEvent sce)</code></li></ul><h4 id="javadoc"><a href="#javadoc" class="headerlink" title="javadoc"></a>javadoc</h4><h5 id="org-springframework-web-context-ContextLoaderListener"><a href="#org-springframework-web-context-ContextLoaderListener" class="headerlink" title="org.springframework.web.context.ContextLoaderListener"></a>org.springframework.web.context.ContextLoaderListener</h5><p>[code lang=java] /*<em> </em> Bootstrap listener to start up and shut down Spring’s root {@link WebApplicationContext}. <em> Simply delegates to {@link ContextLoader} as well as to {@link ContextCleanupListener}. </em> <em> This listener should be registered after {@link org.springframework.web.util.Log4jConfigListener} </em> in {@code web.xml}, if the latter is used. <em> </em> As of Spring 3.1, {@code ContextLoaderListener} supports injecting the root web <em> application context via the {@link #ContextLoaderListener(WebApplicationContext)} </em> constructor, allowing for programmatic configuration in Servlet 3.0+ environments. <em> See {@link org.springframework.web.WebApplicationInitializer} for usage examples. </em> <em> @author Juergen Hoeller </em> @author Chris Beams <em> @since 17.02.2003 </em> @see #setContextInitializers <em> @see org.springframework.web.WebApplicationInitializer </em> @see org.springframework.web.util.Log4jConfigListener */ public class ContextLoaderListener extends ContextLoader implements ServletContextListener { [/code]</p><h5 id="javax-servlet-ServletContextListener"><a href="#javax-servlet-ServletContextListener" class="headerlink" title="javax.servlet.ServletContextListener"></a>javax.servlet.ServletContextListener</h5><p>[code lang=java] /*<em> </em> Implementations of this interface receive notifications about changes to the <em> servlet context of the web application they are part of. To receive </em> notification events, the implementation class must be configured in the <em> deployment descriptor for the web application. </em> <em> @see ServletContextEvent </em> @since v 2.3 */ public interface ServletContextListener extends EventListener { [/code]</p><p>참고 :</p><ul><li>[ContextLoaderListener](<a href="http://docs.spring.io/spring/docs/current/javadoc-api/org/springframework/web/context/ContextLoaderListener.html" target="_blank" rel="noopener">http://docs.spring.io/spring/docs/current/javadoc-api/org/springframework/web/context/ContextLoaderListener.html</a>)</li><li>[ServletContextListener](<a href="https://tomcat.apache.org/tomcat-8.5-doc/servletapi/javax/servlet/ServletContextListener.html" target="_blank" rel="noopener">https://tomcat.apache.org/tomcat-8.5-doc/servletapi/javax/servlet/ServletContextListener.html</a>)</li></ul><h4 id="web-xml-설정"><a href="#web-xml-설정" class="headerlink" title="web.xml 설정"></a>web.xml 설정</h4><p>[code lang=xml] <listener> <listener-class>org.springframework.web.context.ContextLoaderListener</listener-class> </listener> [/code]</p><h3 id="ContextLoader"><a href="#ContextLoader" class="headerlink" title="ContextLoader"></a>ContextLoader</h3><h4 id="역할-1"><a href="#역할-1" class="headerlink" title="역할"></a>역할</h4><ol><li>root application context의 실제 초기화 작업을 수행</li><li>web.xml에서 <code>&lt;context-param&gt;</code>을 찾아서 context class type을 구분하여 `contextClass`로 설정.</li><li>web.xml에서 <code>&lt;param-name&gt;contextConfigLocation&lt;/param-name&gt;</code>을 찾아서 context instance의 값으로 전달<ol><li>허용되는 value<ol><li>commas 또는 spaces로 구분되는 여러개의 파일 경로</li><li>Ant-style의 표현식(eg.”<code>WEB-INF/*Context.xml,WEB-INF/spring*.xml</code>“)</li><li>defualt : “<code>/WEB-INF/applicationContext.xml</code>“</li></ol></li><li>다중 값이 적용되기 때문에 순서에 따라 override가 됨.</li></ol></li></ol><p>참고 : <a href="http://docs.spring.io/spring/docs/current/javadoc-api/org/springframework/web/context/ContextLoader.html" target="_blank" rel="noopener">Spring framework javadoc - ContextLoader</a></p><h3 id="How-Tomcat-Load-Spring-detail"><a href="#How-Tomcat-Load-Spring-detail" class="headerlink" title="How Tomcat Load Spring (detail)"></a>How Tomcat Load Spring (detail)</h3><p><img src="https://s3-ap-northeast-1.amazonaws.com/thdghgns/SpringRootWebApplicationContextLoading.svg" alt="How Tomcat Load Spring (detail)"> 링크 : <a href="https://s3-ap-northeast-1.amazonaws.com/thdghgns/SpringRootWebApplicationContextLoading.svg" target="_blank" rel="noopener">How Tomcat Load Spring (detail)</a></p><ol><li>Web Application Server(tomcat)이 DD(web.xml)을 읽어서 Listener(<code>ClassLoaderListener</code>)를 등록</li><li>Web Application Server가 Servlet Context를 생성하면 servlet context 초기화 이벤트(ServletContextEvent)가 발생하고, 이벤트를 <code>ClassLoaderListener</code>가 이벤트를 받아서 <code>contextInitialized()</code>를 실행한다.<ol><li>이때 받은 <code>ServletContextEvent</code>에서 <code>ServletContext</code>를 꺼내고 보면 실제 context는 <code>org.apache.catalina.core.ApplicationContext</code>이다.</li></ol></li><li>현재 <code>context==null</code>이기 떄문에 context를 생성한다.<ol><li>별다른 설정이 없을 경우 <code>XmlWebApplicationContext</code>가 기본.</li></ol></li><li>context가 active가 아니고 root이기 때문에 parent==null이고 parent를 주려고 찾아도 없다.</li><li>ServletContext를 WebApplicationContext의 servlet context로 설정한다.</li><li>에 설정된 contextConfigLocation 설정 파일 위치를 읽어서 <code>StandardServletEnvironment</code>을 생성한다. <code>StandardServletEnvironment</code>는 내부적으로 <code>StandardEnvironment</code>를 확장하고, <code>StandardEnvironment</code>는 내부적으로 <code>AbstractEnvironment</code>를 확장한다.<ol><li>property source를 customize.<ol><li>servletConfigInitParams</li><li>servletContextInitParams</li><li>jndiProperties</li><li>systemProperties</li><li>systemEnvironment</li></ol></li><li>property source를 init(새로 만들고 replace)<ol><li>servletContextInitParams</li></ol></li><li>refresh()<ol><li>refresh 준비<ol><li>active로 변경</li><li>property source를 다시 init</li></ol></li><li>ConfigurableListableBeanFactory 획득. 없으면 생성<ol><li>XmlBeanDefinitionReader<ol><li>environment 설정</li><li>resource loader설정</li><li>entity resolver 설정</li><li>init</li></ol></li><li>reader로 xml resource에서 bean definition을 읽음.</li><li>bean을 읽고</li><li>resource 닫고</li></ol></li><li>postProcessBeanFactory</li><li>invokeBeanFactoryPostProcessors</li><li>registerBeanPostProcessors</li><li>initMessageSource</li><li>initApplicationEvntMulticaster</li><li>onRefresh -&gt; theme 설정</li><li>registerListeners</li><li>finishBeanFactoryInitialization<ol><li>bean 생성</li></ol></li></ol></li><li>Filter 등록<ol><li>등록할 때 <code>StandardServletEnvironment</code>를 다시 customize하면서 property source 다시 설정</li></ol></li><li>DispatcherServlet 등록<ol><li>servletContext 생성</li><li>등록할 때 <code>StandardServletEnvironment</code>를 다시 customize하면서 property source 다시 설정</li></ol></li></ol></li></ol><h2 id="ApplicationContext의-특성"><a href="#ApplicationContext의-특성" class="headerlink" title="ApplicationContext의 특성"></a>ApplicationContext의 특성</h2><h3 id="Application-Context-vs-Bean-Factory"><a href="#Application-Context-vs-Bean-Factory" class="headerlink" title="Application Context vs Bean Factory"></a>Application Context vs Bean Factory</h3><h4 id="역할-및-기능"><a href="#역할-및-기능" class="headerlink" title="역할 및 기능"></a>역할 및 기능</h4><p><img src="https://i.stack.imgur.com/TqcgB.jpg" alt=""></p><ul><li>Bean Factory :<ul><li>Bean instantiation/wiring</li></ul></li><li>Application Context :<ul><li>Bean instantiation/wiring</li><li>Automatic BeanPostProcessor registration</li><li>Automatic BeanFactoryPostProcessor registration</li><li>Convenient MessageSource access (for i18n)</li><li>ApplicationEvent publication</li></ul></li></ul><h3 id="Application-Context-Structure"><a href="#Application-Context-Structure" class="headerlink" title="Application Context Structure"></a>Application Context Structure</h3><p><img src="https://slipp.net/wiki/download/attachments/25527577/ApplicationContext_2.jpg?version=1&amp;modificationDate=1453340947000&amp;api=v2" alt="">### Application Context Inheritance<em> Root Web Application Context : <code>ContextLoader</code>가 생성한 Application Context</em> DispatcherServlet Web Application Context : <code>Root Web Application Context</code>를 부모로 하는 child application context&gt; parent에서는 child를 바라보지 못하고, child는 parent를 바라볼 수 있다.&gt; 그래서 parent는 child context에 정의된 bean을 사용할 수 없고, child는 parent에 정의된 bean을 사용한다. 이때 한 parent에 속하는 child는 parent의 bean을 공유한다.<img src="http://www.deroneriksson.com/deroneriksson-resources/tutorials/java/spring/introduction-to-the-spring-framework/configuring-root-web-application-context-in-spring-web-application/application-context-inheritance.png" alt="Application Context Inheritance">&gt; BeanPostProcessors, BeaFactoryPostProcessors는 child에게 상속되지 않는다. 이유는 scope가 <code>per-container</code>이기 때문이다.<a href="https://docs.spring.io/spring/docs/current/spring-framework-reference/htmlsingle/#beans-factory-extension-bpp" target="_blank" rel="noopener">참고자료 : 7.8.1 Customizing beans using a BeanPostProcessor</a>### Root Web Application Context vs DispatcherServlet Web Application Context일반적으로 Root Applicaion Context에는 Services, DAOs와 같은 bean이 정의되고, DispatcherServlet Web Applicaion Context에는 servlet을 사용하는 Controller bean이 등록된다.<img src="http://www.deroneriksson.com/deroneriksson-resources/tutorials/java/spring/introduction-to-the-spring-framework/configuring-root-web-application-context-in-spring-web-application/root-web-application-context-vs-dispatcherservlet-web-application-context.png" alt="root context vs servlet context"></p><h3 id="Application-Context-Inheritance"><a href="#Application-Context-Inheritance" class="headerlink" title="Application Context Inheritance"></a>Application Context Inheritance</h3><ul><li>Root Web Application Context : <code>ContextLoader</code>가 생성한 Application Context</li><li>DispatcherServlet Web Application Context : Root Web Application Context를 부모로 하는 child application context</li></ul><p>parent에서는 child를 바라보지 못하고, child는 parent를 바라볼 수 있다. 그래서 parent는 child context에 정의된 bean을 사용할 수 없고, child는 parent에 정의된 bean을 사용한다. 이때 한 parent에 속하는 child는 parent의 bean을 공유한다. <img src="http://www.deroneriksson.com/deroneriksson-resources/tutorials/java/spring/introduction-to-the-spring-framework/configuring-root-web-application-context-in-spring-web-application/application-context-inheritance.png" alt=""> BeanPostProcessors, BeaFactoryPostProcessors는 child에게 상속되지 않는다. 이유는 scope가 ‘per-container’이기 때문이다. <a href="https://docs.spring.io/spring/docs/current/spring-framework-reference/htmlsingle/#beans-factory-extension-bpp" target="_blank" rel="noopener">참고자료 : 7.8.1 Customizing beans using a BeanPostProcessor</a></p><h3 id="Root-Web-Application-Context-vs-DispatcherServlet-Web-Application-Context"><a href="#Root-Web-Application-Context-vs-DispatcherServlet-Web-Application-Context" class="headerlink" title="Root Web Application Context vs DispatcherServlet Web Application Context"></a>Root Web Application Context vs DispatcherServlet Web Application Context</h3><p>  일반적으로 Root Applicaion Context에는 Services, DAOs와 같은 bean이 정의되고, DispatcherServlet Web Applicaion Context에는 servlet을 사용하는 Controller bean이 등록된다. <img src="http://www.deroneriksson.com/deroneriksson-resources/tutorials/java/spring/introduction-to-the-spring-framework/configuring-root-web-application-context-in-spring-web-application/root-web-application-context-vs-dispatcherservlet-web-application-context.png" alt=""> 참고자료 : <a href="http://www.deroneriksson.com/tutorial-categories/java/spring/introduction-to-the-spring-framework" target="_blank" rel="noopener">deroneriksson.com</a></p>]]></content>
      
      
      <categories>
          
          <category> 미분류 </category>
          
          <category> spring </category>
          
      </categories>
      
      
    </entry>
    
    <entry>
      <title>스프링 빈이 등록되는 과정(4)</title>
      <link href="/2017/06/22/ec-8a-a4-ed-94-84-eb-a7-81-eb-b9-88-ec-9d-b4-eb-93-b1-eb-a1-9d-eb-90-98-eb-8a-94-ea-b3-bc-ec-a0-954/"/>
      <url>/2017/06/22/ec-8a-a4-ed-94-84-eb-a7-81-eb-b9-88-ec-9d-b4-eb-93-b1-eb-a1-9d-eb-90-98-eb-8a-94-ea-b3-bc-ec-a0-954/</url>
      
        <content type="html"><![CDATA[<p>우리는 지난 포스팅을 통해 xml, java-config 방식의 빈등록 과정을 살펴봤으며 이번시간에는 내용을 정리해보려고 합니다. 예제들은 모두 Spring Boot을 기준으로 진행되었으나 핵심적인 원리는 스프링 모두 같습니다. 스프링이 올라간다는 것은 스프링의 컨텍스트가 올라간다는 건데 스프링 컨텍스트가 올라갈때 factory를 가지게 됩니다. (정확히는 Spring의 <code>ApplicationContext</code>는 <code>BeanFactory</code>를 구현한 구현체입니다, 물론 lazy, pre-loading의 차이점은 있습니다) 스프링은 빈설정에 따라 다르게 진행되는데 java-config인 경우 <code>AnnotationConfigApplicationContext</code>를 통해 동작을 확인해봤습니다. <code>AnnotatedBeanDefinitionReader</code>를 통해 componentScan을 하여 <code>BeanDefinition</code>을 정의하는 것을 확인했습니다. xml도 마찬가지로 <code>BeanDefinition</code>을 정의하는데요. <code>XmlBeanDefinitionReader</code>을 통해 xml파일의 document를 만들어서 진행하는것을 살펴봤습니다 xml, groovy의 경우 <code>ConfigurationClassBeanDefinitionReader</code>를 통해 읽어오는데 <code>ApplicationContext</code>에서 <code>PostProcessorRegistrationDelegate</code>에게 빈등록을 위임하면 딜리게이트가 빈등록을 진행하면서 <code>ConfigurationClassBeanDefinitionReader</code>까지 연결됬었죠 결국 어떤 식으로 설정을 하든 빈등록을 하려면 BeanDefinition으로 정의된 메타데이터를 만들면 되는것입니다. <img src="https://raw.githubusercontent.com/devload/devload.github.io/master/assert/image/fact_spring_bean4/1.png" alt="1"></p>]]></content>
      
      
      <categories>
          
          <category> 미분류 </category>
          
      </categories>
      
      
    </entry>
    
    <entry>
      <title>스프링 빈이 등록되는 과정(3)</title>
      <link href="/2017/06/22/ec-8a-a4-ed-94-84-eb-a7-81-eb-b9-88-ec-9d-b4-eb-93-b1-eb-a1-9d-eb-90-98-eb-8a-94-ea-b3-bc-ec-a0-953/"/>
      <url>/2017/06/22/ec-8a-a4-ed-94-84-eb-a7-81-eb-b9-88-ec-9d-b4-eb-93-b1-eb-a1-9d-eb-90-98-eb-8a-94-ea-b3-bc-ec-a0-953/</url>
      
        <content type="html"><![CDATA[<h1 id="스프링-빈이-등록되는-과정-3"><a href="#스프링-빈이-등록되는-과정-3" class="headerlink" title="스프링 빈이 등록되는 과정(3)"></a>스프링 빈이 등록되는 과정(3)</h1><p>빈의 등록에 순서가 있을까? annotation으로 빈 설정을 하는 경우와 xml로 하는 경우에 있어 빈은 누가 먼저 등록이 되는걸까요? annotation은 componentScan한 패키지에 있는 어노테이션들을 리플랙션을 통해 가져올것이다. 어쨌든 가장 먼저 등록 되는 순서는 무엇일까요? abc순서인가? 또 xml의 경우 가장 위에 선언한 빈이 가장 먼저 등록 되는것일까요? 순서가 있다면 이런 경우는 어떻게 처리가 될까요? 요즘 제가 즐겨보는 TV프로그램중에 알쓸신잡이라고 있는데 참 쓸대없이 궁금합니다 ABean라는 클래스가 빈으로 등록되고 BBean라는 클래스도 빈으로 등록한다고 하죠, 그리고 BBean은 ABean을 inject받는다고 할때 만약 빈이 등록되는 순서가 있고 순서에 의해 BBean을 먼저 등록한다면 BBean에 inject할 ABean이 아직 등록되지 않았는데 어떻게 스프링은 처리를 할까요? [code lang=text] <bean class="ahea.study.BBean"> <property name="ABean"> <ref bean="aBean"></ref> </property> </bean> <bean class="ahea.study.ABean" id="aBean"></bean> [/code] xml을 다음처럼 넣어놨습니다. BBean을 먼저 선언하고 그 뒤에 ABean을 선언했습니다. 과연 스프링은 BBean을 빈으로 등록하면서 ABean이 아직 등록이 안됬다고 에러를 뱉을까요? 아니면 에러없이 잘 동작할까요? 우선 빈의 등록이 당연히 정상적으로 처리되는 설정을 실행해보려고 합니다 [code lang=text] <bean class="ahea.study.ABean" id="aBean"></bean> <bean class="ahea.study.BBean"> <property name="ABean"> <ref bean="aBean"></ref> </property> </bean> [/code] 그리고 각 빈들에 static과 생성자에 로그를 찍어놨습니다 [code lang=java] public class ABean { static { System.out.println(“ABean static init”); } public ABean() { System.out.println(“ABean init”); } } [/code] [code lang=java] public class BBean { static { System.out.println(“BBean static init”); } public BBean() { System.out.println(“BBean init”); } private ABean aBean; public void setABean(ABean aBean) { System.out.println(“aBean set”); this.aBean = aBean; } } [/code] 이렇게 실행하면 스프링 로그를 포함해서 이런식으로 실행결과가 로그로 나오게 됩니다 [code lang=text] [main] DefaultListableBeanFactory : Creating shared instance of singleton bean ‘aBean’ [main] DefaultListableBeanFactory : Creating instance of bean ‘aBean’ ABean static init ABean init [main] DefaultListableBeanFactory : Eagerly caching bean ‘aBean’ to allow for resolving potential circular references [main] DefaultListableBeanFactory : Finished creating instance of bean ‘aBean’ [main] DefaultListableBeanFactory : Creating shared instance of singleton bean ‘ahea.study.BBean#0’ [main] DefaultListableBeanFactory : Creating instance of bean ‘ahea.study.BBean#0’ BBean static init BBean init [main] DefaultListableBeanFactory : Eagerly caching bean ‘ahea.study.BBean#0’ to allow for resolving potential circular references [main] DefaultListableBeanFactory : Returning cached instance of singleton bean ‘aBean’ aBean set [main] DefaultListableBeanFactory : Finished creating instance of bean ‘ahea.study.BBean#0’ [/code] 우리가 실행시키는 BeanFactory는. DefaultListableBeanFactory인가봅니다. xml의 순서대로 aBean부터 객체를 생성하는군요. static - 생성자 순서대로 로그가 찍히게 됩니다. 그리고 <code>Finished creating instance of bean &#39;aBean&#39;</code>이라는 로그를 찍으면서 ABean등록을 완료합니다 마찬가지로 BBean객체 생성을 진행하는데요. ABean의 진행과 같지만 property를 inject해주기 위해 singleton빈으로 이미 등록이 된 ABean을 리턴한다는 로그가 찍히는것을 볼수 있네요, 그리고 setter에 찍은 로그가 찍히네요. 로그를 자세히 보진 않았지만 대충 봐도 이정도는 알만합니다. <em>ABean 등록 - BBean 등록 - BBean등록할 때 ABean을 inject</em> 순으로 진행된다 이거죠~ 우리가 궁금한것은 이것입니다, 빈등록 순서를 바꾸면 위에 순서가 이렇게 바뀔텐데요 <em>BBean 등록 - BBean등록할 때 ABean을 inject - ABean 등록</em> 두번째 과정에서 ABean을 inject해야 하지만 아직 등록이 안됬는데? 에러가 떨어질지, 아니면 처리를 어떻게든 해줄지 궁금합니다 순서를 바꿔서 실행하겠습니다 [code lang=text] <bean class="ahea.study.BBean"> <property name="ABean"> <ref bean="aBean"></ref> </property> </bean> <bean class="ahea.study.ABean" id="aBean"></bean> [/code] 실행결과를 보겠습니다 [code lang=text] [main] DefaultListableBeanFactory : Creating shared instance of singleton bean ‘ahea.study.BBean#0’ [main] DefaultListableBeanFactory : Creating instance of bean ‘ahea.study.BBean#0’ BBean static init BBean init [main] DefaultListableBeanFactory : Eagerly caching bean ‘ahea.study.BBean#0’ to allow for resolving potential circular references [main] DefaultListableBeanFactory : Creating shared instance of singleton bean ‘aBean’ [main] DefaultListableBeanFactory : Creating instance of bean ‘aBean’ ABean static init ABean init [main] DefaultListableBeanFactory : Eagerly caching bean ‘aBean’ to allow for resolving potential circular references [main] DefaultListableBeanFactory : Finished creating instance of bean ‘aBean’ aBean set [main] DefaultListableBeanFactory : Finished creating instance of bean ‘ahea.study.BBean#0’ [main] DefaultListableBeanFactory : Returning cached instance of singleton bean ‘aBean’ [/code] 우선 실행은 아주 잘됩니다… 우선 빈의 등록 순서를 바꾸면서 어떤 빈부터 객체생성을 하는지 보니 순서를 바꾸면서 먼저 써놓은, 즉 xml의 위에서부터 빈등록을 시작한다는 것을 알게 되었습니다(그렇군요…) 그리고 BBean이 등록이 될때 inject가 되냐 안되냐 부분은 어떻게 되는지 로그를 통해 보도록 하죠, 우선 BBean이 먼저 등록이 됩니다, static이 먼저 호출되고 생성자가 호출되는 로그를 통해 알수 있죠, 그리고 ABean을 inject해줘야 하는데 없으니 ABean을 만들기 시작합니다. 그리고 그 빈을 inject해주네요 실제 코드를 확인해봐야겠습니다. DefaultListableBeanFactory의 부모 클래스중에 AbstractAutowireCapableBeanFactory가 있습니다. <code>Eagerly caching bean &#39;aBean&#39; to allow for resolving potential circular references</code> 라고 찍히는 로그는 여기서 찍히게 되는데요.. [code lang=java] boolean earlySingletonExposure = mbd.isSingleton() &amp;&amp; this.allowCircularReferences &amp;&amp; this.isSingletonCurrentlyInCreation(beanName); if(earlySingletonExposure) { if(this.logger.isDebugEnabled()) { this.logger.debug(“Eagerly caching bean ‘“ + beanName + “‘ to allow for resolving potential circular references”); } this.addSingletonFactory(beanName, new ObjectFactory<object>() { public Object getObject() throws BeansException { return AbstractAutowireCapableBeanFactory.this.getEarlyBeanReference(beanName, mbd, bean); } }); } [/code] 로그를 찍고 나서 다음에 하는 행동이 addSingletonFactory를 통해 팩토리에 등록을 합니다. 팩토리에 빈을 등록하는 객체는 <code>getEarlyBeanReference()</code>을 호출하게 되는데요, <code>getEarlyBeanReference</code>를 레퍼런스에서 찾아보니 이렇게 설명하고 있습니다 [code lang=text] Obtain a reference for early access to the specified bean, typically for the purpose of resolving a circular reference. [/code] 영어 울렁증이 오지만 대충 읽어보면 빈의 순환구조를 맞춰주려고 하는녀석인가봅니다. 실제 메소드를 확인해보면 빈을 등록하기 위해 BeanPostProcessor가 있는것을 볼수 있습니다. 결국 순서가 빈등록의 문제를 발생시키지 않는다는 것을 알 수 있었습니다.</object></p>]]></content>
      
      
      <categories>
          
          <category> spring </category>
          
      </categories>
      
      
    </entry>
    
    <entry>
      <title>스프링 빈이 등록되는 과정(2)</title>
      <link href="/2017/06/22/ec-8a-a4-ed-94-84-eb-a7-81-eb-b9-88-ec-9d-b4-eb-93-b1-eb-a1-9d-eb-90-98-eb-8a-94-ea-b3-bc-ec-a0-952/"/>
      <url>/2017/06/22/ec-8a-a4-ed-94-84-eb-a7-81-eb-b9-88-ec-9d-b4-eb-93-b1-eb-a1-9d-eb-90-98-eb-8a-94-ea-b3-bc-ec-a0-952/</url>
      
        <content type="html"><![CDATA[<h1 id="스프링-빈이-등록되는-과정-2"><a href="#스프링-빈이-등록되는-과정-2" class="headerlink" title="스프링 빈이 등록되는 과정(2)"></a>스프링 빈이 등록되는 과정(2)</h1><p>1편에서는 Spring Boot을 기반으로 스프링이 빈을 어떻게 등록하는지 알아봤습니다 아주 기본적으로는 <code>AnnotationConfigApplicationContext</code>에 대해 알아봤는데요 그 안에 있는 <code>AnnotatedBeanDefinitionReader</code>를 통해 진행하며 그 안에 <code>doScan</code>메소드를 살펴보며 빈을 등록하는 과정을 살펴봤습니다 이번에는 xml기반인 경우 어떻게 진행이 되는지 알아보겠습니다</p><h2 id="XmlBeanDefinitionReader"><a href="#XmlBeanDefinitionReader" class="headerlink" title="XmlBeanDefinitionReader"></a>XmlBeanDefinitionReader</h2><p>spring은 xml기반의 빈등록을 하기 위해 <code>XmlBeanDefinitionReader</code>라는 녀석을 통해 진행하게 됩니다. <code>XmlBeanDefinitionReader</code>는 <code>AbstractBeanDefinitionReader</code>를 상속받고 있는데요. 어노테이션 기반에 사용되었던 <code>AnnotatedBeanDefinitionReader</code>도 이것을 상속받나? 했지만 <code>AbstractBeanDefinitionReader</code>는 상속받는 클래스가 없습니다. 왜일까요?? 어노테이션으로 등록하려는 빈들은 이미 클래스로더에서 꺼내올수 있기 때문이 아닐까 추측하지만 정답은 모르겠습니다 <code>AbstractBeanDefinitionReader</code>를 상속받는 클래스는 <code>GroovyBeanDefinitionReader</code>, <code>PropertiesBeanDefinitionReader</code>, <code>XmlBeanDefinitionReader</code>가 있습니다. 모두 리소스를 접근해야 하는 부분인데 이런 경우에는 <code>AbstractBeanDefinitionReader</code>를 상속받나 봅니다. 나중에 기회가 되면 RMI를 이용한 빈등록을 만들어보거나 위에 타입과 다른 경우의 빈등록 형식을 만들어보는것도 좋을거 같네요. 우선 Spring이 <code>XmlBeanDefinitionReader</code>에게 bean을 읽어오기 위한 과정부터 얘기해보려고 합니다 스프링은 컨텍스트가 생성되면서 <code>refresh</code>를 명령합니다. 그러면 이때 <code>ApplicatioContext</code>는 설정들을 다시 뒤지기 시작합니다. 그러면 최하위 <code>ApplicationContext</code>부터 자신이 해야할 <code>refresh</code>동작을 처리 한뒤 상위 <code>refresh</code>를 호출하게 되죠, 그러면 언젠가 <code>AbstractApplicationContext</code>에까지 <code>refresh</code>명령이 오게 됩니다. 이때 <code>AbstractApplicationContext</code>는 <code>invokeBeanFactoryPostProcessors</code>메소드를 호출하게 되는데 <code>invokeBeanFactoryPostProcessors</code>에서는 <code>PostProcessorRegistrationDelegate</code>라는 딜리게이트에게 빈등록을 위임하게 됩니다. 그러면 이 딜리게이트는 <code>BeanFactoryPostProcessor</code>리스트를 만들게됩니다. <code>BeanFactoryPostProcessor</code>라는 것은 <code>BeanPostProcessor</code>와 같이 빈 등록에 관여하는 녀석인데 다음에 아주 자세하게 살펴보도록 하겠습니다. 어쨋든 <code>BeanPostProcessor</code>에 <code>BeanDefinitionRegistry</code>를 넘겨주면서 <code>BeanFactoryPostProcessor</code>의 <code>postProcessBeanDefinitionRegistry()</code>메소드로 넘어가게 됩니다. Spring Boot의 경우 <code>BeanPostProcessor</code>는 <code>ConfigurationClassPostProcessor</code>로 되어 있는데요. 여기서 호출된 <code>postProcessBeanDefinitionRegistry</code>메소드에서는 파라미터로 넘어온 <code>BeanDefinitionRegistry</code>정보를 <code>BeanDefinitionHolder</code>로 바꾸는 작업을 먼저 진행하고 그후 <code>ConfigurationClassBeanDefinitionReader</code>를 통해 <code>BeanDefiniton</code>을 읽도록 처리를 진행하게 됩니다. <code>ConfigurationClassBeanDefinitionReader</code>에서는 <code>BeanDefinitionReader</code>를 고르는 작업을 진행하는데 <code>groovy</code> 또는 <code>xml</code>만 받게 되는거 같습니다. xml의 설정의 경우 <code>XmlBeanDefinitionReader</code>가 생성되어 결국 <code>XmlBeanDefinitionReader</code>의 <code>loadBeanDefinitions</code>가 호출되게 됩니다. <img src="https://raw.githubusercontent.com/devload/devload.github.io/master/assert/image/fact_spring_bean2/1.png" alt="1"> <code>SpringApplication</code>에서 <code>XmlBeanDefinitionReader</code>로 오는 호출 과정을 보면 다음과 같습니다 <img src="https://raw.githubusercontent.com/devload/devload.github.io/master/assert/image/fact_spring_bean2/2.png" alt="2"> <code>XmlBeanDefinitionReader</code>에서는 <code>loadBeanDefinitions</code>메소드가 호출됨으로 시작합니다 <code>Resource</code>타입으로 받은 파라미터를 기준으로 <code>doLoadBeanDefinitions</code>가 호출될때까지 <code>Resource</code>를 가공합니다 <code>doLoadBeanDefinitions</code>에서는 xml을 파싱하기 위해 Document로 만들어 registerBeanDefinitions로 넘기게 되며 BeanDefinitionDocumentReader를 통해 빈등록을 진행하게 됩니다</p>]]></content>
      
      
      <categories>
          
          <category> 미분류 </category>
          
      </categories>
      
      
    </entry>
    
    <entry>
      <title>스프링 빈이 등록되는 과정(1)</title>
      <link href="/2017/06/11/1203/"/>
      <url>/2017/06/11/1203/</url>
      
        <content type="html"><![CDATA[<h1 id="BeanDefinition"><a href="#BeanDefinition" class="headerlink" title="BeanDefinition"></a>BeanDefinition</h1><p>Spring의 빈설정은 대표적으로 xml과 java config(annotation)으로 구성되어 있습니다. 하지만 이말은 사실은 BeanDefinition으로 추상화되어 있는 빈설정을 xml, java config로 표현하고 있다고 말할수 있습니다. BeanDefinition은 다음과 같이 사용할 수 있습니다 [code lang=java] BeanDefinition helloDef = new RootBeanDefinition(Sample.class); helloDef.getPropertyValues().addPropertyValue(“name”,”Spring”); applicationContext.registerBeanDefinition(“hello2”, helloDef); [/code] 저는 Spring Boot에서 Unit Test를 통해 코드를 돌려보려고 합니다 제가 작성한 코드는 다음과 같습니다 [code lang=java] @RunWith(SpringRunner.class) @SpringBootTest public class DemoApplicationTest { @Autowired ApplicationContext applicationContext; @Test public void difinitionTest() { BeanDefinition helloDef = new RootBeanDefinition(Sample.class); helloDef.getPropertyValues().addPropertyValue(“name”,”Spring”); applicationContext.registerBeanDefinition(“hello2”, helloDef); System.out.println(applicationContext.getBean(“hello2”)); } } [/code] 이렇게 작성했을경우 컴파일 에러가 나게 됩니다 [code lang=java] applicationContext.registerBeanDefinition(“hello2”, helloDef); [/code] applicationContext는 <code>registerBeanDefinition</code>이라는 메소드가 없던 것입니다. registerBeanDefinition메소드가 가능한 applicationContext는 제가 기본적으로 알고 있던 것이 StaticApplicationContext입니다. StaticApplicationContext의 소스를 열어보면서 확인해보니 GenericApplicationContext라는 상위 클래스에 정의되어 있는 것을 알수 있습니다. 우리가 처음에 시도한 ApplicationContext의 경우 GenericApplicationContext의 상위 클래스입니다. 적어도 우리는 GenericApplicationContext를 상속받는 실제 구현체로 선언해야 하는거죠.. 물론 GenericApplicationContext로 타입을 주어도 상관 없지만 Spring Boot는 어떤 구현체를 사용하는 알고 싶어졌습니다. [code lang=java] @Test public void applicationContexTypeTest() { System.out.println(“applicationContext “ + applicationContext ); System.out.println(“applicationContext “ + applicationContext.getClass()); } [/code] [code lang=text] . <strong>__ _ </strong> _ _ /\\ / <strong>_’_ </strong> _ _(_)_ <strong> </strong> _ \ \ \ \ ( ( )\<strong>_ | ‘_ | ‘<em>| | ‘</em> \/ _` | \ \ \ \ \\/ _</strong>)| |<em>)| | | | | || (</em>| | ) ) ) ) ‘ |<strong>__| .</strong>|<em>| |</em>|<em>| |</em>\<strong>, | / / / / =========|<em>|==============|</em></strong>/=/_/_/_/ :: Spring Boot :: (v1.5.4.RELEASE) 2017-06-11 18:02:06.280 INFO 7204 — [ main] com.ahea.spring.DemoApplicationTest : Starting DemoApplicationTest on Nohui-MacBook-Pro.local with PID 7204 (started by nohsunghyun in /Users/nohsunghyun/Downloads/BeanDefinition) 2017-06-11 18:02:06.281 INFO 7204 — [ main] com.ahea.spring.DemoApplicationTest : No active profile set, falling back to default profiles: default 2017-06-11 18:02:06.301 INFO 7204 — [ main] s.c.a.AnnotationConfigApplicationContext : Refreshing org.springframework.context.annotation.AnnotationConfigApplicationContext@43bc63a3: startup date [Sun Jun 11 18:02:06 KST 2017]; root of context hierarchy 2017-06-11 18:02:06.621 INFO 7204 — [ main] com.ahea.spring.DemoApplicationTest : Started DemoApplicationTest in 10.587 seconds (JVM running for 11.171) applicationContext org.springframework.context.annotation.AnnotationConfigApplicationContext@43bc63a3: startup date [Sun Jun 11 18:02:06 KST 2017]; root of context hierarchy applicationContext class org.springframework.context.annotation.AnnotationConfigApplicationContext 2017-06-11 18:02:06.655 INFO 7204 — [ Thread-2] s.c.a.AnnotationConfigApplicationContext : Closing org.springframework.context.annotation.AnnotationConfigApplicationContext@43bc63a3: startup date [Sun Jun 11 18:02:06 KST 2017]; root of context hierarchy [/code] ApplicationContext객체의 클래스 타입을 찍어보니 <code>AnnotationConfigApplicationContext</code>인것을 알수 있습니다. <code>ApplicationContext</code>타입을 <code>AnnotationConfigApplicationContext</code>로 변경후 테스트를 다음과 같이 진행하였습니다 [code lang=text] @Autowired AnnotationConfigApplicationContext applicationContext; @Test public void difinitionTest() { BeanDefinition helloDef = new RootBeanDefinition(Sample.class); helloDef.getPropertyValues().addPropertyValue(“name”,”Spring”); applicationContext.registerBeanDefinition(“hello2”, helloDef); System.out.println(applicationContext.getBean(“hello2”)); } [/code] [code lang=text] 결과 Sample{name=’Spring’} [/code]</p><h1 id="AnnotationConfigApplicationContext"><a href="#AnnotationConfigApplicationContext" class="headerlink" title="AnnotationConfigApplicationContext"></a>AnnotationConfigApplicationContext</h1><p>[code lang=java] @SpringBootApplication public class DemoApplication { public static void main(String[] args) { SpringApplication.run(DemoApplication.class, args); } } [/code] 이 코드는 SpringBoot Application을 시작하기 위한 코드입니다. 저는 spring 2.5부터 시작을 했었는데 기존에는 web.xml에 리스너를 통해 스프링 컨텍스트를 올렸죠. 스프링 부트를 모르시는 분들은 그 설정없이 위에 코드가 그 부분이라고 생각하셔도 좋겠네요. <code>SpringApplication</code>을 들어가보면 쉽게 AnnotationConfigApplicationContext를 찾을수 있습니다 [code lang=Java] protected ConfigurableApplicationContext createApplicationContext() { Class&lt;?&gt; contextClass = this.applicationContextClass; if(contextClass == null) { try { contextClass = Class.forName(this.webEnvironment?”org.springframework.boot.context.embedded.AnnotationConfigEmbeddedWebApplicationContext”:”org.springframework.context.annotation.AnnotationConfigApplicationContext”); } catch (ClassNotFoundException var3) { throw new IllegalStateException(“Unable create a default ApplicationContext, please specify an ApplicationContextClass”, var3); } } return (ConfigurableApplicationContext)BeanUtils.instantiate(contextClass); } [/code] 중간 코드를 보면 contextClass 가 <code>AnnotationConfigEmbeddedWebApplicationContext</code> 또는 <code>AnnotationConfigApplicationContext</code>가 webEnviroment의 값에 따라 나뉘어지게 되는군요.. 둘다 뭐가 어쨌든 어노테이션 기반 어플리케이션 컨텍스트인거 같습니다. <code>AnnotationConfigApplicationContext</code>에 대해 조금 더 알아보겠습니다. <code>AnnotationConfigApplicationContext</code>의 코드를 열어보면 다음과 같은 프로퍼티가 있습니다 [code lang=text] private final AnnotatedBeanDefinitionReader reader; private final ClassPathBeanDefinitionScanner scanner; [/code] 해당 클래스에서 reader가 하는 것들을 모아봤습니다 [code lang=text] this.reader.setEnvironment(environment); this.reader.setBeanNameGenerator(beanNameGenerator); this.reader.setScopeMetadataResolver(scopeMetadataResolver); this.reader.register(annotatedClasses); [/code]</p><ul><li>환경설정인걸까요?</li><li>빈 네임 제너레이터를 set해주는 것도 있습니다</li><li>메타데이터 리졸버라는 것이 있네요?</li><li>어노테이션 클래스를 register하고 있습니다</li></ul><p>reader의 메소드 명은 <code>AnnotatedBeanDefinitionReader</code>인데요. 어노테이션으로 된 beanDefinition 리더 라고 이름이 지어져 있습니다. <code>BeanDefinition</code>은 이번 포스팅에 가장 처음 나온 이야기였는데요. 이름으로 추측하건데 어노테이션으로 된 <code>BeanDefinition</code>을 읽어오는 녀석인거 같습니다. scanner는 어떤지 보겠습니다 [code lang=text] this.scanner.setEnvironment(environment); this.scanner.setBeanNameGenerator(beanNameGenerator); this.scanner.setScopeMetadataResolver(scopeMetadataResolver); this.scanner.clearCache(); this.scanner.scan(basePackages); [/code] 위에 3개는 reader와 같은 일을 하나 봅니다 새로운 것이 밑에 두개인데요 scanner.clearCache는 무엇인지 쫒아 들어가보면 [code lang=text] private final Map&lt;Resource, MetadataReader&gt; metadataReaderCache = new LinkedHashMap&lt;Resource, MetadataReader&gt;(256, 0.75F, true) { protected boolean removeEldestEntry(Entry&lt;Resource, MetadataReader&gt; eldest) { return this.size() &gt; CachingMetadataReaderFactory.this.getCacheLimit(); } }; [/code] 이런 코드가 있습니다. 때려 맞춰보건데 scanner는 메타데이터를 캐싱처리하며 들고 있고 이것을 클리어 할수 있도록 메소드를 제공해주고 있습니다. scan은 파라미터로 넘기려는 변수명부터가 아주 친숙합니다. ComponentScan할때 basePackage를 주죠. ComponentScan이 이때 이녀석을 통해 일어나는지 확인해보고 싶겠죠??? [code lang=text] public int scan(String… basePackages) { int beanCountAtScanStart = this.registry.getBeanDefinitionCount(); this.doScan(basePackages); if(this.includeAnnotationConfig) { AnnotationConfigUtils.registerAnnotationConfigProcessors(this.registry); } return this.registry.getBeanDefinitionCount() - beanCountAtScanStart; } [/code] 우선 scan의 리턴 타입은 int인데요, 이 값으로 어떤 처리를 하려는지는 더 분석해봐야 겠습니다. 스캔을 호출하는 <code>AnnotationConfigApplicationContext</code>에서는 리턴값을 받아놓지 않아서요… 우리는 <code>ComponentScan</code>과의 관계, 즉 <code>basePackages</code>값에 있는 어노테이션을 빈으로 등록해주는가를 찾아가보도록 하겠습니다 세번째 줄에 <code>doScan(basePackages)</code>를 호출하는데 굉장히 의심스럽습니다. 타고 들어가보면 다음 소스인데요 [code lang=text] protected Set doScan(String… basePackages) { Assert.notEmpty(basePackages, “At least one base package must be specified”); Set beanDefinitions = new LinkedHashSet(); String[] var3 = basePackages; int var4 = basePackages.length; for(int var5 = 0; var5 &lt; var4; ++var5) { String basePackage = var3[var5]; Set candidates = this.findCandidateComponents(basePackage); Iterator var8 = candidates.iterator(); while(var8.hasNext()) { BeanDefinition candidate = (BeanDefinition)var8.next(); ScopeMetadata scopeMetadata = this.scopeMetadataResolver.resolveScopeMetadata(candidate); candidate.setScope(scopeMetadata.getScopeName()); String beanName = this.beanNameGenerator.generateBeanName(candidate, this.registry); if(candidate instanceof AbstractBeanDefinition) { this.postProcessBeanDefinition((AbstractBeanDefinition)candidate, beanName); } if(candidate instanceof AnnotatedBeanDefinition) { AnnotationConfigUtils.processCommonDefinitionAnnotations((AnnotatedBeanDefinition)candidate); } if(this.checkCandidate(beanName, candidate)) { BeanDefinitionHolder definitionHolder = new BeanDefinitionHolder(candidate, beanName); definitionHolder = AnnotationConfigUtils.applyScopedProxyMode(scopeMetadata, definitionHolder, this.registry); beanDefinitions.add(definitionHolder); this.registerBeanDefinition(definitionHolder, this.registry); } } } return beanDefinitions; } [/code] 코드를 쭉 살펴보면 <code>Set candidates = this.findCandidateComponents(basePackage)</code>가 있는데요 리턴 타입이 BeanDefinition을 Set으로 주는걸 보니 이부분을 잘 봐야 겠습니다. <code>findCandidateComponents(basePackage)</code>를 호출하면 basePackage에 있는 빈을 주는건 아닐까요? 안으로 들어가보면 [code lang=text] LinkedHashSet candidates = new LinkedHashSet(); . . MetadataReader metadataReader = this.metadataReaderFactory.getMetadataReader(resource); if(resource.isReadable()) { try { MetadataReader metadataReader = this.metadataReaderFactory.getMetadataReader(resource); if(this.isCandidateComponent(metadataReader)) { ScannedGenericBeanDefinition sbd = new ScannedGenericBeanDefinition(metadataReader); sbd.setResource(resource); sbd.setSource(resource); if(this.isCandidateComponent((AnnotatedBeanDefinition)sbd)) { if(debugEnabled) { this.logger.debug(“Identified candidate component class: “ + resource); } candidates.add(sbd); } else if(debugEnabled) { this.logger.debug(“Ignored because not a concrete top-level class: “ + resource); } } else if(traceEnabled) { this.logger.trace(“Ignored because not matching any filter: “ + resource); } } catch (Throwable var13) { throw new BeanDefinitionStoreException(“Failed to read candidate component class: “ + resource, var13); } } else if(traceEnabled) { this.logger.trace(“Ignored because not readable: “ + resource); } [/code] 해당 코드에서는 <code>this.isCandidateComponent(metadataReader)</code> 조건에 따라 ScannedGenericBeanDefinition는 생성하여 Set에 담아주는것을 볼수 있습니다 코드를 쫒아와서 이부분인가? 싶은곳을 이렇게 발견했지만 실제 여기 맞는지 검증을 해보려고 합니다 우선 Application에 ComponentScan을 추가하고 패키지를 줬습니다 [code lang=text] @SpringBootApplication @ComponentScan(basePackages = “com.ahea.spring”) public class DemoApplication { public static void main(String[] args) { SpringApplication.run(DemoApplication.class, args); } } [/code] 그리고 패키지 안에 HomeController라고 하나 만들어놓고 @Controller어노테이션을 줘봤습니다 [code lang=text] @Controller public class HomeContoller { } [/code] 그리고 마지막으로 findCandidateComponents에 중단점을 찍은 후 디버그 모드로 돌려봤습니다. 결과는 basePackage라는 파라미터에는 ComponentScan에 넣어준 basePackages값이 있었으며 <img src="https://ahea.files.wordpress.com/2017/06/e18489e185b3e1848fe185b3e18485e185b5e186abe18489e185a3e186ba-2017-06-11-e1848be185a9e18492e185ae-11-19-04.png?w=300" alt="img2"> 리턴값인 candidates 에는 HomeController가 정의된 BeanDefinition이 들어 있는것을 확인할수 있었습니다. <img src="https://ahea.files.wordpress.com/2017/06/e18489e185b3e1848fe185b3e18485e185b5e186abe18489e185a3e186ba-2017-06-11-e1848be185a9e18492e185ae-11-19-58.png?w=300" alt="img1"> 다시 돌아와서 doScan에서는 위에 내용과 같이 ComponentScan하여 나온 빈정보들을 가지고 registerBeanDefinition를 통해 ApplicationContext에 등록하게 됩니다. [code lang=text] if(this.checkCandidate(beanName, candidate)) { BeanDefinitionHolder definitionHolder = new BeanDefinitionHolder(candidate, beanName); definitionHolder = AnnotationConfigUtils.applyScopedProxyMode(scopeMetadata, definitionHolder, this.registry); beanDefinitions.add(definitionHolder); this.registerBeanDefinition(definitionHolder, this.registry); } [/code] 하나 흥미로운 점은 Bean 객체나 BeanDefinition을 등록하는것이 아니라 BeanDefinitionHolder에 한번 감싸서 등록하는데요. AnnotationConfigUtils.applyScopedProxyMode를 통해 프록시모드 처리를 진행하는 코드를 확인할 수 있었습니다. 프록시 설정에 따라 스프링에서 프록시 객체를 만드는 법을 확인해 볼수 있는데요. 추후에 이부분도 진행하겠습니다</p>]]></content>
      
      
      
        <tags>
            
            <tag> spring </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>ahea study - 20170527 스터디 모임</title>
      <link href="/2017/05/29/ahea-study-20170527-ec-8a-a4-ed-84-b0-eb-94-94-eb-aa-a8-ec-9e-84/"/>
      <url>/2017/05/29/ahea-study-20170527-ec-8a-a4-ed-84-b0-eb-94-94-eb-aa-a8-ec-9e-84/</url>
      
        <content type="html"><![CDATA[<p>2회 공개세미나를 하기전에 스터디 원들이 모여서 각자 진척상황과 스터디 피드백을 하기 위해 강남역에서 모임을 가졌습니다. 간단하게 Ahea 소개를 하자면 저희는 하고싶은 주제를 스스로 정해서, 꾸준히 스터디를 하며 정기적으로 모임을 가지고 있습니다. 현재 실무에서 개발하고있는 개발자, 개발자를 하고싶어하는 학생과 함께 진행하고있습니다. 기술 스펙은 back-end 부터 android, big-data 까지 다양하게 존재하고 있습니다. = 각자 스터디 발표 전에 열심히 자료를 정리하고 있는 모습입니다. <img src="https://ahea.files.wordpress.com/2017/05/kakaotalk_20170529_111619059.jpg" alt="KakaoTalk_20170529_111619059">   = 카페에서 스터디에 대한 피드백을 주고 있는 모습입니다. 이때 피드백을 받으면서 어떤 부분을 더 설명했으면 좋겟다던지 피드백을 진행합니다. <img src="https://ahea.files.wordpress.com/2017/05/kakaotalk_20170529_111618334.jpg" alt="KakaoTalk_20170529_111618334">   = 스포를 하자면 노성현님의 주제이기도 한 java jigsaw!! <img src="https://ahea.files.wordpress.com/2017/05/kakaotalk_20170529_111638123.jpg" alt="KakaoTalk_20170529_111638123">   이날 스터디한 것들은 모두 리뷰 했습니다. 제일 놀라웠던건 이번에 새로 들어오신 분의 ‘스프링의 로드되는 과정’ 이었는데, 자료를 보자마자 다들 ‘와’ 감탄사를 냈습니다. 그만큼 퀄리티가 좋았고 많은것을 배웠습니다. = 리뷰가 끝난 후 맛있는것도 먹고 <img src="https://ahea.files.wordpress.com/2017/05/kakaotalk_20170529_111617611.jpg" alt="KakaoTalk_20170529_111617611"> 이번 제 2회 공개세미나는 1회보다 더 많은 피드백과 다양한 주제가 될것 같습니다. 계획으로는 6월 말에서 7월 초가 될 것 같습니다. 다음 발표는 어떻게 진행될지 궁금해지네요~</p>]]></content>
      
      
      <categories>
          
          <category> 스터디 모임 </category>
          
      </categories>
      
      
    </entry>
    
    <entry>
      <title>자바개발자가 알아야 할 jvm과 garbage collection - 1</title>
      <link href="/2017/05/25/ec-9e-90-eb-b0-94-ea-b0-9c-eb-b0-9c-ec-9e-90-ea-b0-80-ec-95-8c-ec-95-84-ec-95-bc-ed-95-a0-jvm-ea-b3-bc-garbage-collection/"/>
      <url>/2017/05/25/ec-9e-90-eb-b0-94-ea-b0-9c-eb-b0-9c-ec-9e-90-ea-b0-80-ec-95-8c-ec-95-84-ec-95-bc-ed-95-a0-jvm-ea-b3-bc-garbage-collection/</url>
      
        <content type="html"><![CDATA[<p>자바 바이트코드는 JRE 위에서 동작합니다.</p><p><img src="https://ahea.files.wordpress.com/2017/05/1.jpg" alt="1.png"></p><p>JRE는 자바 API와 JVM으로 구성되며, JVM의 역할은 자바 애플리케이션을 클래스 로더(Class Loader)를 통해 읽어 들여서 자바 API와 함께 실행하는 것입니다.</p><p>이 JRE에서 가장 중요한 요소는 자바 바이트코드를 해석하고 실행하는 JVM(Java Virtual Machine)입니다.</p><p>- jvm architecture -</p><p><img src="https://ahea.files.wordpress.com/2017/05/11.png" alt="1.png"></p><p>Execution Engine은 Load된 Class의 ByteCode를 실행하는 역할.</p><p>JVM의 특징 중 하나는 가비지 컬렉션입니다.</p><ul><li>가비지 컬렉션(garbage collection): 클래스 인스턴스는 사용자 코드에 의해 명시적으로 생성되고 가비지 컬렉션에 의해 자동으로 파괴된다.</li></ul><p>C와 Java의 차이점 중 하나인 가바지 컬렉션은 사용자가 메모리에 대해 신경 쓸 필요없이 가비지 컬렉션이 자동으로 관리해주는 역할을 합니다.</p><p>gc는 댕글러 포인터 때문에  필요합니다.</p><p>a -&gt; b -&gt; c 위와 같은 참조관계의 객체가 있다고 했을때,</p><p>b가 삭제되면 유효한 객체 A는 댕글링 포인터를 가집니다. c를 차지하는 부분은 누수가 발생해서, c는 접근할수도 해제 할수도 없습니다.</p><p>가비지 컬렉션은 어떤 가설을 가지고 동작됩니다.</p><p>세대 컬럭터는 대부분의 객체는 일찍죽는다라는 가설 바탕으로 (weak gerenation hypothises 은 프로그래밍 패러다임이나 구현언어에 관계없이 인정됨..)</p><p>어른 객체들의 회수에 노력을 집중함으로 최소한의 노력으로 최대한의 수율을 얻고자 시도하고</p><p>세대 컬렉터는 객체들을 나이에 따라 세대로 분리하고 별개의 영역에 배치합니다.</p><p>새대 컬렉터도 가끔은 힙 전체를 수집해야합니다.</p><p>긴 수명의 객체를 반복적으로 처리하지 않기 때문에 처리량을 향상 시킵니다.</p><p><img src="https://ahea.files.wordpress.com/2017/05/21.png" alt="2"></p><p>위에 그림은 오라클 홈페이지에 나와있는 그림이고, 그림은 객체의 수명에 대한 일반적인 분포인데 처음에 많은 객체가 할당되지만 ‘die young’한것을 확인 할 수 있습니다.</p><p>출처 : <a href="http://docs.oracle.com/javase/8/docs/technotes/guides/vm/gctuning/generations.html#sthref16" target="_blank" rel="noopener">http://docs.oracle.com/javase/8/docs/technotes/guides/vm/gctuning/img_text/jsgct_dt_003_alc_vs_srvng.html</a></p><p>그럼 이 가비지 컬렉션은 어떤 메모리를 자동으로 관리해줄까 하는 의문이 생길 수 있는데</p><p>동작 방식에 따라 매우 다양한 종류가 있지만 공통적으로 크게 다음 2가지 작업을 수행한다고 볼 수 있습니다.</p><ol><li>힙(heap) 내의 객체 중에서 가비지(garbage)를 찾아낸다.</li><li>찾아낸 가비지를 처리해서 힙의 메모리를 회수한다.</li></ol><p>힙 데이터를 알기 전 Runtime Data Area 부터 알아보자면 <img src="https://ahea.files.wordpress.com/2017/05/3.png" alt="3.png"></p><p>런타임 데이터 크게 3가지로 분류되는데</p><p>1. 스레드가 차지하는 영역</p><p>2. 객체를 생성 및 보관하는 하나의 큰 힙</p><p>3. 클래스 정보가 차지하는 영역인 메서드 영역</p><p>  이중에서도 힙을 가비지 컬럭터가 관리하게 됩니다. 다음글에서는 java의 메모리는 어떻게 구분되고 gc는 어떻게 일어나는지 알아보겟습니다. <a href="https://ahea.wordpress.com/2017/07/26/자바개발자가-알아야-할-jvm과-garbage-collection-2/" target="_blank" rel="noopener">https://ahea.wordpress.com/2017/07/26/자바개발자가-알아야-할-jvm과-garbage-collection-2/</a> 참고 : <a href="http://d2.naver.com/helloworld/329631" target="_blank" rel="noopener">http://d2.naver.com/helloworld/329631</a> <a href="http://d2.naver.com/helloworld/1329" target="_blank" rel="noopener">http://d2.naver.com/helloworld/1329</a></p>]]></content>
      
      
      <categories>
          
          <category> java </category>
          
      </categories>
      
      
    </entry>
    
    <entry>
      <title>1회 공개스터디 - 설문자료 및 후기사진</title>
      <link href="/2017/05/22/1-ed-9a-8c-ea-b3-b5-ea-b0-9c-ec-8a-a4-ed-84-b0-eb-94-94-ec-84-a4-eb-ac-b8-ec-9e-90-eb-a3-8c-eb-b0-8f-ed-9b-84-ea-b8-b0-ec-82-ac-ec-a7-84/"/>
      <url>/2017/05/22/1-ed-9a-8c-ea-b3-b5-ea-b0-9c-ec-8a-a4-ed-84-b0-eb-94-94-ec-84-a4-eb-ac-b8-ec-9e-90-eb-a3-8c-eb-b0-8f-ed-9b-84-ea-b8-b0-ec-82-ac-ec-a7-84/</url>
      
        <content type="html"><![CDATA[<p>1회 공개스터디가 성공적으로 끝난지 한참 지난후에 기록으로 남길 사진과 설문조사 공유 합니다. 다음에 2회 공개세미나를 할때 참고하시면 좋을것 같습니다. <img src="https://ahea.files.wordpress.com/2017/05/kakaotalk_20170522_143140344.jpg" alt="KakaoTalk_20170522_143140344"> 공개세미나 하기 전날에 모여서 다들 열심히 마무리 작업을 하고 있는 모습입니다. <img src="https://ahea.files.wordpress.com/2017/05/kakaotalk_20170522_143140986.jpg" alt="KakaoTalk_20170522_143140986"> 처음에 팀 리더 노성현님이 OT및 ahea study가 추구하는 방향을 설명하고 있습니다. <img src="https://ahea.files.wordpress.com/2017/05/kakaotalk_20170522_143141712.jpg" alt="KakaoTalk_20170522_143141712"> 그 다음엔 김종인님이 열심히 스터디를 발표하고있는 자리입니다. 참 열심히 준비해서 기대가 남달랐는데 그만큼 발표를 잘한것 같아 팀원으로 자랑스러웠습니다. <img src="https://ahea.files.wordpress.com/2017/05/kakaotalk_20170522_143142524.jpg" alt="KakaoTalk_20170522_143142524"> 최경운님은 다른 팀원이 사진을 안찍어줘서 없네요………………… 대신 발표 대본만 찍었습니다. 대본만 봐도 대충 어떤 방향으로 진행될지 보이시죠? 공개세미나가 끝난 후 피드백을 받기위해서 간단한 설문조사를 하였습니다. 발표자를 제외하고 25분정도 참여하셧는데요. 10분이 설문조사에 참여해 주셧습니다. <img src="https://ahea.files.wordpress.com/2017/05/1.png" alt="1"> 스터디에 대한 만족도는 대부분 만족하셧고 보통인분들도 계시네요. <img src="https://ahea.files.wordpress.com/2017/05/2.png" alt="2"> 다시 세미나를 한다면 주제에 따라 참석하시는 분들이 제일 많았습니다. 개선점을 피드백 받았는데요. 장소적인면은 확실히 개선해야될 부분으로 느끼고 있습니다. ahea 스터디원은 3명에서 폐쇠적으로 진행했었는데요. 이 세미나를 기점으로 5분이 참석하겟다는 의사를 보여왔고, 현재 슬랙에서 자유롭게 이야기하며 2회 공개 세미나를 준비 중 입니다.</p>]]></content>
      
      
      <categories>
          
          <category> 공개스터디 </category>
          
      </categories>
      
      
    </entry>
    
    <entry>
      <title>Ahea study - d2fest 서류 합격 자료(140418)</title>
      <link href="/2017/05/22/ahea-study-d2fest-ec-84-9c-eb-a5-98-ed-95-a9-ea-b2-a9-ec-9e-90-eb-a3-8c140418/"/>
      <url>/2017/05/22/ahea-study-d2fest-ec-84-9c-eb-a5-98-ed-95-a9-ea-b2-a9-ec-9e-90-eb-a3-8c140418/</url>
      
        <content type="html"><![CDATA[<ol start="2"><li><strong>제안하실 프로젝트의 이름을 적어주세요.</strong></li></ol><ol start="3"><li><strong>프로젝트의 목적과 핵심기능, 주요 사용자를 말씀해주세요.*</strong></li></ol><p>프로젝트를 진행하는 개발자 - 코드리뷰 이 프로그램을  이용할 시 나중에 따로 문서를 보지 않아도 되며 프로그램의 흐름이나 클래스 와  메소드의 사용법 등등을 따로 기재하여 프로젝트의 깔끔함을 더할 수 있으며 코드에 주석이 남지 않으므로 소스 코드에서는 간결함을 꿰 할 수 있습니다. (이 외에도 프로젝트의 전반적인 사항에 대해 설명해주세요.)</p><ol start="4"><li><strong>프로젝트에 사용할 언어, 아키텍쳐 등 전반적인 기술사항에 대해 설명해주세요.*</strong></li></ol><p>사용언어 : 자바, Web 기술, Eclipse RCP 이클립스 플러그인 개발.. Spring 3.0 framework를 이용해서 네트워크를 기반으로 여러 컴퓨터와 관계되는 웹 서비스를 제공할 예정입니다. HTML5, CSS3, JavaScript, jQurey, Jquery Bootsrap, OSGI Framework, CouchDB (D2 FEST 도중 더 적합한 구조로 변경되어도 무방하며, 기술현황 파악을 위한 참고사항입니다.)  </p><ol start="5"><li><p><strong>프로젝트의 기술적 우수성, 독창성, 유용성 등을 자유롭게 기술해주세요.*</strong></p><p>소프트웨어의 효과적인 품질 보증을 위해서 하는 코드리뷰는 필수적입니다. 최근 떠오르는 애자일 개발 프로세스에서 모든 개발 팀원이 참여하는 일일 스크럼 회의를 가지고, 스크럼 리뷰를 하는 개발 순서를 가지면서 코드 리뷰의 중요성은 더해지고 있습니다.  코드 리뷰를 통해서 개발자는 코드의 결함을 스스로 발견 할 수 있을 뿐만 아니라 오류 검출, 개발 내용을 서로에게 알려 주며 노하우를 공유 한다는 목적이 있습니다. 코드에 주석을 쓰면 코드를 설명해준 다는 장점이 있지만 소스라인이 늘어나서 보기 좋지 않고, 그것을 대체하기 위해 코드에 직접 주석을 삽입하는 것 보다 이 프로젝트를 이용해 주석을 웹상에서 확인할 수 있게 해주는 기능을 구현할 예정입니다. 클래스에 유의사항이 있는지, 메소드의 파라미터에는 어떤 벨리데이션이 처리되어 있는지 소스안에 주석이 아니라 독립적으로 지원해주고 웹브라우져로 쉽게 접근해서 코드리뷰를 할 수 있습니다. 더나아가 한가지 언어로 리뷰가 작성되어도 다른사람이 리뷰를 다른언어로 번역하여 다국적으로 접근이 가능 할 것입니다.     <strong>7. 모든 팀 구성원의 학교, 전공, 학년, 본 프로젝트에서의 역할에 대해 말씀해주세요.*</strong> 컴퓨터공학과, 4학년, 최경운 - 모바일소프트웨어학과, 4학년, 노성현 - 컴퓨터공학과, 4학년, 김종인 -  </p></li><li><p><strong>모든 팀 구성원의 이메일 주소를 세미콜론(;)으로 구분하여 적어주세요*</strong></p></li></ol><p>-</p><ol start="9"><li><strong>프로젝트에 대해 설명된 참고자료나 웹 사이트 등이 있다면 링크를 적어주세요.</strong></li></ol><p>스크럼(애자일 개발 프로세스)이란   <a href="http://ko.wikipedia.org/wiki/%EC%8A%A4%ED%81%AC%EB%9F%BC_(%EC%95%A0%EC%9E%90%EC%9D%BC_%EA%B0%9C%EB%B0%9C_%ED%94%84%EB%A1%9C%EC%84%B8%EC%8A%A4)" target="_blank" rel="noopener">http://ko.wikipedia.org/wiki/%EC%8A%A4%ED%81%AC%EB%9F%BC_(%EC%95%A0%EC%9E%90%EC%9D%BC_%EA%B0%9C%EB%B0%9C_%ED%94%84%EB%A1%9C%EC%84%B8%EC%8A%A4)</a>   NiPA SW공학센터 - Agile 적용 프로젝트의 sw품질관리 <a href="http://www.software.kr/mbs/swkr/jsp/board/view.jsp?spage=1&amp;boardId=127&amp;boardSeq=2397936&amp;mcategoryId=&amp;id=swkr_040200000000" target="_blank" rel="noopener">http://www.software.kr/mbs/swkr/jsp/board/view.jsp?spage=1&amp;boardId=127&amp;boardSeq=2397936&amp;mcategoryId=&amp;id=swkr_040200000000</a>   피쉬넷 시큐리티 - 코드리뷰의 중요성 <a href="https://www.fishnetsecurity.com/6labs/resource-library/white-paper/importance-source-code-review" target="_blank" rel="noopener">https://www.fishnetsecurity.com/6labs/resource-library/white-paper/importance-source-code-review</a></p>]]></content>
      
      
      <categories>
          
          <category> 과거 스터디 자료 </category>
          
      </categories>
      
      
    </entry>
    
    <entry>
      <title>__trashed-2</title>
      <link href="/2017/05/02/trashed-2/"/>
      <url>/2017/05/02/trashed-2/</url>
      
        <content type="html"><![CDATA[]]></content>
      
      
      <categories>
          
          <category> 미분류 </category>
          
      </categories>
      
      
    </entry>
    
    <entry>
      <title>MapReduce (20170427)</title>
      <link href="/2017/04/27/mapreduce-20170427/"/>
      <url>/2017/04/27/mapreduce-20170427/</url>
      
        <content type="html"><![CDATA[<p>이번 글은 MapReduce에 대해 자세히 공부해볼까합니다. HDFS는 파일을 저장하고, 읽고, 삭제하고, 관리하는 시스템이니 설정 및 서버 환경에 대한 이슈를 제외하면 큰 문제가 되는건 없다고 생각합니다. 하지만, MapReduce는 우리가 직접 개발해야 하는 사항이니, 자세히 알아둘 필요가 있다고 생각합니다. MapReduce가 하는 일은 비교적 간단하다.</p><p>1. 저장된(HDFS) 파일을 key-value 쌍으로 분할하여 Mapper 함수로 전송<br>2. Mapper는 key-value 쌍을 새로운 객체로 합성<br>3. shuffle 과 sort<br>4. Reducer는 key-value 쌍을 최종 결론으로 합성<br>5. 결과를 HDFS에 저장</p><p>더 간단하게 정리하면, 저장된 파일을 파싱하여 key-value로 만들고(Mapper), 만들어진 key-value를 합치는(Reducer) 작업이다. Hadoop을 설치하려면 설정하는데 너무 오랜 시간이 걸리므로 cloudera와 hortonworks에서 가상머신으로 간단하게 실행할수 있도록 해둔 것이 있으니 다운 받아 실행하면 될것 같습니다. 전 hortonworks로 하였습니다( <a href="https://ko.hortonworks.com/downloads/#sandbox" target="_blank" rel="noopener">https://ko.hortonworks.com/downloads/#sandbox</a> ) sandbox를 통해 실행한 hadoop의 버전은 다음과 같습니다. [root@sandbox study]# hadoop version Hadoop 2.7.3.2.5.0.0-1245 Subversion <a href="mailto:git@github.com" target="_blank" rel="noopener">git@github.com</a>:hortonworks/hadoop.git -r cb6e514b14fb60e9995e5ad9543315cd404b4e59 Compiled by jenkins on 2016-08-26T00:55Z Compiled with protoc 2.5.0 From source with checksum eba8ae32a1d8bb736a829d9dc18dddc2 This command was run using /usr/hdp/2.5.0.0-1245/hadoop/hadoop-common-2.7.3.2.5.0.0-1245.jar input file <img src="https://ahea.files.wordpress.com/2017/04/hdfs_file01.png" alt="hdfs_file01"><img src="https://ahea.files.wordpress.com/2017/04/hdfs_file02.png" alt="hdfs_file02"> library list</p><p>commons-cli-1.2.jar<br>commons-collections-3.2.2.jar<br>commons-configuration-1.6.jar<br>commons-io-2.4.jar<br>commons-lang-2.6.jar<br>commons-lang3-3.3.2.jar<br>commons-logging-1.1.3.jar<br>guava-11.0.2.jar<br>hadoop-auth-2.7.3.2.5.0.0-1245.jar<br>hadoop-common-2.7.3.2.5.0.0-1245.jar<br>hadoop-hdfs-2.7.3.2.5.0.0-1245.jar<br>hadoop-mapreduce-client-app-2.7.3.2.5.0.0-1245.jar<br>hadoop-mapreduce-client-common-2.7.3.2.5.0.0-1245.jar<br>hadoop-mapreduce-client-core-2.7.3.2.5.0.0-1245.jar<br>hadoop-mapreduce-client-hs-2.7.3.2.5.0.0-1245.jar<br>hadoop-mapreduce-client-jobclient-2.7.3.2.5.0.0-1245.jar<br>hadoop-mapreduce-client-shuffle-2.7.3.2.5.0.0-1245.jar<br>hadoop-yarn-server-tests-2.7.3.2.5.0.0-1245.jar<br>log4j-1.2.17.jar<br>slf4j-api-1.7.21.jar</p><ul><li>import list</li></ul><p><img src="https://ahea.files.wordpress.com/2017/04/import_list.png" alt="import_list"></p><ul><li>Mapper</li></ul><p><img src="https://ahea.files.wordpress.com/2017/04/mapper.png" alt="Mapper"></p><ul><li>Reducer</li></ul><p><img src="https://ahea.files.wordpress.com/2017/04/reducer1.png" alt="Reducer"></p><ul><li>Main</li></ul><p><img src="https://ahea.files.wordpress.com/2017/04/main.png" alt="Main"> 위 코드는 MapReduce의 기본 틀이며, 흔히 MapReduce의 Hello World라고 말하는 WordCount 코드 입니다. 실행은 Hadoop 1.x 버전에선 java -jar 로 실행이 가능했다. 하지만, Hadoop 2.x 버전이 되면서 Yarn 이라는 시스템이 생기면서 MapReduce는 컴퓨팅을 위한 프로그램만 제공하고, YARN에서 클러스터의 리소스 관리, 장애 관리 등을 하게 되었다. 그러므로 실행 방법은 hadoop 명령어를 통해서 MapReduce를 실행 한다. (YRAN 참고 : <a href="http://www.popit.kr/what-is-hadoop-yarn/" target="_blank" rel="noopener">http://www.popit.kr/what-is-hadoop-yarn/</a>)</p><p>hadoop jar ./WordCount.jar input_file_path output_file_path</p><p>이제 출력된 로그로 분석을 해볼까 합니다. 하지만…. 기본 설정에서 실행을 했을때 System.out.println(); 에 대한 출력이 나오지 않습니다.해당 로그를 보는 방법은 총 3가지가 있습니다.</p><ol><li>JobTracker 페이지<ul><li>해당 방법은 yarn이 생기기 전에도 사용하던 방법입니다.</li><li>Hadoop이 정상적으로 설치가 되면 기본적으로 확인하는 페이지는 NameNode UI(기본포트 : 50070)와 JobHistory(기본포트 : 19888) 입니다.</li><li>이 중 JobHistory에서 확인이 가능합니다.</li></ul></li><li>yarn 명령어<ul><li>yarn logs -applicationId application_ID</li><li>이를 통해 로그를 알수 있지만, application id 를 알아야하며 하나의 job에 여러 application id 가 존재하므로 확인하기 힘듭니다.</li></ul></li><li>MapReduce 설정 변경<ul><li>MapReduce의 설정 파일 중 mapred-site.xml을 수정하는 방법입니다.</li><li>mapreduce.framework.name의 기본 값은 yarn 으로 되어 있는데 이를 local 로 변경하게 되면 hadoop jar 명령어를 실행함에 있어 문제 없이 System.out.println 의 출력 값을 볼수 있습니다.</li><li>하지만, 이는 MapReduce의 restart를 의미하며, 그 외에도 yarn과 hive등의 프로세스를 restart해야하는 상황이 되므로 주의해야합니다.</li></ul></li></ol><p>저는 가상 머신으로 실행하고 있고 테스트 및 스터디를 위한 Hadoop이므로 설정을 바꾸는 3번 방법으로 하도록 하겠습니다.</p><h2 id="코드-실행"><a href="#코드-실행" class="headerlink" title="코드 실행"></a>코드 실행</h2><p>이렇게 실행하여 로그를 보면 Map이 실행되기 직전에</p><h5 id=""><a href="#" class="headerlink" title=""></a><img src="https://ahea.files.wordpress.com/2017/04/mr_log11.png" alt="MR_log1.png"></h5><p>이 있습니다.</p><ol><li>mapred.MapTask: Processing split: hdfs://sandbox.hortonworks.com:8020/user/admin/data/input/file02:0+27<ul><li>이 로그는 현재 Mapper 함수에서 읽은 파일입니다.</li><li>MapReduce가 파일을 가장 먼저 읽는 것이 이름 역순인지 가장 최근에 업로드된 파일인지 그냥 궁금해서 알아보니 가장 최근에 업로드된 파일 순으로 읽고 있다는걸 확인했습니다.</li></ul></li><li>mapreduce.task.io.sort.mb: 64<ul><li>map을 거치고 reduce가 구동되는 시점에 data-sorting이 일어나는데 이때 사용될 파일핸들 개수 및 메모리 용량을 설정하는 부분입니다.</li></ul></li></ol><p>이제 코드 상에서 찍은 로그를 보도록 하겠습니다.</p><ol><li><p>Mapper</p><ul><li><h5 id="-1"><a href="#-1" class="headerlink" title=""></a><img src="https://ahea.files.wordpress.com/2017/04/mr_log2.png" alt="MR_log2"></h5></li><li><p>위 로그는 우리가 실제로 HDFS에 업로드한 file02입니다. value는 file의 값을 읽었으니 첫 라인이 들어가는 것은 당연한데, key값이 무엇일지 몰라 로그를 보면서 추측을 해봤습니다.</p><h5 id="mapred-MapTask-bufstart-0-bufvoid-67108864"><a href="#mapred-MapTask-bufstart-0-bufvoid-67108864" class="headerlink" title="mapred.MapTask: bufstart = 0; bufvoid = 67108864"></a>mapred.MapTask: bufstart = 0; bufvoid = 67108864</h5><p>위에 적은 로그 중 이 부분에 bufstart라는 것이 있습니다. 또한, bufvoid가 있으며, Reduce 실행시 bufend가 있습니다. 이에 대한 내용은 찾아도 알수가 없어서 <a href="https://svn.apache.org/repos/asf/hadoop/common/branches/branch-1/src/mapred/org/apache/hadoop/mapred/MapTask.java" target="_blank" rel="noopener">org.apache.hadoop.mapred.MapOutputBuffer</a>를 보니 해당 변수들을 다음과 같이 설명하고 있습니다.</p><p>// k/v accounting<br>private volatile int kvstart = 0;  // marks beginning of spill<br>private volatile int kvend = 0;    // marks beginning of collectable<br>private int kvindex = 0;           // marks end of collected<br>private final int[] kvoffsets;     // indices into kvindices<br>private final int[] kvindices;     // partition, k/v offsets into kvbuffer<br>private volatile int bufstart = 0; // marks beginning of spill<br>private volatile int bufend = 0;   // marks beginning of collectable<br>private volatile int bufvoid = 0;  // marks the point where we should stop</p><pre><code>                                   // reading at the end of the buffer</code></pre><p>그러므로 Map에서 key라고 하는건 bufstart가 아닐까 하는 생각이 들었습니다. 아직 확실한 뭔가를 찾진 못했네요…</p></li></ul></li><li><p>Reducer…?</p><ul><li><h5 id="-2"><a href="#-2" class="headerlink" title=""></a><img src="https://ahea.files.wordpress.com/2017/04/mr_log3.png" alt="MR_log3"></h5></li><li><p>아직 파일을 다 읽지 않은 상황에서 Reducer가 실행이 됐습니다.</p></li><li>이는 코드 중 job.setCombinerClass(IntSumReducer.class); 으로 인해 실행되는 Reducer 입니다. 해당 코드를 사용하지 않아도 문제는 정상 처리됩니다.</li><li>하지만 만약, 용량이 크고 많은 수의 파일을 처리하며, Reducer의 key의 수가 많아진다면, Reducer의 부하가 심해지므로 각 Mapper마다 Reducer를 실행하는 것이 효율이 좋습니다.</li><li>이 Reducer에서 발생되는 또 하나의 기능이 있습니다. 바로 Sort &amp; Shuffle 입니다. key가 출력된 순서를 보면 Mapper에서 제일 먼저 만든 “Hello”가 나오지 않고 “Goodbye”가 나오고 있습니다.</li></ul></li><li>2번째 파일(file01)에 해당하는 Mapper &amp; Reducer<ul><li><img src="https://ahea.files.wordpress.com/2017/04/mr_log4.png" alt="MR_log4.png"></li><li>기본적으로 실행되는건 file02때와 같습니다. 맨 마지막에 Reduce task를 기다리는 것으로 Mapper의 일은 모두 끝이 납니다.</li></ul></li><li><p>Reducer</p><ul><li>2번째 파일(file01)까지 위와 같이 처리가 되었다면, 이제 두 Mapper의 결과를 합치는 과정이 남았습니다. 진짜 Reducer입니다.</li><li><h5 id="-3"><a href="#-3" class="headerlink" title=""></a><img src="https://ahea.files.wordpress.com/2017/04/mr_log51.png" alt="MR_log5.png"></h5></li><li><p>Reducer 가 실행 되면서 Mapper의 결과를 가져오게 되는데 그 부분에 해당하는 로그는 위와 같이 나옵니다.</p></li><li><img src="https://ahea.files.wordpress.com/2017/04/mr_log6.png" alt="MR_log6.png"></li><li>setCombinerClass 과 setReduceClass가 같긴 때문에 실행되는것 역시 같습니다.</li></ul></li><li>최종 결과<ul><li><img src="https://ahea.files.wordpress.com/2017/04/mr_log71.png" alt="MR_log7.png"></li><li>맨 마지막으로 최종적인 결과가 정리되어 나오게 되는데 실제 사용할때는 이것만 봐도 충분하다고 생각합니다. Map과 Reduce의 input/output에 대한 라인 수를 포함한 결과가 모두 나와있기 때문입니다.</li><li><img src="https://ahea.files.wordpress.com/2017/04/mr_result.png" alt="MR_result.png"></li></ul></li><li>추가 사항<ul><li>Mapper 와 Reducer에서 Iterable과 Context에 대해 출력해본 결과, key의 수가 몇개든 같은 객체를 사용하고 있다는 것을 알수 있습니다. (Mapper의 확인은 input file 하나에 여러 라인으로 테스트 하면 같은 객체를 사용하고 있다는것을 알수 있습니다.)</li></ul></li></ol><p>최종 정리 <img src="https://ahea.files.wordpress.com/2017/04/wordcount_mapreduce_paradigm.png" alt="WordCount_MapReduce_Paradigm.PNG"> 그림 참고 : <a href="https://wikis.nyu.edu/display/NYUHPC/Big+Data+Tutorial+1%3A+MapReduce" target="_blank" rel="noopener">https://wikis.nyu.edu/display/NYUHPC/Big+Data+Tutorial+1%3A+MapReduce</a> 위 그림은 위키에 올라와 있는 그림입니다. Main 함수에 있는 FileInputFormat.addInputPath( job, new Path(String) ); 를 통해 Mapper에서 처리할 파일을 설정하고, 파일 내용을 라인 별로 ETL 처리 합니다.(코드 실행 1번) 실행된 각 Mapper의 결과를 Sort &amp; Shuffle을 실행하고(코드 실행 2번), Reducer를 통해 최종 결과를 만들어냅니다.(코드 실행 3번) 만들어진 결과는 FileOutputFormat.setOutputPath( job, new Path(String) )에 설정된 HDFS에 저장 됩니다.</p>]]></content>
      
      
      <categories>
          
          <category> 미분류 </category>
          
      </categories>
      
      
    </entry>
    
    <entry>
      <title>Hadoop architecture (20170414)</title>
      <link href="/2017/04/14/hadoop-architecture-20170414/"/>
      <url>/2017/04/14/hadoop-architecture-20170414/</url>
      
        <content type="html"><![CDATA[<p>Hadoop 이란 HDFS + MapReduce로 구성되어 있습니다. (이전 글  : <a href="https://ahea.wordpress.com/2017/03/29/hadoop-eco-system-정리-1-20170329/" target="_blank" rel="noopener">https://ahea.wordpress.com/2017/03/29/hadoop-eco-system-정리-1-20170329/</a> ) 각 시스템의 아키텍처에 대해 정리해 보았습니다.</p><h3 id="1-HDFS"><a href="#1-HDFS" class="headerlink" title="1. HDFS"></a>1. HDFS</h3><p> - Hadoop Distributed File System<br> - 블록 구조의 파일 시스템 (특정 크기의 블록으로 나누어 분산된 서버에 저장)<br> - 분산 파일 시스템 : 블록을 다중 노드에 분산해서 보관<br> - Replication : 하나의 블록은 여러 노드에 복제, 특정 노드 장애에 무정지 대응</p><h4 id="네임노드-Name-Node"><a href="#네임노드-Name-Node" class="headerlink" title="네임노드 (Name Node)"></a>네임노드 (Name Node)</h4><ol><li>메타데이터 관리 : 파일 스스템을 유지하기 위한 메타데이터 관리</li><li>데이터 노드 모니터링 : 데이터 노드는 네임 노드에게 3초 마다 하트비트(heartbeat)를 전송<ul><li>네임 노드는 이를 이용해 데이터 노드의 실행 상태와 용량을 체크</li><li>heartbeat를 전송하지 않은 데이터 노드는 장애 서버로 판단</li></ul></li><li>블록 관리 : 장애가 발생한 데이터 노드의 블록을 새로운 데이터 노드에 복제<ul><li>용량이 부족하다면 여유가 있는 데이터 노드에 블록을 옮긴다.</li></ul></li><li>클라이언트 요청 접수 : 클라이언트가 HDFS에 접근하려면 반드시 네임노드의 먼저 접속<ul><li>HDFS에 파일을 저장할 경우 기존 파일의 저장여부와 권한 확인 절파를 거쳐 저장을 승인</li></ul></li><li>이중화가 가능해졌지만, 중요한 정보들을 가지고 있으므로, 물리적으로 Disk 백업 체계를 고려해야한다.</li><li>SPOF ( Single Point Of Failure )</li></ol><h4 id="보조-네임노드-Secondary-Name-Node"><a href="#보조-네임노드-Secondary-Name-Node" class="headerlink" title="보조 네임노드 (Secondary Name Node)"></a>보조 네임노드 (Secondary Name Node)</h4><ol><li>네임노드가 메타데이터를 메모리에 담고 처리하는데 만약 서버가 리부팅되는 경우 사라질 수 있다.</li><li>HDFS는 이러한 문제로 인해 editslog와 fsimage라는 두 개의 파일을 생성<ul><li>editslog : HDFS의 모든 변경이력을 저장</li><li>fsimage : 메모리에 저장된 메타데이터의 파일 시스템 이미지를 저장하는 파일</li></ul></li><li>editslog가 커지면 fsimage를 만드는데 시간이 많이 소요되는 단점</li><li>세컨드리 네임노드가 fsimage를 갱신 (체크포인트) : 세컨드리 네임노드 = 체크포인팅 서버</li><li>네임노드의 백업이 아닌 fsimage를 줄여주는 역할</li><li>fsimage가 너무 커서 네임노드가 메모이레 로딩되지 못하는 경우를 예방하기 위해 사용되는 것</li></ol><h4 id="데이터-노드-Data-Node"><a href="#데이터-노드-Data-Node" class="headerlink" title="데이터 노드 (Data Node)"></a>데이터 노드 (Data Node)</h4><ol><li>클라이언트가 HDFS에 저장하는 파일을 로컬 디스크에 유지</li><li>파일을 두가지로 저장되는데 하나는 실제 저장되는 로우 데이터이며, 다른 하나는 체크섬이나 파일 생성 일장 같은 메타데이터가 저장된 파일</li><li>Hadoop이 자체적인 Replication을 해서 High Availability를 보장하기 때문에 물리적인 Disk 백업이 필요하지 않다.</li></ol><p>구글 이미지 검색 중 HDFS architecture로 검색하니 다음 이미지가 나왔다. <img src="https://ahea.files.wordpress.com/2017/04/ed9598eb91a1_ed8c8cec9dbcec8b9cec8aa4ed859c.png" alt="하둡_파일시스템"> 이 그림은 HDFS 아키텍쳐의 설명을 자세하게 설명되어 있습니다.  이 중 파일 저장과 파일 읽기에 관한 내용을 간단하게 정리해봤습니다.</p><h4 id="파일-저장"><a href="#파일-저장" class="headerlink" title="파일 저장"></a>파일 저장</h4><ol><li>클라이언트에서 먼저 네임노드와 통신 과정을 통해 스트림(DFSOutputStream)을 생성</li><li>생성된 스트림을 통해 클라이언트에서 파일을 각 데이터 노드에 전송. 저장할 파일을 패킷 단위로 나누어 전송</li><li>파일 전송이 완료되면 클라이언트에서는 네임노드에서 얻은 스트림을 close하면 남은 모든 패킷이 flush.</li><li>클라이언트에서 네임노드의 complete 메소드를 호풀해서 정상적으로 저장되었다면 true가 반환.</li></ol><h4 id="파일-읽기"><a href="#파일-읽기" class="headerlink" title="파일 읽기"></a>파일 읽기</h4><ol><li>클라이언트에서 네임노드이 입력스트림 객체(DFSInputStream)를 통해 스트림 객체를 생성</li><li>생성된 스트림 객체를 이용하여 기본 블록의 10배수 만큼 조회</li><li>클라이언트에서 스트림 객체에서 블록리더기를 생성하는데 블록이 저장된 데이터노드가 같은 서버에 있다면 로컬블록리더기(BlockReaderLocal)을 생성, 원격에 있다면 원격블록리더기(RemoteBlockReader)를 생성한다.</li><li>DFSInputStream은 파일 모두 읽을 때까지 블록을 조회한다. 모두 읽었다면 close 를 통해 닫아주어야한다.</li></ol><p>참고 사이트 : <a href="http://hadooper.blogspot.kr/" target="_blank" rel="noopener">http://hadooper.blogspot.kr/</a> <a href="http://socurites.com/hadoop/%EB%B2%88%EC%97%AD-%ED%95%98%EB%91%A1-%ED%8C%8C%EC%9D%BC-%EC%8B%9C%EC%8A%A4%ED%85%9C%EA%B3%BC-mr-%EC%95%84%ED%82%A4%ED%85%8D%EC%B2%98" target="_blank" rel="noopener">http://socurites.com/hadoop/%EB%B2%88%EC%97%AD-%ED%95%98%EB%91%A1-%ED%8C%8C%EC%9D%BC-%EC%8B%9C%EC%8A%A4%ED%85%9C%EA%B3%BC-mr-%EC%95%84%ED%82%A4%ED%85%8D%EC%B2%98</a></p><h3 id="MapReduce"><a href="#MapReduce" class="headerlink" title="MapReduce"></a>MapReduce</h3><p> - Google에서 정보 검색을 위한 데이터 가공(색인어 추출, 정렬 및 역 인덱스 생성 등)을<br>목적으로 개발된 분산 환경에서의 병렬 데이터 처리 기법이자 프로그래밍 모델<br> - Map과 Reduce는 모두 입/출력으로 Key-Value</p><h4 id="Map-Key1-Value1-gt-Key2-Value2"><a href="#Map-Key1-Value1-gt-Key2-Value2" class="headerlink" title="Map : (Key1, Value1) -&gt; (Key2, Value2)"></a>Map : (Key1, Value1) -&gt; (Key2, Value2)</h4><ul><li>(Key, Value) 쌍을 읽어 다른 (Key, Value)쌍에 대응</li><li>(Key, Value)를 읽어서 이를 필터링 하거나, 다른 값으로 변환하는 작업을 수행</li></ul><h4 id="Reduce-Key2-List-Value-gt-Key3-Value3"><a href="#Reduce-Key2-List-Value-gt-Key3-Value3" class="headerlink" title="Reduce : (Key2, List Value) -&gt; (Key3, Value3)"></a>Reduce : (Key2, List Value) -&gt; (Key3, Value3)</h4><ul><li>Key2를 기준으로 취합된 value list를 읽어 집계된 값 value3를 출력</li><li>Map함수를 통해 출력된 값들을 새 키 Key3를 기준으로 그룹화 한 후 집계연산을 수행한 결과를 출력</li></ul><h4 id="처리-흐름"><a href="#처리-흐름" class="headerlink" title="처리 흐름"></a>처리 흐름</h4><ol><li>HDFS 상에 적재된 각 파일 조각들은 Mapper 태스크들에 할당</li><li>Mapper들은 클러스터 상의 여러 노드들에 분산되어 있으며, 각기 청크 하나를 받아 Map 함수를 수행하고 그 결과를 Mapper가 수행된 노드의 로컬 디스크에 기록한다. Mapper 태스크의 작업이 끝나고 남아 있는 chunk가 있다면, 추가로 할당하여 처리하도록 한다.</li><li>Mapper들은 선택적으로 combiner를 가질 수도 있다. 이는 Mapper가 key-value만을 출력하고 이를 Reducer가 복사, 분할 하는데 드는 I/O와 네트워크 대역폭을 절감하고자 각 Mapper가 출력한 key-value에 대해 미리 그룹화하고 집계 연산을 수행하도록 하는데 이용된다.</li><li>더 이상 처리해야 할 chunk가 없고 모든 Mapper가 정상 종료되었다면, Reducer 태스크를 수행한다.</li><li>HTTPS를 이용해 여러 노드들로부터 Key를 기준으로 각 Reducer가 처리해야 할 Key-Value를 이전 Mapper들의 로컬 디스크로부터 읽어 온다.</li><li>key값을 기준으로 정렬 연산을 수행, 정렬된 key-value들을 동일 키 값을 기준으로 그룹화를 수행</li><li>각 key값을 기준으로 그룹지어진 값들을 대상으로 집계 연산을 수행하고, 그 결과를 다시 HDFS상에 출력.</li></ol><h4 id="데이터-처리-중-장애-발생"><a href="#데이터-처리-중-장애-발생" class="headerlink" title="데이터 처리 중 장애 발생"></a>데이터 처리 중 장애 발생</h4><ul><li>Mapper의 경우 같은 청크를 대상으로 다시 수행하거나, 또는 유휴한 다른 Mapper가 해당 청크를 수행</li><li>Reducer의 경우 Mapper의 결과는 이미 로컬 디스크에 Mapper의 결과가 실체화된 상태이므로 Mapper의 수행은 건너뛰고 Reducer 작업을 다시 수행.</li><li>파일의 내구성은 HDFS의 데이터 복제에 의존</li></ul><p>위 글을 읽고 다음 그림을 보면 이해하기 쉬울것입니다. <img src="https://ahea.files.wordpress.com/2017/04/ed9598eb91a1_eba7b5eba6aceb9380ec8aa4.png" alt="하둡_맵리듀스.png"></p><h4 id="학회지-CACM에-두-진영-DBMS와-MapReduce-이-주장하는-MapReduce의-장단점-요약-http-bart7449-tistory-com-276-이-분께서-번역을-너무-잘해주셨습니다"><a href="#학회지-CACM에-두-진영-DBMS와-MapReduce-이-주장하는-MapReduce의-장단점-요약-http-bart7449-tistory-com-276-이-분께서-번역을-너무-잘해주셨습니다" class="headerlink" title="학회지 CACM에 두 진영(DBMS와 MapReduce)이 주장하는 MapReduce의 장단점 요약 - http://bart7449.tistory.com/276 이 분께서 번역을 너무 잘해주셨습니다."></a>학회지 CACM에 두 진영(DBMS와 MapReduce)이 주장하는 MapReduce의 장단점 요약 - <a href="http://bart7449.tistory.com/276" target="_blank" rel="noopener">http://bart7449.tistory.com/276</a> 이 분께서 번역을 너무 잘해주셨습니다.</h4><h4 id="장점"><a href="#장점" class="headerlink" title="장점"></a>장점</h4><ol><li>단순하고 사용이 편리<ul><li>Map함수와 Reduce함수 라는 두 개의 함수를 구현함으로써 병렬 처리가 가능하게 한다는 것.</li><li>데이터의 분산 배치와 실행은 스케쥴러가 담당함으로써 사용자는 분산 시스템의 물리적 구조를 알지 못해도 데이터 병렬화 방식을 통해 분산 처리를 매우 쉽게 할 수 있다는 이점</li></ul></li><li>유연성<ul><li>특정화된 데이터 모델이나 스키마 정의, 질의 언어에 의존적이지 않다.</li><li>범용의 프로그래밍 언어를 이용하여 데이터를 어떻게 처리할지 기술</li><li>관계형 데이터 모델로는 표현되기 어려운 다르거나, 비 정형적인 데이터 모델들도 지원</li></ul></li><li>저장 구조와의 독립성<ul><li>병렬 데이터 처리를 위한 시스템으로 하부 저장구조와 독립적</li><li>기본적으로 HDFS와 같은 분산 파일 시스템 상의 파일을 입출력으로 하지만, 그외 일반 파일 시스템이나 DBMS등 다른 저장 구조를 하부에 두는 것도 가능</li></ul></li><li>내고장성<ul><li>분산 파일 시스템의 replication에 기반한 데이터의 내구성 지원과 함계 Mapper나 Reducer의 태스크 장애 시 각 태스크의 재수행을 통해 장애로부터의 내고장성을 확보한다.</li><li>Map과 Reduce 작업이 처음부터 다시 실행되는 것을 막기 위해 Map의 결과는 Mapper가 수행된 노드의 로컬 디스크에 기록</li></ul></li><li>높은 확장성<ul><li>처리해야 할 데이터 크기가 커지면 그 만큼 높은 작업처리량을 가지도록 시스템을 개선</li><li>기존의 방식은 HW성능의 개선을 통해 처리량을 향상 시키는 scale-up방식</li><li>MapReduce는 저가의 범용 PC들을 추가로 할당함으로써 확장성을 지원하는 scale-out 방식의 구현을 용이하게 한다.</li></ul></li></ol><h4 id="단점"><a href="#단점" class="headerlink" title="단점"></a>단점</h4><ol><li>고정된 단일 데이터 흐름<ul><li>이항 연상자를 지원하지 않는다.</li><li>때문에 join은 하나의 MapReduce 작업으로 표현되지 못하고 여러개의 MapReduce 작업을 직렬로 연결해 표현해야 한다.</li><li>Loop는 매 반복때마다 계속 입력을 반복해서 읽어야 하는 등의 I/O 낭비가 심하다.</li><li>즉 MapReduce에서는 DAG(Directed Acyclic Graph) 형태로 자신의 워크플로우를 따로 적의하는 작업은 불가능하며, 복잡한 알고리즘의 구현을 위해서는 여러 번의 MapReduce 작업을 수행해야하는 불편함과 그에 따른 성능 저하가 많다.</li></ul></li><li>스키마, 인덱스, 고차원 언어 등의 미지원<ul><li>기존의 DBMS가 제공하는 스키마나 질의 언어, 인덱스 등을 제공하지 못한다.</li><li>데이터의 무결성의 미비는 결국 프로그램 로직 상에서 무결성을 검증하도록 하게 한다.</li><li>프로그램의 복잡성이 높ㅍ아지며, 하부 데이터 형식의 변경은 프로그램 조직의 변경을 야기하고, 또한 질의 형식의 재활용이나 손쉬운 질의의 작성을 어렵게 한다.</li><li>인덱스는 질의 처리 성능의 향상을 위해 중요하지만, MapReduce는 지원하지 않으며, 데이터의 일괄 처리만을 제공</li></ul></li><li>단순한 스케쥴링<ul><li>런타임 스케쥴링에 기반</li><li>런타임 스케쥴링에서는 태스크를 수행하는 경우는<ul><li>1. 실패한 태스크를 재수행</li><li>2. 아직 수행되지 않는 태스크를 수행</li><li>3. 태스크가 매우 느린 경우</li></ul></li><li>특히 3 의 경우는 임계값을 설정해 두고 일정 시간동안에 임계값을 도달하지 못하는 경우 strggler로 판정하고, 이를 다시 수행시키는데 노드 PC 성능이 상이한 경우 이 과정이 효과적이 못하다.</li><li>한 클러스터에서 여러 MapReduce 작업을 동시에 수행하는 경우에 대해서 효과적인 다중 작업 스케쥴링을 제공하지 못한다.</li></ul></li><li>상대적으로 낮은 성능<ul><li>성능 측정은 대개 단위 시간당 작업 처리량이나 시스템의 효율성 등으로 측정</li><li>MapReduce는 다른 병렬 DBMS에 비해 데이터 적재 시간 이외에 우수한 성능을 보이지 못함</li><li>이러한 늦은 성능은 내고장서 지원을 위해 디스크 I/O를 희생하는 태생적인 이유에 근거<ul><li>파일을 보관하는 분산 ㅍ파일 시스템은 2개의 replication를 추가로 가짐에 따라 디스크 공간과 I/O를 소비</li><li>복제된 이휴 읽기 연산은 각기 다른 복사본에 접근함으로써 병렬화를 꾀할 수는 있지만, 출력의 경우 한 데이터를 가지고 여러 노드에 분산, 기록.</li><li>각 태스크는 수행 결과를 다음 태스크에 전달하기 이전에 태스크를 수행한 노드의 로컬 디스크 또는 분산 파일 시스템 상에 기족하는 과정을 먼저 수행.</li></ul></li></ul></li></ol><p>참고 사이트 : <a href="http://bart7449.tistory.com/276" target="_blank" rel="noopener">http://bart7449.tistory.com/276</a> 다음 글은  MapReduce를 사용하여 Hello World인 WordCount를 구현하도록 하겠습니다. 구현 하면서 동작되는 원리를 정리해 볼까 합니다.</p>]]></content>
      
      
      <categories>
          
          <category> 미분류 </category>
          
      </categories>
      
      
    </entry>
    
    <entry>
      <title>Hadoop 이란 (20170329)</title>
      <link href="/2017/03/29/hadoop-ec-9d-b4-eb-9e-80-20170329/"/>
      <url>/2017/03/29/hadoop-ec-9d-b4-eb-9e-80-20170329/</url>
      
        <content type="html"><![CDATA[<p>꼭 알아야해까진 아니여서 간략하게 읽을 수 있도록 정리 하고, 추후 글 추가 및 수정으로 공부한 내용을 올리겠습니다.</p><h3 id="1-Bigdata-란"><a href="#1-Bigdata-란" class="headerlink" title="1. Bigdata 란"></a>1. Bigdata 란</h3><blockquote><p>서버 한 대로 처리할 수 없는 규모의 데이터</p></blockquote><ul><li>아마존의 data scientist의 존 라우저가 2012년 아마존 클라우드 컨퍼런스에서 정의한 말</li><li>가지고 있는 데이터를 제대로 처리하기 위해 분산 화ㄴ경이 필요하느냐에 포커스를 둔 정의</li></ul><p>경영 컨설팅 회사들은 20TB를 빅데이터의 기준점이라 말하며, 3V라는 정의(현재는 4V라고도 함)를 내새웁니다.</p><ol><li>Volume(규모) : 데이터의 크기</li><li>Velocity(속도) : 데이터가 얼마나 빠르게 생성되는지</li><li>Variety(다양성) : 데이터가 구조화/비구조화된 데이터를 다 포함하는지 여부</li><li>Variability(변동성) : Variety와 연관된 것으로 데이터의 형태가 아예 알려져 있지 않은지 아니면 급변하는지 여부</li></ol><h3 id="2-Bigdata-예"><a href="#2-Bigdata-예" class="headerlink" title="2. Bigdata 예"></a>2. Bigdata 예</h3><ul><li>웹 검색엔진 데이터</li><li>웹 페이지 데이터</li><li><p>검색어 로그와 클릭 로그 데이터</p><ul><li><a href="https://trends.google.com/trends/" target="_blank" rel="noopener">https://trends.google.com/trends/</a></li><li><a href="https://translate.google.com" target="_blank" rel="noopener">https://translate.google.com</a></li></ul></li><li><p>디바이스에서 생성되는 데이터</p><ul><li>스마트폰의 TV, 전화, 위치 정보, 앱 다운 등 (시스코에 따르면 2015년에 생성되는 데이터만 6.3ExaByte)</li><li>보잉 제트엔진(비행기 엔진)의 경우 매 30분마다 10TB의 데이터를 생성</li><li>스마트 미터 (전기사용량을 측정)</li><li>강우량이나 풍량 같은 날씨를 관측하는 센서</li></ul></li><li><p>소셜미디어의 데이터</p><ul><li>페이스북 / 트위터 등</li></ul></li></ul><h3 id="3-Hadoop의-역사"><a href="#3-Hadoop의-역사" class="headerlink" title="3. Hadoop의 역사"></a>3. Hadoop의 역사</h3><ol><li>웹 검색 엔진인 아파치 너치(Apache Nutch)의 일부 - 창시자 : 더그 커팅</li><li>웹 사이트를 크롤하고 색인하는 소프트웨어와 서버와 데이터의 관리가 필요</li><li>Nutch는 2002년에 개발 시작하였지만 수십 억 웹 페이지로 확장될 수 없었음.</li><li>2003년 GFS(Google File System)라는 구글 분산 파일시스템의 아키텍처가 기술된 논문 공개</li><li>2004년 NDFS(Nutch Distributed File System)을 오픈소스로 구현</li><li>2004년 구글의 MapReduce를 소개하는 논문 출판</li><li>2005년초 너치에 맵리듀스를 구현, 2005년 중반까지 주요 너치 알고리즘이 MapReduce + NDFS 를 사용하기 위해 포팅</li><li>NDFS + MapReduce는 검색 분야 외의 여러 분야에서 응용</li><li>2006년 2월에 NDFS + MapReduce는 하둡이라고 명명된 독립 서브 프로젝트를 구성하기 위해 너치 밖으로 빠져나옴 (이때, NDFS를 HDFS로 이름을 변경)</li><li>비슷한 시기에 더그 커팅은 야후에 합류</li><li>2008년 2월 웹 규모의 시스템으로 전환하기 위해 전용 팀과 리소스를 제공</li><li>이후 하둡은 야후 뿐만 아니라 다양한 회사에서 사용</li><li>대기업 벤더인 EMC, IBM, MS, Oracle, Cloudera, Hortonworks, MapR 같은 하둡 전문 기업이 하둡을 배포</li></ol><h3 id="4-Hadoop-기반의-빅데이터-처리"><a href="#4-Hadoop-기반의-빅데이터-처리" class="headerlink" title="4. Hadoop 기반의 빅데이터 처리"></a>4. Hadoop 기반의 빅데이터 처리</h3><ul><li>데이터 수집 : 수집 후 분산 파일 시스템에 저장 (Flume, Chukwa, Kafka)</li><li><p>데이터 저장 및 처리 : MapReduce</p><ul><li>하둡은 기본적으로 큰 데이터릐 배치 프로세싱에 적합하고, 실시간으로 데이터를 분석하는 용도로 사용하기에는 버겁다는 점</li></ul></li><li><p>처리데이터 액세스 모듈</p><ul><li>기존 관계형 데이터베이스 : sqoop( RDB to HDFS or HDFS to RDB )</li><li>NoSQL : HBase, Cassandra, MongoDB</li><li>검색 엔진 : Lucene, Solr, ElasticSearch</li></ul></li><li><p>데이터의 분포 등을 보여주는 시각화 : Matlab, R(R-Hadoop), (Datameer, Pentaho 의 제품)</p><ul><li>R-Hadoop 이란 RMR(R-MapReduce), RHDFS, RHBase등 하둡 기반 기술들에 R 인터페이스를 접목한 프로젝트</li></ul></li><li><p>작업 워크플로우 관리 정의 모듈 : Cascading, Oozie, Azkaban, Ambrose</p></li></ul><p>Oozie : xml로 잡들을 어떻게 이어서 실행할지 설정 Cascading :자바 API를 통해 설정 Azkaban : 링크드인 내부에서 사용하는 워크플로우 관리 오픈소스 툴 Ambrose : 트위터 내부에서 사용하는 워크플로우 툴을 오픈소스 화</p><h3 id="5-Hadoop의-특징"><a href="#5-Hadoop의-특징" class="headerlink" title="5. Hadoop의 특징"></a>5. Hadoop의 특징</h3><ul><li>오픈소스 : 무료</li><li>스케일 아웃<ul><li>단, 스케일 업이 어느정도 적용된 스케일 아웃</li><li>너무 낮은 사양을 사용할 경우 공간적 제약이 너무 심함</li><li>서버 수를 어느정도 늘린 후에는 서버의 스펙을 올리는 편</li></ul></li><li>병렬처리를 가능하게 해주는 단순한 데이터 모델<ul><li>MapReduce 프로그래밍 특징 상 데이터는 다음과 같아야 합니다.<ul><li>데이터는 레코드의 집합</li><li>각 레코드는 Key와 Value를 갖는다.</li></ul></li></ul></li><li>오프라인 배치 프로세싱에 최적화<ul><li>Hadoop은 오프라인 배치를 처리하는데 적합한 framework</li><li>현재는 Spark, Storm, Kafka 등으로 오프라인 배치라는 제약이 약해짐.</li></ul></li><li>불편 파일만 저장<ul><li>파일은 HDFS의 업로드 후에는 내용을 변경하지 않는다는 가정</li></ul></li><li>NameNode<ul><li>파일 시스템의 namespace를 namenode의 메모리상에서 관리하기 때문에 Hadoop의 저장할 수 있는 파일과 디렉토리의 개수는 namenode의 제약을 받는다.</li><li>SPOF(Single Point Of Failure)<ul><li>이는 Secondary NameNode를 구성하면 NameNode의 데이터를 주기적으로 백업함으로써 어느정도 해결 할수 있다.</li></ul></li></ul></li></ul><p>1차적인 글은 이걸로 마치겠습니다. 이론적인 내용이 많아 <a href="http://book.naver.com/bookdb/book_detail.nhn?bid=7217333" target="_blank" rel="noopener">하둡 완벽 가이드 클라우드 컴퓨팅 구축을 위한 실전 안내서</a> 와 <a href="http://book.naver.com/bookdb/book_detail.nhn?bid=7141828" target="_blank" rel="noopener">Do it! 직접 해보는 하둡 프로그래밍</a>의 책을 많이 참조 하였습니다. 이후 추가 및 수정할 내용이 있으면 바로 바로 수정해서 올리겠습니다.</p>]]></content>
      
      
      <categories>
          
          <category> 미분류 </category>
          
      </categories>
      
      
    </entry>
    
    <entry>
      <title>1회 공개 스터디 reactive programming</title>
      <link href="/2017/03/20/1-ed-9a-8c-ea-b3-b5-ea-b0-9c-ec-8a-a4-ed-84-b0-eb-94-94-reactive-programming/"/>
      <url>/2017/03/20/1-ed-9a-8c-ea-b3-b5-ea-b0-9c-ec-8a-a4-ed-84-b0-eb-94-94-reactive-programming/</url>
      
        <content type="html"><![CDATA[<p><a href="https://www.slideshare.net/sunghyunroh12/ahea-study-reactive-programming" target="_blank" rel="noopener">https://www.slideshare.net/sunghyunroh12/ahea-study-reactive-programming</a></p>]]></content>
      
      
      <categories>
          
          <category> 공개스터디 </category>
          
          <category> java </category>
          
          <category> reactive </category>
          
          <category> spring </category>
          
      </categories>
      
      
    </entry>
    
    <entry>
      <title>1회 공개 스터디 Spring batch</title>
      <link href="/2017/03/20/1-ed-9a-8c-ea-b3-b5-ea-b0-9c-ec-8a-a4-ed-84-b0-eb-94-94-spring-batch/"/>
      <url>/2017/03/20/1-ed-9a-8c-ea-b3-b5-ea-b0-9c-ec-8a-a4-ed-84-b0-eb-94-94-spring-batch/</url>
      
        <content type="html"><![CDATA[<p><a href="https://www.slideshare.net/sunghyunroh12/ahea-team-spring-batch" target="_blank" rel="noopener">https://www.slideshare.net/sunghyunroh12/ahea-team-spring-batch</a></p>]]></content>
      
      
      <categories>
          
          <category> 공개스터디 </category>
          
          <category> java </category>
          
          <category> spring </category>
          
          <category> spring batch </category>
          
      </categories>
      
      
    </entry>
    
    <entry>
      <title>1회 공개 스터디 Orm은 어떻게 객체를 &quot;매핑&quot;할까</title>
      <link href="/2017/03/20/1-ed-9a-8c-ea-b3-b5-ea-b0-9c-ec-8a-a4-ed-84-b0-eb-94-94-orm-e1-84-8b-e1-85-b3-e1-86-ab-e1-84-8b-e1-85-a5-e1-84-84-e1-85-a5-e1-87-82-e1-84-80-e1-85-a6-e1-84-80-e1-85-a2-e1-86-a8-e1-84-8e-e1-85-a6/"/>
      <url>/2017/03/20/1-ed-9a-8c-ea-b3-b5-ea-b0-9c-ec-8a-a4-ed-84-b0-eb-94-94-orm-e1-84-8b-e1-85-b3-e1-86-ab-e1-84-8b-e1-85-a5-e1-84-84-e1-85-a5-e1-87-82-e1-84-80-e1-85-a6-e1-84-80-e1-85-a2-e1-86-a8-e1-84-8e-e1-85-a6/</url>
      
        <content type="html"><![CDATA[<p><a href="https://www.slideshare.net/sunghyunroh12/orm-73337953" target="_blank" rel="noopener">https://www.slideshare.net/sunghyunroh12/orm-73337953</a></p>]]></content>
      
      
      <categories>
          
          <category> 공개스터디 </category>
          
          <category> java </category>
          
      </categories>
      
      
    </entry>
    
    <entry>
      <title>오브젝트 매핑과 슈퍼 타입 토큰</title>
      <link href="/2017/03/04/ec-98-a4-eb-b8-8c-ec-a0-9d-ed-8a-b8-eb-a7-a4-ed-95-91-ea-b3-bc-ec-8a-88-ed-8d-bc-ed-83-80-ec-9e-85-ed-86-a0-ed-81-b0/"/>
      <url>/2017/03/04/ec-98-a4-eb-b8-8c-ec-a0-9d-ed-8a-b8-eb-a7-a4-ed-95-91-ea-b3-bc-ec-8a-88-ed-8d-bc-ed-83-80-ec-9e-85-ed-86-a0-ed-81-b0/</url>
      
        <content type="html"><![CDATA[<p>자바 프로젝트를 진행 하면서 외부 데이터를 가지고 ValueObject(이하 VO)에 매핑하고 여러가지 연산작업을들 합니다. 그중에서도 VO의 정보를 가져와 매핑하는 방법에 대해서 궁금하게 되었고 자바에서 제공하는 리플렉션API와 간단한 예제들을 통해서 오브젝트 매핑에 대해 알아 보겠습니다.</p><h1 id="클래스-정보-가져오기"><a href="#클래스-정보-가져오기" class="headerlink" title="클래스 정보 가져오기"></a>클래스 정보 가져오기</h1><p><img src="https://ahea.files.wordpress.com/2017/03/471_uxqrwdbcro.png" alt=""></p><p><img src="https://ahea.files.wordpress.com/2017/03/471_zlofw7r-8r.png" alt=""></p><p><img src="https://ahea.files.wordpress.com/2017/03/471_tges7yfoa1.png" alt=""></p><p>자바는<a href="http://docs.oracle.com/javase/8/docs/api/java/lang/reflect/package-summary.html" target="_blank" rel="noopener"> java.lang.reflect패키지의 API</a>를 가지고 클래스의 정보와 필드 어노테이션 정보까지 모두 가져 올수 있는 리플렉션을 제공 합니다.</p><p>그래서 이렇게 구할수 있는 정보를 가지고 외부에서 가져오는 json 데이터나 sql문을 가져올시 매핑을 하여서 해당 오브젝트로 값을 삽입해 넘겨줄수 있습니다.</p><h1 id="조금더-편리한-API"><a href="#조금더-편리한-API" class="headerlink" title="조금더 편리한 API"></a>조금더 편리한 API</h1><p>리플렉션 API로도 훌륭하게 매핑이 가능하지만 조금더 사용하기 편리하고 안전하게 매핑할수 있도록 자바에서 제공하는 <a href="http://docs.oracle.com/javase/8/docs/api/java/beans/package-summary.html" target="_blank" rel="noopener">java</a><a href="http://docs.oracle.com/javase/8/docs/api/java/beans/package-summary.html" target="_blank" rel="noopener">.beans</a> 에서 제공하는 API를 사용 하겠습니다.</p><p><img src="https://ahea.files.wordpress.com/2017/03/471_tkq0crge72.png" alt=""></p><p><img src="https://ahea.files.wordpress.com/2017/03/471_jbtifhc3is.png" alt=""></p><p>BeanInfo 객체를 생성할 땐 Introspector.getBeanInfo라는 static factory methode를 이용하여 빈정보를 생성한뒤 각각의 BeanDescriptor, PropertyDecriptors, MethodDescriptors를 가져와서 리플렉션보다는 편리하게 클래스 정보를 가져 올수 있습니다.</p><p>여기에서 map형태나 json형태의 값을 가져 왔을때 오브젝트 매핑을 해야 하는데 PropertyDecriptors의 출력결과를 자세히 보시면  각각의 property에 대해서 redeMethod와 writeMethod정보를 보여주고 있습니다. 이걸 활용하여 맵에 프로퍼티이름과 값을 넣어두고 간단하게 매핑하는 예제를 보여드리겠습니다.</p><h1 id="심플-매핑"><a href="#심플-매핑" class="headerlink" title="심플 매핑"></a>심플 매핑</h1><p><img src="https://ahea.files.wordpress.com/2017/03/471_kpagpsnkrh.png" alt=""><img src="https://ahea.files.wordpress.com/2017/03/471_3qslmuyj-b.png" alt=""></p><p>Map에 프로퍼티 이름과 동일하게 값을 셋팅해주고 List에 한개씩 담았습니다.</p><p><img src="https://ahea.files.wordpress.com/2017/03/471_aopqydizio.png" alt=""></p><p><img src="https://ahea.files.wordpress.com/2017/03/471_gsdpa-3-fl.png" alt=""></p><p>소스를 보시면 셋팅된 데이터로 forEach문을 돌리면서 Map을 한개씩 가져옵니다 그러면서 데이터를 셋팅될 오브젝트를 생성하고(User u = new User();) forEach문 안에 property를 한개씩 꺼내오면서 property의 이름을 으로  Map의 키값을 검색하여 Map의 Value를 가져와 propertyDescriptor.getWriteMethod를 이용하여 값을 셋팅 해줍니다. 보기엔 복잡해 보이지만 하나씩 따라가보면 비교적 쉽게 느껴 지실수 있습니다.</p><h1 id="타입-토큰"><a href="#타입-토큰" class="headerlink" title="타입 토큰"></a>타입 토큰</h1><p>예제 소스 코드중에서 Introspector.getBeanInfo(User.class)가 있는데 보통 User.class를 타입 토큰 이라고 합니다. 그런데 자바에서는 아쉽게도 타입 토큰에는 컴파일시 제너릭정보를 담을수가 없어서 class정보만을 가져올수가 있습니다.(C#은 자바와는 다르게 제너릭정보를 바로 가져올 수 있다고 하네요…)</p><p><img src="https://ahea.files.wordpress.com/2017/03/471_lgqlm85e8m.png" alt=""></p><p>그래서 이걸 해결하기 위해 나온것이 슈퍼 타입 토큰 이라고 합니다.</p><h1 id="슈퍼-타입-토큰"><a href="#슈퍼-타입-토큰" class="headerlink" title="슈퍼 타입 토큰"></a>슈퍼 타입 토큰</h1><p>슈퍼 타입 토큰은 클래스의 제너릭 정보까지 가져오는 방식 입니다. 익명클래스를 작성하여 상속하면 상속된 정보는 컴파일시 지워지지가 않는다고 하여 익명클래스 상속방식으로 슈퍼 타입 토큰을 가져옵니다.</p><p><img src="https://ahea.files.wordpress.com/2017/03/471_vfbsbjeare.png" alt=""></p><p><img src="https://ahea.files.wordpress.com/2017/03/471_1toza74z_l.png" alt=""></p><p>예제 소스를 보시면 extends가 된 클래스(슈퍼 클래스)는 가져오지만 List의 String정보는 못가져오고 있습니다. 이를 이용하여 슈퍼 타입 토큰을 이용하면 제너릭 정보를 가져올수가 있습니다.</p><p>위의 예제에서 슈퍼 타입 토큰을 사용하기 편하게 클래스를 정의해 보겠습니다.</p><h1 id="타입-토큰과-슈퍼-타입-토큰-비교"><a href="#타입-토큰과-슈퍼-타입-토큰-비교" class="headerlink" title="타입 토큰과 슈퍼 타입 토큰 비교"></a>타입 토큰과 슈퍼 타입 토큰 비교</h1><p>슈퍼 타입 토큰을 사용을 간소화 하기 위해서 클래스를 작성하였습니다.</p><p><img src="https://ahea.files.wordpress.com/2017/03/471_dqeow7mq0n.png" alt=""></p><p><img src="https://ahea.files.wordpress.com/2017/03/471_s0gvfh7ggk.png" alt=""></p><p>ParametertizedType은 파라미터형의 타입을 표현하는 인터페이스 입니다.</p><p><img src="https://ahea.files.wordpress.com/2017/03/471_aqpw2yeejk.png" alt=""></p><p><img src="https://ahea.files.wordpress.com/2017/03/471_cjexy53exq.png" alt=""></p><p>슈퍼 타입 토큰의 경우 제너릭정보를 모두 불러오지만 타입 토큰은 제너릭정보를 담을수가 없어 제한적일수바께 없습니다.</p><h1 id="예제1-JDBC-예제"><a href="#예제1-JDBC-예제" class="headerlink" title="예제1. JDBC 예제"></a>예제1. JDBC 예제</h1><p>GitHub : <a href="https://github.com/kji6252/ORM-example2.git" target="_blank" rel="noopener">https://github.com/kji6252/ORM-example2.git</a></p><p>앞에서 알아본 클래스정보를 가져올수있는 BeanInfo와 슈퍼타입 토큰을 활용한 JDBC 오브젝트 매핑 예제를 작성 했습니다.</p><p><img src="https://ahea.files.wordpress.com/2017/03/471_-qum1ndn3j.png" alt=""></p><p>그림. JDBC 예제 구성도</p><p><img src="https://ahea.files.wordpress.com/2017/03/471_hmho5-em2j.png" alt=""></p><p>그림. JDBC 예제 메인</p><p><img src="https://ahea.files.wordpress.com/2017/03/471_eyetr4td8y.png" alt=""></p><p>OMMaper에서는 query메서드 에서 각각 원하는 결과를 리턴 할 수 있는 classQuery,listQuery,mapQuery 로 분기 한다음 ResultSet과 BeanInfo의 PropertyDescriptor로 매핑하여 최종 결과를 리턴 하게 됩니다.</p><p><img src="https://ahea.files.wordpress.com/2017/03/471_zktv1jz3sg.png" alt=""></p><h1 id="예제2-Spring-JDBC-예제"><a href="#예제2-Spring-JDBC-예제" class="headerlink" title="예제2. Spring JDBC 예제"></a>예제2. Spring JDBC 예제</h1><p><img src="https://ahea.files.wordpress.com/2017/03/471_dfcoldcfv1.png" alt=""></p><p>스프링에서 제공하는 SqlQuery를 상속받으면 protected abstract RowMapper&lt;T> newRowMapper(Object[] parameters, Map&lt;?, ?> context); 메서드를 구현해야 합니다.</p><p>스프링 JDBC예제에서도 예제1과 동일한 방식으로 매핑을 하였습니다.</p><p><img src="https://ahea.files.wordpress.com/2017/03/471_ilowdvj_uu.png" alt=""></p><p>예제 1과 동일하게 구성 하였습니다.</p><p><img src="https://ahea.files.wordpress.com/2017/03/471_cptgockuxu.png" alt=""></p><p>SqlQuery에서 아이디값으로 sql문을 실행하여 RowMapper로 매핑하여 결과를 가져 옵니다.</p><p><img src="https://ahea.files.wordpress.com/2017/03/471_r3amagw3pb.png" alt=""></p>]]></content>
      
      
      
        <tags>
            
            <tag> java </tag>
            
            <tag> reflection </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>4. Spring batch, boot 연동 및 처리 과정.</title>
      <link href="/2017/02/20/3-spring-batch-boot-ec-97-b0-eb-8f-99-eb-b0-8f-ec-b2-98-eb-a6-ac-ea-b3-bc-ec-a0-95/"/>
      <url>/2017/02/20/3-spring-batch-boot-ec-97-b0-eb-8f-99-eb-b0-8f-ec-b2-98-eb-a6-ac-ea-b3-bc-ec-a0-95/</url>
      
        <content type="html"><![CDATA[<p>spring batch 와 spring boot를 연동하고 프로세스 과정을 살펴보겟습니다.</p><p>sample 데이터 추가.</p><p><img src="https://ahea.files.wordpress.com/2017/02/image9.png" alt="image"></p><p>schema-@@platform@@.sql으로 플랫폼에 맞춰서 sql문이 돌아간다.</p><p>-all이면 모든 플랫폼에 대해 기본값으로 설정됨.</p><p>ex&gt;schema-mysql.sql</p><p><img src="https://ahea.files.wordpress.com/2017/02/image12.png" alt="image1"> <img src="https://ahea.files.wordpress.com/2017/02/image22.png" alt="image2"></p><p>간단하게 firstName 과 lastname을 대문자로 만들어주는 PersionItemProcessor를 만들었습니다.</p><p>PersionItemProcessor는 ItemProcessor의 인터페이스를 구현받습니다.</p><p>Item이 나오는데 Item은 처리할 데이터의 가장 작은 구성 요소 입니다.</p><p><img src="https://ahea.files.wordpress.com/2017/02/image32.png" alt="image3"></p><p>이제 실제 Batch job을 돌려봅시다. Spring batch는 개발자가 비지니스 로직에 집중할수 있도록 많은 유틸리티 클래스를 제공합니다.</p><p><code>EnableBatchProcessing</code>은 jobBuilderFactory와 stepBuilderFactory 빈을 제공합니다.</p><p>Job은 step 으로 이루어져 있고 Step은 reader, processor, writer로 이루어져 있습니다.</p><p>JobInstance 는 Job + Job Parameter이기 때문에 Job Parameter를 자동으로 Increment 하기 위해서 사용합니다.</p><p>Step에서는 한번에 쓸 데이터 양을 정의 합니다. 이 경우에는 한번에 최대 10개 item의 record를 기록합니다.”chunk”의 입력 및 출력 유형을 나타내며, ItemReader&lt;~&gt;및 ItemWriter&lt;~&gt; 와 일치합니다.</p><p><img src="https://ahea.files.wordpress.com/2017/02/image42.png" alt="image4"></p><p>아래 그림을 보면 위에 프로세스와 비슷하게 흘러가는걸 확인할수 있습니다.</p><p><img src="https://ahea.files.wordpress.com/2017/02/image7.png" alt="image"></p><p>reader   -   sample-data에 있는 csv파일을 읽어서 하는 부분이니 이런식으로 읽는구나만 참조 하면 될 것 같습니다.</p><p>writer - date를 db에 쓰는 부분 입니다.</p><p><img src="https://ahea.files.wordpress.com/2017/02/image52.png" alt="image5"></p><p>  Processor 부분인데 실제 비지니스 로직이 포함 되는 부분입니다.</p><p><img src="https://ahea.files.wordpress.com/2017/02/image62.png" alt="Image6.png"></p><p>job 에 걸린 listener를 보면 끝난 상태를 체크하는 부분을 JobExecution에서 status 를 가져오는것을 알수 있습니다.</p><p><img src="https://ahea.files.wordpress.com/2017/02/image71.png" alt="Image7.png"></p><p>Job Execution에 대해서는 이전 글을 참고하시면 됩니다.</p><p>결과 화면 :</p><p><img src="https://ahea.files.wordpress.com/2017/02/image10.png" alt="Image10.png"></p><p>배치 처리는</p><ol><li>main 메소드가 있는 jar 만들거나</li><li>웹 애플리케이션에 포함시킨다.</li></ol><p>jar 만드는 방법은 구글링 참고.</p><p>Spring batch 참고 : <a href="https://spring.io/guides/gs/batch-processing/" target="_blank" rel="noopener">https://spring.io/guides/gs/batch-processing</a></p><p>위에 사이트에서 소스를 받아서 돌렸는데 h2 메모리 디비 말고 mysql을 쓰고 싶어서</p><p>datasource에</p><p><img src="https://ahea.files.wordpress.com/2017/02/image81.png" alt="Image8.png"></p><p>다음과 같이 세팅했습니다.</p><p>BasicDataSource 를 import하기 위해서 maven에 dependency를 추가하면 끝.</p><p><img src="https://ahea.files.wordpress.com/2017/02/image91.png" alt="Image9.png"></p><p>-- 기타 -- 1. 쿼츠랑 스프링 스케줄러랑 무슨차이인가요?  -P사 다니는 K모씨 Quartz와 Spring  <strong>Scheduler의 차이.</strong> Quartz <strong>- 모든 Java 애플리케이션에 통합 할 수있는 오픈 소스 작업 스케줄 라이브러리.</strong> <strong>- 수십, 수백 또는 심지어 수만 개의 작업을 실행하기위한 간단하거나 복잡한 일정을 만드는 데 사용할 수 있습니다.</strong> - JTA 트랜잭션 및 클러스터링 지원과 같은 많은 엔터프라이즈 급 기능이 포함되어 있습니다 Spring  <strong>Scheduler</strong> <strong>- Spring은 또한 Timer와 JDK 1.3이후에  Quartz Scheduler와의 스케쥴링을 지원하기위한 통합 클래스를 제공한다.</strong> -&gt;<a href="https://docs.spring.io/spring/docs/current/spring-framework-reference/html/scheduling.html" target="_blank" rel="noopener">https://docs.spring.io/spring/docs/current/spring-framework-reference/html/scheduling.html</a></p><p> 참고 :</p><p>스프링 배치와 전자전부 프레임워크 : <a href="http://open.egovframe.go.kr/nforges/information/filearchive/6179/.do" target="_blank" rel="noopener">http://open.egovframe.go.kr/nforges/information/filearchive/6179/.do</a></p><p>스프링 배치 이점 : <a href="https://groups.google.com/forum/#!topic/ksug/9FMlJaE-zKU" target="_blank" rel="noopener">https://groups.google.com/forum/#!topic/ksug/9FMlJaE-zKU</a></p><p>스프링 배치 vs DB 프로시저 : <a href="https://groups.google.com/forum/#!topic/ksug/vznlOZarb3s" target="_blank" rel="noopener">https://groups.google.com/forum/#!topic/ksug/vznlOZarb3s</a></p><p>대규모 배치시스템 성공적인 구축 전략 : <a href="https://www.kodb.or.kr/info/info_04_view.html?field=&amp;keyword=&amp;type=techreport&amp;page=135&amp;dbnum=128484&amp;mode=detail&amp;type=techreport" target="_blank" rel="noopener">https://www.kodb.or.kr/info/info_04_view.html?field=&amp;keyword=&amp;type=techreport&amp;page=135&amp;dbnum=128484&amp;mode=detail&amp;type=techreport</a></p>]]></content>
      
      
      <categories>
          
          <category> spring batch </category>
          
      </categories>
      
      
    </entry>
    
    <entry>
      <title>Reactive PublishOn, SubscribeOn</title>
      <link href="/2017/02/20/reactive-publishon-subscribeon/"/>
      <url>/2017/02/20/reactive-publishon-subscribeon/</url>
      
        <content type="html"><![CDATA[<p>Reactive 글 모음</p><ol><li><a href="https://ahea.wordpress.com/2017/02/02/iterable%ec%99%80-observable%ec%9d%98-%ea%b0%9c%eb%85%90/" target="_blank" rel="noopener">Iterable와 Observable의 개념</a></li><li><a href="https://ahea.wordpress.com/2017/02/03/reactive-history/" target="_blank" rel="noopener">Reactive History</a></li><li><a href="https://ahea.wordpress.com/2017/02/13/reactive-streams/" target="_blank" rel="noopener">Reactive Streams</a></li><li><a href="https://ahea.wordpress.com/2017/02/13/rxjava/" target="_blank" rel="noopener">RxJava</a></li><li><a href="https://ahea.wordpress.com/2017/02/15/spring-reactive/" target="_blank" rel="noopener">Spring Reactive</a></li><li><a href="https://ahea.wordpress.com/2017/02/20/reactive-publishon-subscribeon/" target="_blank" rel="noopener">Reactive PublishOn, SubscribeOn</a></li></ol><hr><p><a href="http://ahea.files.wordpress.com/2017/02/993d6acff3e9bc2448266c19570a4a18.png" target="_blank" rel="noopener"><img src="https://ahea.files.wordpress.com/2017/02/993d6acff3e9bc2448266c19570a4a18.png" alt=""></a> 다음과 같은 코드가 있습니다. Publisher, Subscriber 그리고 Subscription이 있습니다. 각자가 처리되는 곳에서 로그를 찍었고 로그는 Slf4j를 이용했습니다. 결과를 보면 다음과 같이 나옵니다. <a href="http://ahea.files.wordpress.com/2017/02/c95e4162e7e91ab27a2ddbc6e013e552.png" target="_blank" rel="noopener"><img src="https://ahea.files.wordpress.com/2017/02/c95e4162e7e91ab27a2ddbc6e013e552.png" alt=""></a> 우리가 코딩한 그대로 subscriber가 publisher에 등록을 하면 내부처리가 진행되고 exit로 끝나게 됩니다. 이때 subscriber와 publisher의 진행은 메인메소드에서 진행됩니다. 이렇게 되면 subscriber가 등록을 하면 publisher가 데이터를 넣어주고 처리할때까지 메인메소드를 붙잡고 있게 됩니다. 이게 맞는것일까요… 결국 우리가 원하는것은 비동기-동기화 처리, 즉 publisher에 subscriber를 등록하게 되면 자기들은 자기들대로 진행하고 계속 메인메소드가 진행되는것을 하고 싶은겁니다. Reactive Streams가 겨우 Observerable을 해주기 위한 건 아니지 않습니까… 결국 Reactive Streams 가 해주고 싶었던 궁극적인 목적은 병렬프로그래밍을 손쉽게 하기 위해 옵저버 모델을 가져간것이죠. 옵저버 자체가 핵심은 아니였습니다. 이번 포스팅에서는 간단하게 PublishOn과 SubscribeOn 을 통해 Reactive Stream에서 병렬처리를 어떻게 하는지 알아보겠습니다</p><h1 id="publishOn-subscribeOn"><a href="#publishOn-subscribeOn" class="headerlink" title="publishOn, subscribeOn"></a>publishOn, subscribeOn</h1><p>위에 이슈를 보면 publisher에 subscriber를 등록하면 메인스레드가 아닌 다른 스레드가 진행함으로써 메인은 계속 진행되도록 만들고 싶었습니다 우리는 publishOn을 이용하여 처리하는방법을 보도록 하겠습니다 결국 간단하게 처리한다면 위에 코드에 pub.subscribe(sub)이라는 코드를 스레드로 감싸주면 되겠죠 <a href="http://ahea.files.wordpress.com/2017/02/a8d16b50c36e94e68a14f6f2160ddf61.png" target="_blank" rel="noopener"><img src="https://ahea.files.wordpress.com/2017/02/a8d16b50c36e94e68a14f6f2160ddf61.png" alt=""></a> 하지만 매번 메인 메소드에 이런 코드가 직접 뜬다는것은 구조상 부담스러운 일입니다 이때 우리는 publishOn방식을 이용하여 해결해보려고 합니다. 이방식은 쓰레드를 위한 퍼블리셔로 한번 더 감싸서 이 퍼블리셔가 쓰레드를 열어주는 것입니다. 뭐래는지 하나도 모르겠죠, 코드로 보겠습니다. <a href="http://ahea.files.wordpress.com/2017/02/621d24b61738e06dd535abacfbabd4bf.png" target="_blank" rel="noopener"><img src="https://ahea.files.wordpress.com/2017/02/621d24b61738e06dd535abacfbabd4bf.png" alt=""></a> 이것은 퍼블리셔입니다, 원래라면 퍼블리셔 안에는 subscription을 만들고 request 메소드를 구현해서 ~~ 하는 코드들이 있었습니다. publishOn은 이곳에서 원래 기존에 퍼블리셔에세 자신이 가지고 있는 퍼블리셔를 쓰레드를 통해 전달해줍니다. 그러면 기존 퍼블리셔는 subscriber를 전달 받아서 프로세스를 진행하게 되는것이죠 <img src="https://ahea.files.wordpress.com/2017/02/ac40781cb9be1f0586f2fbd98c656798.png" alt=""> 결국 마지막에 pub.subscribe(sub)이였던 코드를 위와 같이 바꿔주면 pubOnPub이 동작하게 되겠죠 실제 실행결과를 보면 놀랍게도 다음과 같이 바뀌었습니다 <a href="http://ahea.files.wordpress.com/2017/02/9f9387c68e705f55f7be4bfb58507f56.png" target="_blank" rel="noopener"><img src="https://ahea.files.wordpress.com/2017/02/9f9387c68e705f55f7be4bfb58507f56.png" alt=""></a> 기존 메인메소드에서 모든것이 다 진행됬던것과 달리 스레드 하나가 올라와서 publisher와 subscriber의 로직을 처리하고 있습니다 더 놀라운것은 메인메소드 가장 마지막에 찍었던 exit로그가 가장 먼저 실행이 되었고 그 다음 subscriber로직이 타게 되었습니다 아마도 메인스레드는 exit를 찍고 끝났을것입니다. 하지만 subscriber를 처리하는 스레드는 메인메소드가 끝나도 계속 진행하고 있었을 겁니다. 이 안에서도 문제는 있습니다. subscription의 request와 subscriber의 onNext는 같은 메소드로 진행되고 있습니다 이것은 어떤 문제가 생기냐면 onNext에서 작업이 오래 걸릴경우 다음 데이터를 보내야 하는 subscription은 대기하게 됩니다. 보내줄 데이터는 많은데 받을 아이는 역량이 부족하여 빨리 처리 못하고 있는 상태인거죠 이때는 반대로 subscribeOn을 이용하여 문제를 해결할 수 있습니다 아까 publishOn은 쓰레드를 대신 담당하는 Publisher를 만들었습니다. subscribeOn도 마찬가지 입니다. 쓰레드를 담당하는 subscriber를 만들면 됩니다 <a href="http://ahea.files.wordpress.com/2017/02/7a611e4bf4339723b177ef126ecd7e6b.png" target="_blank" rel="noopener"><img src="https://ahea.files.wordpress.com/2017/02/7a611e4bf4339723b177ef126ecd7e6b.png" alt=""></a> subscribeOn 객체를 만들었습니다. 내용을 보면 각각 메소드 모두 스레드를 올려서 기존 subscriber에게 작업을 전달합니다 그리고 publisher에 등록을 subscribeOn객체를 줬습니다. 이렇게 하면 어떻게 진행이 될까요? publisher에 등록을 하면 subscribeOn의 onSubscribe가 실행이 될거고 스레드를 열어서 원래 동작해야 할 애를 호출해줍니다 마찬가지로 onNext는 request에서 데이터를 보내주면 subscribeOn이 받아서 스레드를 열어서 원래 동작해야 할 애의 onNext를 호출해줍니다. 파라미터를 그대로 전달하면서 말이죠 결과 화면을 보시죠. <a href="http://ahea.files.wordpress.com/2017/02/eba4b3191f303cb4cc1ba30a946a103d.png" target="_blank" rel="noopener"><img src="https://ahea.files.wordpress.com/2017/02/eba4b3191f303cb4cc1ba30a946a103d.png" alt=""></a> 실행결과를 보면 Subscriber에서 호출되는것들이 각각 메소드에서 동작하고 있음을 확인 할 수 있습니다 만약 onNext의 작업이 오래 걸려도 Subscription은 다음 데이터를 보내줄것입니다. 왜냐면 처음 onNext를 보낸 스레드는 이미 끝났고 아직 onNext를 처리하는 스레드는 새로 만들어진 스레드가 진행중이기 때문에 interrupt하고 있지 않죠. 이 두개를 같이 쓰는 방식을 보면서 publishOn, subscribeOn 의 간략한 설명은 마치겠습니다 <a href="http://ahea.files.wordpress.com/2017/02/fe7fa0423560c12961de476a417c1989.png" target="_blank" rel="noopener"><img src="https://ahea.files.wordpress.com/2017/02/fe7fa0423560c12961de476a417c1989.png" alt=""></a></p><h1 id="Spring에서-subscribeOn-publishOn"><a href="#Spring에서-subscribeOn-publishOn" class="headerlink" title="Spring에서 subscribeOn, publishOn"></a>Spring에서 subscribeOn, publishOn</h1><p>Spring에서는 아주 쉽게 api에서 지원해주고 있습니다 Flux에서 publishOn과 subscribeOn메소드를 주고 있습니다 <a href="http://ahea.files.wordpress.com/2017/02/4656c530c29f9dd0ef32e896f5410cac.png" target="_blank" rel="noopener"><img src="https://ahea.files.wordpress.com/2017/02/4656c530c29f9dd0ef32e896f5410cac.png" alt=""></a> range는 1부터 10까지 데이터를 가져가는것이고 밑에 publishOn 을 넣었습니다 Schedulers.newSingle 을 통해 스레드를 관리하게 됩니다. 밑에는 log를 출력해주는 log(), 그리고 밑에는 subscribeOn 을 사용하였습니다 마지막으로 subscribe에서는 출력을 해주고 있네요 실행결과를 보겠습니다 <a href="http://ahea.files.wordpress.com/2017/02/b977f7f05eac99e90b37a2ac6e74f747.png" target="_blank" rel="noopener"><img src="https://ahea.files.wordpress.com/2017/02/b977f7f05eac99e90b37a2ac6e74f747.png" alt=""></a> 디테일하게 찍혀있는 로그는 Flux.log()에서 나오는 로그입니다. 스레드 정보를 보기에 좋습니다. 메인메소드는 시작하자마자 로그 한줄 찍고 끝났고, publishOn이 진행됩니다 또 보면 sub-1과 pub-2가 두개가 띄어있습니다, 즉 request하는 스레드와 onNext하는 스레드가 다른 스레드로 동작하고 있음을 확인할수 있습니다</p><h1 id="정리"><a href="#정리" class="headerlink" title="정리"></a>정리</h1><p>이렇게 스프링에서 publishOn과 subscribeOn을 통해 Reactive를 병렬적으로 처리할수 있도록 하는 방법을 알았고 그것들이 어떻게 동작되는지 살펴봤습니다.</p>]]></content>
      
      
      <categories>
          
          <category> reactive </category>
          
      </categories>
      
      
    </entry>
    
    <entry>
      <title>Java JDBC</title>
      <link href="/2017/02/20/java-jdbc/"/>
      <url>/2017/02/20/java-jdbc/</url>
      
        <content type="html"><![CDATA[<p>BC자바에서 데이터베이스에 접속 할수 있는 API를 제공하는데 그게  <a href="https://ko.wikipedia.org/wiki/JDBC" target="_blank" rel="noopener"><strong>JDBC</strong>(Java Database Connectivity)</a> 입니다.</p><p><img src="https://ahea.files.wordpress.com/2017/02/untitled-diagram.png" alt="untitled-diagram"></p><p>자바 JDBC와 DB벤더들</p><p>JDBC API는 Java에서 가장 로우레벨의 데이터베이스 API 입니다. 그래서 SQL을 실행하는 데도 매우 번잡한 코드가 필요하고 DB에 따라 일관성없는 예외체크를 해야 하며 SQL은 코드 내에서 문자로 제공해야 하는 불편을 감수해야 한다. 커넥션과 같은 공유 리소스를 제대로 처리하지 않으면 시스템의 자원이 바닥나는 심각한 버그를 심어놓을 수도 있다.</p><p><img src="https://ahea.files.wordpress.com/2017/02/springjdbc.png" alt="springjdbc"></p><p>Spring JDBC</p><p>spring 에서는 jdbc를 확장해서 만든 jdbctemplate을 이용하여 데이터베이스에 접근을 합니다.</p><p>jdbctemplate은 JDBC API를 가지고 템플릿콜백패턴을 통해 간결함과 리소스 처리를 함으로써 비즈니스로직에 집중할수 있게 하였고 데이터베이스마다 다른 exception핸들링을 통하여 데이터베이스 예외처리를 획일화 하였습니다.</p><p><img src="https://ahea.files.wordpress.com/2017/02/dataaccessexception.gif" alt="DataAccessException.gif"></p><p>스프링 Exception 핸들링</p><p>spring data 는 JDBC뿐만 아니라 JPA와 각각의 클라이언트를 제공하던 NoSQL들도 제공 함으로써 Spring에서 가장 대표적으로 사용하는 Dao Access 프레임워크가 되었습니다.</p><p>Repositories, Templates, Object Mapping과 트랜잭션동시지원, 간편한 설정등의 기능을 더하고 확장 하였습니다.</p><p><img src="https://ahea.files.wordpress.com/2017/02/image8.png" alt="Image.png"></p><p>Spring Data와 서브 프로젝트들</p><p>spring data 서브프로젝트 중에서는 Repository만 구현해도 자동으로 CRUD및 Paging, sort 기능을 자동으로 생성되는 프로젝트들도 있습니다.</p><p>spring data의 기능은 Repository에 crud, paging, sort 기능을 함유 커스텀 Repository 하고 있고 각종 유틸과 QueryDSL에 관련된 서포트툴이 있어</p><p>QueryDSL의 TypeSafe한 쿼리문을 작성하기에 용이 합니다.</p><p><img src="https://ahea.files.wordpress.com/2017/02/querydsl.png" alt="querydsl"></p><p>QueryDSL 동작</p><p><a href="http://www.querydsl.com/static/querydsl/4.0.1/reference/ko-KR/html_single/" target="_blank" rel="noopener">QueryDSL</a>은 정적 타입을 이용해서 SQL과 같은 쿼리를 생성할 수 있는 프레임워크다. 문자열이나 XML에 쿼리를 작성하는 대신 QueryDSL이 제공하는 플루언트(Fluent) API를 이용해서 쿼리를 생성할 수 있다.</p><ul><li>IDE의 코드 자동 완성 기능 사용</li><li>컴파일 시점에서 잘못된 쿼리를 허용하지 않음</li><li>도메인 타입과 프로퍼티를 안전하게 참조할 수 있음</li><li>도메인 타입의 리팩토링을 더 잘 할 수 있음</li></ul><p>예제 프로그램을 통해서 자바 JDBC, Spring JDBCTemplate, Spring data jdbc 알아 보겠습니다.</p>]]></content>
      
      
      
        <tags>
            
            <tag> java </tag>
            
            <tag> JDBC </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>3. Spring batch domain - job</title>
      <link href="/2017/02/17/3-spring-batch-domain-job/"/>
      <url>/2017/02/17/3-spring-batch-domain-job/</url>
      
        <content type="html"><![CDATA[<p>아래 보이는 다이어그램은 수십년간 사용된 Batch 아키텍쳐의 단순화된 버전입니다.</p><p>이것은 배치처리과정에 대한 domain 을 대략적으로 구성해서 보여줍니다. 스프링 배치는 견고하고 유지보수가 용이한 구현을 제공합니다.</p><p><img src="https://ahea.files.wordpress.com/2017/02/image7.png" alt="image"> JobLauncher로 작업을 실행하고 현재 실행중인 프로세스에 대한 메타 데이터를 JobRepository에 저장합니다.  </p><p><strong>1. Job</strong></p><p>Job 은 배치 프로세스에서 캡슐화 되있는 entity이고 단순히 Step을 위한 컨테이너입니다. </p><p>projet에서 job은 xml이나 java base 컨피그 설정을 할 수 있습니다.</p><p><img src="https://ahea.files.wordpress.com/2017/02/image11.png" alt="image1"></p><p><strong>JobInstance</strong></p><p>다이어그램의 ‘EndOfDay’작업과 같이 하루가 끝날 때 한 번 실행해야하는 배치 작업을 생각해보면, 하루에 하나의 ‘EndOfDay’작업이 존재하고, 이것은 1 월 1 일 및 1 월 2 일이 실행됩니다. JobInstance는 실패했을때 여러번 돌릴 수 있으며, 성공시 생명주기가 끝나게 됩니다.</p><p>이미 완료된 JobInstance를 돌리려고 한다면 에러를 발생시킵니다.</p><p><strong>JobExecution</strong></p><p><code>JobExecution</code><strong>은 한번 시도 되는 job의 개념입니다. </strong>EndOfDay 을 예로 들면 만약 01-01-2008에 돌리는 Job을 실패했을때, 같은 파라미터(01-01-2008 )로  돌리면 새로운 <code>JobExecution</code> 가 생성됩니다. 그러나 <code>JobInstance</code> 은 여전히 하나입니다.</p><p><img src="https://ahea.files.wordpress.com/2017/02/image31.png" alt="image3"></p><p>JobExecution 의 코드를 보면 상태, 시작시간, 종료시간이 있고 기타 필요한것들이 들어 있습니다.</p><p>정리하면 Job과 JobParameter가 JobInstance를 만들고 이게 실행되는데 실행되는 시도가 JobExecution1 입니다.</p><p>이때 JobInstance가 실패해서 한번 더 시도 하면 JobExecution2 가 생기고 JobExecution에 위에와 같은 메타 정보가 저장됩니다.</p><p>Job 을 등록하는 예제입니다.</p><p>@Bean</p><p><code>public Job job() { return jobBuilderFactory.get(JOB_NAME) .start(StepName) .build();</code>    }   <strong>JobBuilderFactory 는 get으로 builder를 얻어오고 job repository를 초기화 시킵니다. </strong> <img src="https://ahea.files.wordpress.com/2017/02/image41.png" alt="image4"></p><p>JobBuilder는 start를 호출하고 step 이름을 넘겨서 SimpleJobBuilder를 호출함.</p><p>step을 호출할때  fluent method chaining이 됩니다.</p><p><img src="https://ahea.files.wordpress.com/2017/02/image51.png" alt="image5"> SimpleJobBuild는 build를 호출하면서 job에 Steps을 set하고 job을 리턴합니다. <img src="https://ahea.files.wordpress.com/2017/02/image61.png" alt="image6"></p><p><strong>2. Step</strong></p><p><strong> 모든 Job은 하나 이상의 단계로 이루어져 있습니다. Step에는 실제 배치 처리를 정의하고 제어하는 데 필요한 모든 정보가 들어 있습니다.</strong></p><p>Step Execution 하나의 step을 실행하는 한번의 시도. 시작시간, 종료시간,상태, 종료상태, commitCount, itemCount 의 속성을 가지고, Job 과 Step 그 연관관계와 개념은 가이드 소스를 보면서 진행하도록 하겟습니다. 참고 : <a href="http://open.egovframe.go.kr/nforges/information/filearchive/6179/.do" target="_blank" rel="noopener">http://open.egovframe.go.kr/nforges/information/filearchive/6179/.do</a> <img src="https://ahea.files.wordpress.com/2017/02/eca095eba6ac.png" alt="%ec%a0%95%eb%a6%ac"></p>]]></content>
      
      
      <categories>
          
          <category> spring batch </category>
          
      </categories>
      
      
    </entry>
    
    <entry>
      <title>2. Spring Batch Admin</title>
      <link href="/2017/02/17/2-spring-batch-admin/"/>
      <url>/2017/02/17/2-spring-batch-admin/</url>
      
        <content type="html"><![CDATA[<p>스프링 배치 어드민은 스프링은 오픈소스 프로젝트이며, 스프링배치에 대한 유저인터페이스를 웹 베이스로 제공합니다.</p><p>spring boot 와 spring admin을 연동시켜보았습니다.</p><p>- maven dependency 추가</p><p><img src="https://ahea.files.wordpress.com/2017/02/image.png" alt="image"></p><p><img src="https://ahea.files.wordpress.com/2017/02/image1.png" alt="image1"></p><p><img src="https://ahea.files.wordpress.com/2017/02/image2.png" alt="image2"></p><p>spring admin batch 에서 web 설정을 그대로 쓰기 위해 servlet-config, webapp-config 설정을 가져옵니다.</p><p><img src="https://ahea.files.wordpress.com/2017/02/image6.png" alt="image6"></p><p><img src="https://ahea.files.wordpress.com/2017/02/image3.png" alt="image3"></p><p>- mainConfiguration을 import하고 bootRun을 하면 콘솔에서 접근가능한</p><p>url들이 나타납니다.</p><p><img src="https://ahea.files.wordpress.com/2017/02/image4.png" alt="image4"></p><p>http:도메인/home 으로 들어가면 다음과 같이 페이지가 뜹니다.</p><p><img src="https://ahea.files.wordpress.com/2017/02/image5.png" alt="image5"></p><p>spring IO 에서 spring batch에 대한 소식을 봤는데 버전 2.0.0.M1 이 릴리즈 되면서 다양한것들이 가능해졌습니다.</p><p>[… will now support JSR-352 configured jobs. By dropping your XML based configuration in the <code>/META-INF/batch-jobs</code> directory as the spec requires, Spring Batch Admin will load the job to be launchable by the REST endpoints and the current UI. All of the monitoring aspects provided by Spring Batch Admin (viewing the executions, start/stop/restart, etc) are available.]</p><p>2.0.0.M1 release로 바뀌면서 JSR-352(배치 처리를 위한 JSR 표준)를 더이상 지원하지 않습니다.</p><p>더이상 xml 베이스로 된 설정파일을 읽지 않고 UI에서 REST로 처리되고 모든 배치 진행중인 상황을 볼수 있습니다. 라고 써있네요.</p><p>batch의 진행상황을 보고 싶으면 batch admin을 추가해서 쉽게 확인 가능할것 같습니다.</p><p>spring batch 에 대한 기본 이해 후 batch admin의 사용법을 알아보겟습니다.</p><p>참고 : <a href="http://docs.spring.io/spring-batch-admin/getting-started.html" target="_blank" rel="noopener">http://docs.spring.io/spring-batch-admin/getting-started.html</a></p>]]></content>
      
      
      <categories>
          
          <category> spring batch </category>
          
      </categories>
      
      
    </entry>
    
    <entry>
      <title>Spring Reactive</title>
      <link href="/2017/02/15/spring-reactive/"/>
      <url>/2017/02/15/spring-reactive/</url>
      
        <content type="html"><![CDATA[<p>Reactive 글 모음</p><ol><li><a href="https://ahea.wordpress.com/2017/02/02/iterable%ec%99%80-observable%ec%9d%98-%ea%b0%9c%eb%85%90/" target="_blank" rel="noopener">Iterable와 Observable의 개념</a></li><li><a href="https://ahea.wordpress.com/2017/02/03/reactive-history/" target="_blank" rel="noopener">Reactive History</a></li><li><a href="https://ahea.wordpress.com/2017/02/13/reactive-streams/" target="_blank" rel="noopener">Reactive Streams</a></li><li><a href="https://ahea.wordpress.com/2017/02/13/rxjava/" target="_blank" rel="noopener">RxJava</a></li><li><a href="https://ahea.wordpress.com/2017/02/15/spring-reactive/" target="_blank" rel="noopener">Spring Reactive</a></li><li><a href="https://ahea.wordpress.com/2017/02/20/reactive-publishon-subscribeon/" target="_blank" rel="noopener">Reactive PublishOn, SubscribeOn</a></li></ol><hr><p>spring.io는 Java9과 함께 Reactive 아키텍처를 지원하는 Spring 5 버전을 내놓겠다고 발표했습니다. 그리고 현재 2017년 2월 중순 기준으로 5.0.0 M4가 릴리즈 되었습니다. 아직 Java9이 아직 릴리즈되지 않은 상태에서 spring.io가 조금 앞서 발빠르게 대응할 준비를 하고 있습니다. 개인적으로 Java 서버 개발에 아주 많은 점유율을 가지고 가고 있는 spring framework가 4.x대부터 변화하려는 것들을 보고 많이 놀랬는데 이번에도 놀랄 준비를 해야겠습니다. 특히 서버 사이드에서 Reactive Programming에 대한 필요는 늘어나고 있는데 spring이 이것을 제공해준다면 개발자들은 한발더 손쉽게 개발을 할수 있겠네요. Spring5에서부터는 java 8이상이여야 하고 servlet3.0 이상이여야 하는데 국내시장에서도 물론 많은 기업들이 java와 servlet버전을 올리고 있지만 기존 레거시 버전을 유지하려는 기업 또는 소프트웨어들이 많은 상태에서 과연 Spring5가 국내에서 얼마만큼 영향을 줄지는 미지수입니다. 하지만 spring이 트랜드에 따라 잘 쫒아가주고 있는 것을 보면 다른 언어에 뒤지지 않는 개발 생태계를 계속 끌어주고 있는거 같습니다. java가 끌고가는건지 spring이 끌고가는건지 모르겠네요… (java = spring은 아니지만 java개발자라고 불리는 사람들 중 스프링을 이용하여 개발하지 않는 분들이 얼마나 계실런지 모르겠습니다) 이번 포스팅에서는 spring에서 제공하는 reactive programming 예제를 살펴보면서 앞으로 사용하게 될지도 모를 spring reactive를 미리 경험해보도록 하겠습니다.</p><h1 id="Project-Reactor"><a href="#Project-Reactor" class="headerlink" title="Project Reactor"></a>Project Reactor</h1><p>Spring Reactive는 Reactor Core라는것을 사용하고 있습니다. Reactor Core는 Project Reactor의 프로젝트이며, 아직 다 완성되진 않았지만 Java9의 java.util.concurrent.Flow도 들어갈것으로 보입니다. Spring Reactor는 non-booking을 충분히 제공해주는 Reactive Streams라이브러리이며 많은 팀들이 조인하였는데 이중 spring.io가 눈에 보이네요 <a href="http://ahea.files.wordpress.com/2017/02/36dd6ff0b61eb5d0dc4ec0962ac18fb0.png" target="_blank" rel="noopener"><img src="https://ahea.files.wordpress.com/2017/02/36dd6ff0b61eb5d0dc4ec0962ac18fb0.png" alt=""></a> Project Reactor에는 Reactor Core, Reactor Test, Reactor IPC, Reactor Netty 4가지 프로젝트가 있으며 이중 Reactor Core가 Spring Reactive에 들어간 것입니다. <a href="https://github.com/bclozel/spring-boot-web-reactive" target="_blank" rel="noopener">스프링부트-reactor</a>를 통해 예제를 살펴볼텐데, 기존에 처음보는 React Core의 클래스를 몇가지 살펴본 후 예제를 보려고 합니다. Reactor Core의 도큐먼트를 보면 다음과 같이 나옵니다 <a href="http://ahea.files.wordpress.com/2017/02/78bf73d26438ef64c58c4600595e8afa.png" target="_blank" rel="noopener"><img src="https://ahea.files.wordpress.com/2017/02/78bf73d26438ef64c58c4600595e8afa.png" alt=""></a> 제가 지금 작성하는 날짜 기준으로 3.0.4까지 버전이 나왔는데요, 스프링에서는 2.5부터 사용하고 있습니다. 우리가 하나하나 다 볼수는 없고 아래쪽에 초록색으로 링크가 바껴있는 부분들을 몇개 보면 Reactive Streams Flux, Mono라는게 나오고 reactor.core.publisher라는게 나오는데요, publisher는 우리가 Reactive Streams 스펙에서 본 퍼블리셔라고 생각하면 될거 같고 네이밍을 보니 패키지 같은데 저 안에 퍼블리셔들이 들어있나 봅니다. Flux는 처음에는 저도 잘 몰라서 열심히 구글링을 했는데 MVC와 비교하면서 페이스북은 mvc를 버리고 flux로 갔다고 하는 그 Flux인가? 도 싶었는데 그것과 연관이 있는건지는 잘 모르겠습니다. 어쨋든 Flux는 <a href="http://ahea.files.wordpress.com/2017/02/5073b4b1c9a0d3ecd9457530bf927486.png" target="_blank" rel="noopener"><img src="https://ahea.files.wordpress.com/2017/02/5073b4b1c9a0d3ecd9457530bf927486.png" alt=""></a> publisher에 있는걸 보니 Observable인거 같네요. 마찬가지로 mono도 검색하면 많이 나오는데요, 이거도 용어가 생소해서 검색하면 닷넷이 어쩌고 하는 위키도 나오고 하는데요, 얘도 걔랑 무슨 연관이 있는지는 잘 모르겠습니다.. 용어가 참 어렵네요, 여튼 얘도 보면 <a href="http://ahea.files.wordpress.com/2017/02/433c967c9cba10dec9556f46b496e18f.png" target="_blank" rel="noopener"><img src="https://ahea.files.wordpress.com/2017/02/433c967c9cba10dec9556f46b496e18f.png" alt=""></a> 퍼블리셔 패키지에 있습니다. mono와 flux 둘다 퍼블리셔인데 무슨 차이가 있을까 보니 설명과 그림에서 차이가 납니다 우선 mono는 “at most one”이라고 해서 한건의 데이를 처리하는데 사용됩니다 <a href="http://ahea.files.wordpress.com/2017/02/55f78e1b039ebbbb50a543a067d293cd.png" target="_blank" rel="noopener"><img src="https://ahea.files.wordpress.com/2017/02/55f78e1b039ebbbb50a543a067d293cd.png" alt=""></a> (영어가 짧아서…) 결국 이 그림을 보면 mono가 데이터 한건을 처리해서 만약 operator가 잘 처리가 되었다면 원하는 데이터를 Subscriber에게 전달할 것이고, 문제가 생기면 에러를 보내주겠죠. 보면 우리가 RxJava의 예제에서 Observable.just(“hello world”)한것처럼 한건의 데이터를 처리하려고 할때 사용이 됩니다. 이게 무슨 말이면 하나의 subscription을 가질수 있다는 겁니다. 어렵지만 flux를 보면서 좀더 이해해보기로 하죠. 반대로 flux는 0에서 N개의 엘리먼트를 가질수 있고요, 그림을 보면 <a href="http://ahea.files.wordpress.com/2017/02/e185fbd78fcd6b2f862e84f9c2ecdb29.png" target="_blank" rel="noopener"><img src="https://ahea.files.wordpress.com/2017/02/e185fbd78fcd6b2f862e84f9c2ecdb29.png" alt=""></a> 한건을 처리하던 mono와 달리 여러건을 처리하고 있죠, 그림에서 만약 4번에서 에러가 난다면 mono가 그랬듯이 에러를 subscriber에게 알려줄것이고, 잘 끝나면 complete하겠죠. RxJava에서 봤지만 여러건의 데이터, 즉 iterable한 데이터는 여러개의 subscription으로 나뉘고 합쳐져서 subscriber에게 전달되는데, 그와 비슷한 개념으로 flux는 iterable한 데이터들을 mono로 바꿔서 나누고 합침으로 해서 subscriber에게 전달합니다. 즉 mono가 뭉치면 flux라고 생각해도 좋을거 같습니다(이해를 돕기위해 이렇게 설명했지만 내부적으로는 어떻게 동작하는지는 아직 모르겠습니다, 나중에 기회가 되면 까보도록 하죠) 저는 이 두가지 용어가 너무 해깔렸습니다. 특히 구글에 쳐도 잘 안나왔고, 결국 깊숙히 이해하고 스프링블로그에서 여러 글들을 계속 읽으면서(영어 읽느냐 쥐나는줄 알았습니다) Project Reactor를 알게 되었고, 이 레퍼런스를 통해 이해를 하게 되었습니다. 사실 아무것도 모를때 위에 그림도 많이 봤고, Project Reactor라는 단어도 엄청 많이 본거 같은데 아는만큼 보인다고 Reactive Programming에 대해 계속 공부하다 보니 처음과는 다르게 이제는 이해가 조금씩 가는거 같습니다. 어쨋든 mono와 flux에 대해 이상한 곳에서 내용을 찾으시면서 삽질하지 마시고 Project Reactor의 레퍼런스를 참고하시길 바랍니다</p><h1 id="Spring-boot-Reactor-샘플"><a href="#Spring-boot-Reactor-샘플" class="headerlink" title="Spring-boot Reactor 샘플"></a>Spring-boot Reactor 샘플</h1><p><a href="https://github.com/bclozel/spring-boot-web-reactive" target="_blank" rel="noopener">스프링부트-reactor</a> 해당 링크를 통해 GitHub으로 들어가셔서 소스코드를 다운로드 받으실수 있습니다. 저 링크는 어디서 봤냐면 <a href="https://spring.io/blog/2016/07/28/reactive-programming-with-spring-5-0-m1" target="_blank" rel="noopener">https://spring.io/blog/2016/07/28/reactive-programming-with-spring-5-0-m1</a> 에서 봤습니다. 기회가 되시면 Github에서 소스코드를 받으시기 이전에 내용을 한번 읽어보셔도 좋을거 같습니다 소스코드를 받으시고 압축을 푸시셔 IDE를 통해 프로젝트를 열어보시면 여러 프로젝트가 보이실겁니다 <a href="http://ahea.files.wordpress.com/2017/02/9449f765ba2c5d0dbed11123aee22777.png" target="_blank" rel="noopener"><img src="https://ahea.files.wordpress.com/2017/02/9449f765ba2c5d0dbed11123aee22777.png" alt=""></a> 이중 우리가 지금 살펴볼 것은 spring-boot-sample-web-reactive입니다. 쭉쭉 열어보시면 HomeController가 있는데요, 잠깐 살펴보고 가겠습니다 <a href="http://ahea.files.wordpress.com/2017/02/caba113bb3452894ed31ee677a24eef8.png" target="_blank" rel="noopener"><img src="https://ahea.files.wordpress.com/2017/02/caba113bb3452894ed31ee677a24eef8.png" alt=""></a> 소스가 길지 않고 메소드도 몇개 없습니다. RestController이고 3개의 메소드가 있는데요, requestMapping으로 메소드가 url과 연결되어 있습니다. starter메소드를 보면 리턴타입이 Mono로 되어 있습니다. 우리가 금방 봤던 Reactor Core에 Mono입니다. Mono.just를 하는데 RxJava에서 Observable.just하는거와 같은 느낌이네요, new BootStarter를 해서 값을 넣어주는데 BootStart는 별거 없습니다 그냥 Vo입니다. Mono는 1건만 처리한다고 했기 때문에 저렇게 한개가 들어 갔네요. 이부분이 어떻게 사용되는지 이따가 테스트 코드에서 확인해보도록 하고 넘어가겠습니다 starters메소드는 Flux를 리턴하는데요, 얘도 마찬가지로 just로 만들고 여러 BootStarter를 받고 있습니다. customArg는 다양한 어규먼트를 받는다는걸 보여주려고 하는거 같은데 우리는 위에 두개만 보도록 하죠. 이 코드를 확인해보려면 테스트 패키지에 ReactiveSampleApplicationTests 클래스를 이용하시면 됩니다. 테스트코드라 코드가 많은데요 위에서부터 조금씩 보겠습니다 <a href="http://ahea.files.wordpress.com/2017/02/ad9452eec370b388227dae8b9fe48aba.png" target="_blank" rel="noopener"><img src="https://ahea.files.wordpress.com/2017/02/ad9452eec370b388227dae8b9fe48aba.png" alt=""></a> 이 클래스는 유닛테스트를 위한 코드이고요, 저는 spring 2.5부터 쓰면서 테스트코드를 그때당시에 작성해서 보면 Repository나 Service는 테스트가 좀 쉽게 하는데, Controller부분이 좀 막막했었어요, Request나 Response를 가지고 Mock테스트를 하기가 번거롭고 어려웠던거 같습니다. 최근에는 SpringBootTest가 되서 저렇게 WebClient를 이용해서 편하게 테스트 하실수 있습니다. setup에서 저렇게 WebClient.create를 하시면 spring-boot가 올라가서 테스트를 진행해줍니다. 첫번째는 Mono테스트입니다 <a href="http://ahea.files.wordpress.com/2017/02/e1208c5aab0ddd914ee2444417c6041c.png" target="_blank" rel="noopener"><img src="https://ahea.files.wordpress.com/2017/02/e1208c5aab0ddd914ee2444417c6041c.png" alt=""></a> webClient를 이용해서 Mono를 받아오고요, Reactor Test에 있는 ScriptedSubscriber라는 Subscriber를 이용하여 데이터를 받아옵니다. 이건 좀 특이하게 Subsciber에 verify라는 메소드를 통해 Publisher를 주네요(Mono는 Publisher임을 잊지마세요) 보시면 consumeNextWith에서 assertThat으로 데이터를 체크하는 로직이 들어가 있습니다. 체크가 끝나면 expectComplete로 끝나게 되는 아주 간단한 예제입니다. 이코드를 보시고 어떻게 느끼실지는 각각 다 다르실것이고 생소하실수도 있고, 쉽게 느껴지실수도 있을거 같은데요. 우리가 바라보는 관점은 Reactive하게 데이터를 받아온다는 점을 주목하시길 바랍니다. 우선 다음으로 넘어가죠 두번째는 Flux테스트입니다 <a href="http://ahea.files.wordpress.com/2017/02/258323c8c51147c7413c9007f80229c5.png" target="_blank" rel="noopener"><img src="https://ahea.files.wordpress.com/2017/02/258323c8c51147c7413c9007f80229c5.png" alt=""></a> 테스트코드만 보자면 크게 Mono와 다른점은 없습니다. 그저 consumeNextWith가 몇개 더 늘어났을 뿐입니다. mono테스트도 마찬가지로 여러개 늘리셔도 상관 없습니다. 결국 뭐냐면 Subscriber는 얘 나름대로 독립적으로 있는것이죠, 무슨말을 하고 싶냐면 데이터가 mono이든 flux든, 데이터 한건이든 여러건이든 그건 퍼블리셔의 일이고, Subscriber는 데이터가 몇건이 오든 자신이 처리해야 할 역활을 하는것이죠.</p><h1 id="정리"><a href="#정리" class="headerlink" title="정리"></a>정리</h1><p>사실 이 샘플만으로는 과연 스프링이 버전이 올라갔을 때 내가 꼭 Reactive를 써야 할까? 라는 의문이 들수도 있을겁니다. 단순히 코드만을 보고, 동작 자체만을 보고 ‘에이 아무것도 아니네’,’쉽게 짤수 있는걸 더 복잡하게 만드는거 아니냐’ 판단하지 마시고 우리가 처음 <a href="https://ahea.wordpress.com/2017/02/02/iterable%ec%99%80-observable%ec%9d%98-%ea%b0%9c%eb%85%90/" target="_blank" rel="noopener">Observable</a>에서 시작해서 <a href="https://ahea.wordpress.com/2017/02/13/reactive-streams/" target="_blank" rel="noopener">Reactive Streams</a>, <a href="https://ahea.wordpress.com/2017/02/13/rxjava/" target="_blank" rel="noopener">RxJava</a>를 거쳐서 Spring Reactive까지 오면서, 왜, 언제 Reactive Programming을 해야 하는지에 대해 많은 고민을 해야 하고, <a href="https://ahea.wordpress.com/2017/02/03/reactive-history/" target="_blank" rel="noopener">Reactive History</a>를 통해 넷플릭스가 Reactive Programming을 도입하면서 얻은 효과들을 보면서, 우리가 넷플릭스와 같은 문제를 만났을 때 Reactive Programming을 해야 할 상황이 올때를 준비한다고 생각하시면 좋을것 같습니다.</p>]]></content>
      
      
      <categories>
          
          <category> reactive </category>
          
      </categories>
      
      
    </entry>
    
    <entry>
      <title>Spring Data</title>
      <link href="/2017/02/13/spring-data/"/>
      <url>/2017/02/13/spring-data/</url>
      
        <content type="html"><![CDATA[<p>Spring Data 프로젝트는 Spring Framework를 둘러싼 생태계의 일부이며 고급 데이터 액세스와 관련된 주제를 다루는 포괄적 인 프로젝트입니다. 여기에는 일반 관계형 데이터 저장소 (일반 JDBC 또는 JPA 기반), NoSQL (MongoDB, Neo4j 또는 Redis) 및 Apache Hadoop과 같은 대형 데이터 기술을 지원하는 모듈이 포함되어 있습니다. 이 프로젝트의 핵심 사명은 상점 별 특징과 기능을 유지하면서 다양한 데이터 액세스 기술을위한 친숙하고 일관된 스프링 기반 프로그래밍 모델을 제공하는 것입니다.</p><h2 id="특징"><a href="#특징" class="headerlink" title="특징"></a>특징</h2><h3 id="인프라-구성-지원"><a href="#인프라-구성-지원" class="headerlink" title="인프라 구성 지원"></a>인프라 구성 지원</h3><p>모든 Spring Data 프로젝트의 핵심 주제는 데이터 액세스하기위한 환경 설정을 지원하는 것입니다. 이 지원은 XML 네임 스페이스와 Spring JavaConfig를위한 지원 클래스를 사용하여 구현되어 Mongo DB, embedded Neo4j instance 등에 대한 액세스를 쉽게 설정할 수 있습니다. 또한 <a href="https://ko.wikipedia.org/wiki/JMX" target="_blank" rel="noopener">JMX(Java Management eXtensions)</a>와 같은 핵심 Spring 기능 통합이 제공됩니다. 또한 JMX와 같은 core Spring 기능과의 통합이 제공됩니다. 즉, 일부 저장소는 Spring API를 통해 JMX에 노출되는 고유 API를 통해 통계를 노출합니다.</p><h3 id="객체-매핑-프레임-워크"><a href="#객체-매핑-프레임-워크" class="headerlink" title="객체 매핑 프레임 워크"></a>객체 매핑 프레임 워크</h3><p>대부분의 NoSQL Java API는 도메인 오브젝트를 저장소의 데이터 모델 (예 : MongoDB의 Document 또는 Neo4j의 Node 및 relationships)에 맵핑하는 지원을 제공하지 않습니다. 따라서 네이티브 Java 드라이버를 사용하여 작업 할 때는 일반적으로 읽을 때 응용 프로그램의 도메인 객체에 데이터를 매핑하기 위해 상당한 양의 코드를 작성해야하며, 그 반대의 경우도 마찬가지입니다. 따라서 Spring Data 프로젝트의 핵심 부분은 매핑 및 변환 API로서 도메인 클래스에 대한 메타 데이터를 유지하여 영구 도메인 객체를 저장소 특정 데이터 유형으로 변환 할 수 있도록합니다.</p><h3 id="템플릿-API"><a href="#템플릿-API" class="headerlink" title="템플릿 API"></a>템플릿 API</h3><p>객체 매핑 API 위에는 Spring의 JdbcTemplate, JmsTemplate 등에서 이미 잘 알려진 템플릿 패턴 구현 형태로 유명한 API가 있습니다. 따라서 RedisTemplate, MongoTemplate 등이 있습니다. 이러한 템플릿은 적절한 리소스 관리 및 예외 변환을 자동으로 처리하면서 단일 명령문으로 개체를 지속하는 것과 같이 일반적으로 필요한 작업을 실행할 수있는 <strong>도우미 메서드</strong>를 제공합니다. 그 외에도 store-native API에 액세스 할 수있는 콜백 API를 노출하면서 예외는 변환되고 리소스는 적절하게 관리됩니다.</p><h3 id="Repository-추상화"><a href="#Repository-추상화" class="headerlink" title="Repository 추상화"></a>Repository 추상화</h3><p>이러한 기능은 기존 데이터베이스와 마찬가지로 데이터 액세스 계층을 구현하기위한 toolbox를 제공합니다. Spring Data는 데이터 액세스 레이어의 개발을 단순화하기 위해 템플릿 구현 위에 Repository 추상화를 제공합니다. 따라서 표준 CRUD 작업 수행 및 실행과 같은 가장 일반적인 시나리오에 대한 일반 interface 정의를 작성하기 위해 데이터 액세스 개체를 구현하려는 노력이 줄어 듭니다. 이 데이터 액세스 레이어 추상화는 여러 저장소에서 CRUD 작업을위한 이식성 계층을 제공하지만 MongoDB의 geo-spatial 쿼리와 같은 특정 기능을 저장하는 데 제한되지 않습니다. <img src="https://ahea.files.wordpress.com/2017/02/a.png" alt="a"> 스프링 데이터 리파지토리 추상화에서 중심적인 인터페이스는 Repository입니다.이것은 도메인클래스와 도메인의 id 타입을 타입아규먼트로 받습니다. 이 인터페이스는 주로 마커 인터페이스로 동작하며, 작업할 타입을 가지고 있으면서, 당신이 이것을 확장할 인터페이스를 발견하게 해줍니다. CrudRepository 는 관리되는 엔티티클래스에서 복잡한 CRUD기능을 제공해줍니다.</p><p>public interface CrudRepository&lt;T, ID extends Serializable&gt;  extends Repository&lt;T, ID> {  S save(S entity); //주어진 엔티티를 저장합니다.  T findOne(ID primaryKey); //주어진 아이디로 식별된 엔티티를 반환합니다.   Iterable findAll(); //모든 엔티티를 반환합니다.   Long count(); //엔티티의 숫자를 반환합니다.   void delete(T entity); //주어진 엔티티를 삭제합니다.   boolean exists(ID primaryKey); //주어진 아이디로 엔티티가 존재하는지를 반환합니다. <em>// … more functionality omitted.</em>  }</p><p>그다음 확장된 PagingAndSortingRepository 는 페이징 처리 및 소팅 기능을 첨부하였습니다.</p><p>public interface PagingAndSortingRepository&lt;T, ID extends Serializable&gt;  extends CrudRepository&lt;T, ID> {  Iterable findAll(Sort sort);  Page findAll(Pageable pageable);  }</p><p>그 이외 Spring data commons와 함께 쓰는 JPA와 MongDB 등등 은 PagingAndSortingRepository 를 상속 받아서 저장소 고유의 메서드를 정의 하였습니다.</p><p>@NoRepositoryBean  public interface JpaRepository&lt;T, ID extends Serializable> extends PagingAndSortingRepository&lt;T, ID> {  public List findAll();  public List findAll(Sort paramSort);  public List findAll(Iterable paramIterable);  public List save(Iterable paramIterable);  public void flush();  public S saveAndFlush(S paramS);  public void deleteInBatch(Iterable paramIterable);  public void deleteAllInBatch();  public T getOne(ID paramID);  }</p>]]></content>
      
      
      
        <tags>
            
            <tag> java </tag>
            
            <tag> spring </tag>
            
            <tag> JDBC </tag>
            
            <tag> data </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>RxJava</title>
      <link href="/2017/02/13/rxjava/"/>
      <url>/2017/02/13/rxjava/</url>
      
        <content type="html"><![CDATA[<p>Reactive 글 모음</p><ol><li><a href="https://ahea.wordpress.com/2017/02/02/iterable%ec%99%80-observable%ec%9d%98-%ea%b0%9c%eb%85%90/" target="_blank" rel="noopener">Iterable와 Observable의 개념</a></li><li><a href="https://ahea.wordpress.com/2017/02/03/reactive-history/" target="_blank" rel="noopener">Reactive History</a></li><li><a href="https://ahea.wordpress.com/2017/02/13/reactive-streams/" target="_blank" rel="noopener">Reactive Streams</a></li><li><a href="https://ahea.wordpress.com/2017/02/13/rxjava/" target="_blank" rel="noopener">RxJava</a></li><li><a href="https://ahea.wordpress.com/2017/02/15/spring-reactive/" target="_blank" rel="noopener">Spring Reactive</a></li><li><a href="https://ahea.wordpress.com/2017/02/20/reactive-publishon-subscribeon/" target="_blank" rel="noopener">Reactive PublishOn, SubscribeOn</a></li></ol><hr><h1 id="RxJava는…"><a href="#RxJava는…" class="headerlink" title="RxJava는…"></a>RxJava는…</h1><p>RxJava는 Reactive Extensions에서 JVM으로 확장된 라이브러리입니다. Reactive Extensions에 대한 내용은 <a href="https://ahea.wordpress.com/2017/02/03/reactive-history/" target="_blank" rel="noopener">Reactive History</a>에서 정리하였습니다. RxJava는 Reactive Streams 표준은 아닙니다. 그러므로 Reactive Streams와 뿌리 자체는 다르게 보는게 맞습니다. 물론 하는 역활, 즉 Reactive한 프로그래밍을 하기 위한 목적은 같습니다만 RxJava는 Reactive Extentions를 주도한 Microsoft에서 Jvm으로 옮긴 Netflix가 주도하여 개발되었다고 할수 있습니다. RxJava와 비슷하게 이름이 지어진것들을 보면 Rxjs, RxAndroid, RxSwift등등이 있는데 모두 Reactive Extentions를 뿌리로 두고 해당 환경에 맞도록 바뀌었다고 할수 있습니다.</p><h1 id="RxJava를-사용해보기"><a href="#RxJava를-사용해보기" class="headerlink" title="RxJava를 사용해보기"></a>RxJava를 사용해보기</h1><p><a href="https://ahea.wordpress.com/2017/02/02/iterable%EC%99%80-observable%EC%9D%98-%EA%B0%9C%EB%85%90/" target="_blank" rel="noopener">Iterable와 Observable의 개념</a> 에서는 Iterable과 Observable이 Duality하다고 설명했습니다. Duality에 대한 설명이 저 포스팅에서는 약했지만 아직도 저 개념을 명확하게 설명할 자신은 없군요.. 처리하려는 기능(또는 처리 결과)은 같지만 처리과정에 있어서 서로 상반되는 부분을 duality라고 하면 설명은 부족하지만 이해하기 위한 최소한은 되는지 모르겠군요. 그럼 RxJava의 기본을 살펴보겠습니다 <a href="http://ahea.files.wordpress.com/2017/02/27bb73f04047ac2753d78370ddadfdf1.png" target="_blank" rel="noopener"><img src="https://ahea.files.wordpress.com/2017/02/27bb73f04047ac2753d78370ddadfdf1.png" alt=""></a> 2-3회에 거쳐 Observable한 코드들과 Reactive Stream포스팅을 준비하다 보니 Observable한 코드는 저는 익숙해지는데 글을 보시는 분들은 어떤지 모르겠습니다. 이 코드에서 Obersavable은 Java의 Observable이 아닙니다. RxJava의 Observable입니다.(라이브러리 세팅은 다루지 않겠습니다) 자바의 Observable과의 차이점을 살펴보자면 제네릭타입이 추가가 되었군요, 해당 코드에서는 String인것을 보니 Observer에게 String을 보내주려나봅니다. Observable.create를 통해 Observable을 만들어냅니다. 이 안에는 Observable.OnSubscribe를 인수로 받는데 OnSubscribe는 어디선가 많이 본 코드이군요.(Reactive Streams 를 보시길) call메소드를 implements받는데 Subscriber를 파라미터로 받습니다. 이부분도 Reactive Streams와 매우 비슷한 구조를 가져가는데 개념적으로 어느것이든 이해하신다면 무엇을 쓰시든 빨리 적응하실수 있으실거 같습니다. 해당 코드에서는 helloWorld를 onNext로 보내줍니다(점점 소름돋습니다… Reactive Streams와 정말 비슷한녀석이군요…) 그리고 마지막으로 onCompleted를 함으로서 처리를 끝내줍니다(더이상 소름돋지 않겠습니다) Subscriber도 generic으로 타입을 받아주는군요, Subscriber는 onNext, onCompleted, onError를 받습니다. Observable의 문제점을 RxJava는 이렇게 해결해주고 있군요. 마지막으로 observable에 subscriber를 subscribe메소드로 등록해줍니다. 실행을 한다면 ‘Hello, World!’가 onNext에서 출력되겠군요… 해당 코드는 단순히 String값을 보내주는 Observable입니다. 이런 경우 더 단순하게 Observable을 만들수 있습니다</p><p> Observable myObservable = Observable.<em>just</em>(“Hello World”);</p><p>조금더 코드를 다이어트 시키기 위해 이번에는 subscribe 메소드를 보겠습니다 <a href="http://ahea.files.wordpress.com/2017/02/f457af1279562452e144e0281576666d.png" target="_blank" rel="noopener"><img src="https://ahea.files.wordpress.com/2017/02/f457af1279562452e144e0281576666d.png" alt=""></a> subscribe메소드는 몇가지 오버로드된 메소드들이 있습니다. 우리는 Subscriber를 넣어주는 메소드를 사용했군요, 그 이외에 Action1를 통한 각각 메소드를 구현하는 방법이 있군요. Action1은 람다식을 사용할때 많이 사용됩니다. 위에 코드는 onNext만 쓰기 때문에 Action1이 하나만 들어가는 메소드를 람다를 써서 코드를 줄여준다면 이렇게 되겠군요 <a href="http://ahea.files.wordpress.com/2017/02/91b3246118a7535aa6c92c00e43d5b33.png" target="_blank" rel="noopener"><img src="https://ahea.files.wordpress.com/2017/02/91b3246118a7535aa6c92c00e43d5b33.png" alt=""></a> 이게 무슨 Observable하지…??? or 지금까지 Observable을 만들고 Observer를 만들어서 쓰는 코드들을 쭉 봐왔는데 이건 그런게 없는데요… 하시는 분들은 이코드는 위의 코드가 리팩토링되었다는것을 다시한번 느끼시기 바랍니다. RxJava는 처음 코드를 이와 같이 만들어 낼수 있습니다. 만약 String으로 넘어오는 데이터 앞에 MillisTime을 찍고 싶다면? <a href="http://ahea.files.wordpress.com/2017/02/34867b2b5b1a558d77c6110698a10d06.png" target="_blank" rel="noopener"><img src="https://ahea.files.wordpress.com/2017/02/34867b2b5b1a558d77c6110698a10d06.png" alt=""></a> 이렇게 하면 Observable이 어떤 String데이터를 보냈을 때 Subscriber는 그 문자열 앞에 Long한 시간을 찍어줄것입니다 이정도면 아주 훌륭한 코드입니다. 하지만 데이터 처리와 출력을 다르게 하고 싶은 경우가 있을수 있습니다.(이정도도 충분한데…..) 이런경우 map을 이용하여 처리하면 됩니다. map은 Observable의 메소드를 말하는것입니다. map은 Func1을 파라미터로 받는데 Func1은 자바에서 functional을 쓰려고 할때 씁니다. 즉 람다를 쓰라는 뜻이죠. map을 이용하여 데이터를 처리하는부분과 출력 부분을 분리시키면 다음과 같은 결과가 됩니다. <a href="http://ahea.files.wordpress.com/2017/02/45818efa21408b73f33037cd67ecf3c4.png" target="_blank" rel="noopener"><img src="https://ahea.files.wordpress.com/2017/02/45818efa21408b73f33037cd67ecf3c4.png" alt=""></a> map은 몇개든 써도 상관이 없습니다. 만약 지금 위와 같이 변경된 문자열의 length를 구해본다면 <a href="http://ahea.files.wordpress.com/2017/02/165181408ad4f2036869f19df758c15f.png" target="_blank" rel="noopener"><img src="https://ahea.files.wordpress.com/2017/02/165181408ad4f2036869f19df758c15f.png" alt=""></a> 이렇게 쉽게 추가할수 있습니다. 기능이 분리되고 객체화 되는것이 보이십니까. 이 처리들이 Observable하게 처리되고 있지만 체감상 느껴지지 않으신가요??</p><h1 id="Iterable한-Rxjava"><a href="#Iterable한-Rxjava" class="headerlink" title="Iterable한 Rxjava"></a>Iterable한 Rxjava</h1><p>이번에는 조금더 나아가 array한 데이터를 사용해보겠습니다. 이 섹션을 시작하기전 공통으로 사용할 컨셉과 코드상에 메소드를 하나 정의하겠습니다. 우리는 검색포탈 엔진을 만들고 있습니다. 키워드를 던지면 해당 키워드가 있는 URL들을 받아 처리하려고 합니다. 우리는 query라는 메소드를 정의하여 이렇게 개발하였습니다. <a href="http://ahea.files.wordpress.com/2017/02/ca8e62da3f9c4811f89f4eb50afcd378.png" target="_blank" rel="noopener"><img src="https://ahea.files.wordpress.com/2017/02/ca8e62da3f9c4811f89f4eb50afcd378.png" alt=""></a> 원래라면 엄청난 알고리즘(?)을 이용하여 데이터를 가져와야 하는데 우리는 저 세개의 url을 무조건 줄수 있는 Observable을 리턴하기로 하죠. Subscribe에서는 저 url들을 하나하나 출력해보는 코드를 작성해보죠 <a href="http://ahea.files.wordpress.com/2017/02/4fe811c1b660d983c45bc8d9e2964c86.png" target="_blank" rel="noopener"><img src="https://ahea.files.wordpress.com/2017/02/4fe811c1b660d983c45bc8d9e2964c86.png" alt=""></a> 이렇게 하면 어떻게 될까요. query라는 메소드에서는 네이버, 구글, 카카오가 들어있는 Observable을 리턴해줄것이죠, 그리고 urls는 Observable이 들고 있는 객체(Arrays.asList한 데이터, 즉 List타입의 객체겠죠)가 넘어오겠죠, “Hello world”를 보내면 String값이 넘어올것이고, List를 보내면 List가 오겠죠 위에서는 List를 for each로 돌려서 출력했군요.. for문이 맘에 들지 않습니다. collection같은 순차적인 데이터는 java stream을 쓰든 어떻게 하든 바꾸라고 엄마가 그랬는데 말이죠… Observable에는 from이라는 메소드를 통해 Iterable한 데이터를 처리할 수 있습니다 <a href="http://ahea.files.wordpress.com/2017/02/68c2499231a7ab1987a07248ecd78c20.png" target="_blank" rel="noopener"><img src="https://ahea.files.wordpress.com/2017/02/68c2499231a7ab1987a07248ecd78c20.png" alt=""></a> query는 우리가 정의한거로 봤을때 Observable이고 그 안에 subscribe에 또 Observable을 썼네요. 재미있는 구조입니다. 이 안에 Observable.from을 통해 Iterable한 데이터를 처리하고 있습니다. 자 어렵지만 머리속으로 상상해보겠습니다. Observable.from으로 만들어진 아이는 Subscriber이 등록이 되면 Subscriber의 onNext에게 Iterable의 데이터를 하나씩 꺼내서 보내줍니다. 그러면 Subscriber는 onNext에 구현된 System.ont.println을 처리하겠군요… Obserable하게 처리되는 구조가 상상이 되시나요… (엄청 중요합니다 모른다면 저 코드를 Observable한 코드로 다시 돌아가 코드를 작성하셔서 꼭 확인하시면서 이해해보시길 바랍니다. 전 이해했으니 안하구 넘어감~) 이 코드에도 문제는 있습니다. 아까처럼 이 subscribe는 print만 하고 싶은데 iterable한 데이터 저놈 때문에 코드가 늘어났습니다. 아까는 map을 통해서 해결했습니다. 이번에는 flatMap을 사용해야 합니다. <a href="http://ahea.files.wordpress.com/2017/02/af2ae489b9962131fbd92ed355b51abb.png" target="_blank" rel="noopener"><img src="https://ahea.files.wordpress.com/2017/02/af2ae489b9962131fbd92ed355b51abb.png" alt=""></a> flatMap을 이용하여 다시한번 기존 subscribe는 출력만을 담당하고 flatMap에서 iterable한 데이터를 뭔가 잘 처리해줬습니다. String을 사용할때 사용했던 map과 flatMap은 어떤경우 사용해야 할까요… 이 답을 알기 위해 flatMap의 예제는 람다로 처리하지 않았습니다. 큰 차이점은 Iterable을 리턴하는 flatMap과, 자신의 타입(“hello world”일경우 String)을 리턴하는 map이 차이점이겠습니다. 이게 무슨 상황이냐면 Observable은 자신에게 등록된 데이터를 subscriber에 보내줍니다. 위에 단순히 네이버 구글 카카오가 등록된 List가 등록이 되었다면 네이버, 구글, 카카오를 보내는게 아니라 이것들이 들어있는 리스트 객체를 던져버린거죠. 우리는 하나하나 받고 싶었는데 말이죠.. 이런 경우 from은 각각의 요소를 분해해 늘여놓은 하나의 Observable을 만들어냅니다. 그렇게 해서 분해한 데이터를 하나하나 보내게 되는 것이죠. 즉 flatMap을 사용한다면 이론상 iterable한 데이터든, 뭐든 Observable하게만 만들어줄수 있다면 위와 같은 코드를 만들어 낼수 있다는 것입니다. 이것이 지금처럼 String array이든, 파일을 readLine하였든, 데이터베이스에서의 recordset(java에서는 resultSet이라고 하나요..)이든 다 된다는거죠 우리가 아까 했던 시간을 앞에 붙여주는것을 한다면 이렇게 되겠네요 <a href="http://ahea.files.wordpress.com/2017/02/26b6624822e4426fa56b8eae924acda9.png" target="_blank" rel="noopener"><img src="https://ahea.files.wordpress.com/2017/02/26b6624822e4426fa56b8eae924acda9.png" alt=""></a> filter 이번에는 filter에 대해 알아보겠습니다. RxJava에서는 filter를 이용해서 데이터를 골라낼수 있습니다. 만약 데이터가 null이 들어온다면 이건 걸러내고 싶습니다. 이런 경우 <a href="http://ahea.files.wordpress.com/2017/02/0ce9bbbbef424f3320de7579ecfc1543.png" target="_blank" rel="noopener"><img src="https://ahea.files.wordpress.com/2017/02/0ce9bbbbef424f3320de7579ecfc1543.png" alt=""></a> filter에서 null을 제거한 데이터만 subscriber에게 전달하게 됩니다 take 기존 Reactive Streams를 보면 subscription에 request에 몇개를 달라 파라미터를 줍니다 RxJava에는 take를 이용하여 처리합니다 <a href="http://ahea.files.wordpress.com/2017/02/2f80ed70f6f3399b8407329047c69a6c.png" target="_blank" rel="noopener"><img src="https://ahea.files.wordpress.com/2017/02/2f80ed70f6f3399b8407329047c69a6c.png" alt=""></a> take에 5를 줬다면 5개를 요청하겠군요. 5번 호출되고 onComplete가 호출되고 끝날것입니다. 우리는 onComplete를 구현하지 않았기 때문에 그냥 끝나겠네요.. doOnXX 다음과 같이 doOnNext를 사용해볼수도 있습니다. doOnNext는 OnNext가 실행될 때 호출이 됩니다. 지금같은 경우 url을 보내기 전에 saveTitle이 먼저 호출되고 그 다음에 subscriber의 onNext가 되겠죠. <a href="http://ahea.files.wordpress.com/2017/02/76c974a345ed65c918048724b7389c23.png" target="_blank" rel="noopener"><img src="https://ahea.files.wordpress.com/2017/02/76c974a345ed65c918048724b7389c23.png" alt=""></a> doOnNext이외에도 다양한 기능이 있으니 참고하면 좋을거 같습니다. <a href="http://ahea.files.wordpress.com/2017/02/2c6cb9bf328eb191db5f6d241f2d337f.png" target="_blank" rel="noopener"><img src="https://ahea.files.wordpress.com/2017/02/2c6cb9bf328eb191db5f6d241f2d337f.png" alt=""></a></p><h1 id="RxJava에서-Exception처리"><a href="#RxJava에서-Exception처리" class="headerlink" title="RxJava에서 Exception처리"></a>RxJava에서 Exception처리</h1><p>제가 본 레퍼런스에서는 최종적인 예제로 Exception처리를 설명해줬습니다. <a href="http://ahea.files.wordpress.com/2017/02/f6b11e37324c54100c8ae341537cff45.png" target="_blank" rel="noopener"><img src="https://ahea.files.wordpress.com/2017/02/f6b11e37324c54100c8ae341537cff45.png" alt=""></a> 만약 Observable에서 날라오는 데이터에 대한 유효성 체크를 본다면 해당 코드와 같은 모델이 되지 않을까 합니다. 지금은 s라는 variable에 잔뜩 붙겠습니다만 해당 데이터의 에러여부 전처리나 에러 판단, 후 처리 등을 모두 할수 있을것입니다. 하지만 RxJava는 에러처리도 깔끔하게 만들어 낼수 있습니다 <a href="http://ahea.files.wordpress.com/2017/02/a2aa648083928e69d710495dcdc95719.png" target="_blank" rel="noopener"><img src="https://ahea.files.wordpress.com/2017/02/a2aa648083928e69d710495dcdc95719.png" alt=""></a> 해당코드에는 onErrorReturn을 보셔야 합니다. 만약 에러가 날경우 어떻게 처리해야 할까요.. 코드에서 보면 onNext를 두번 잘 호출합니다만, onError를 강제로 발생시키는 코드가 있습니다. onError가 난다면 원래라면 onError가 호출되어야 하지만 이 코드에서는 onErrorReturn이 받아서 에러일경우 “return”이라는 문자열을 onNext로 보내줍니다. <a href="http://ahea.files.wordpress.com/2017/02/b11a2db17c6040ba8584eafd98a130a2.png" target="_blank" rel="noopener"><img src="https://ahea.files.wordpress.com/2017/02/b11a2db17c6040ba8584eafd98a130a2.png" alt=""></a> 해당코드에는 onErrorResumeNext가 구현되어 있는데요, 여기서는 에러가 날경우 Observable을 리턴해서 이 Observable이 진행되도록 합니다. 실행결과를 보면 <a href="http://ahea.files.wordpress.com/2017/02/4d357504858719e1e366fafa4d7eaf3b.png" target="_blank" rel="noopener"><img src="https://ahea.files.wordpress.com/2017/02/4d357504858719e1e366fafa4d7eaf3b.png" alt=""></a> 이 출력됩니다. 이 코드를 보고 순간 앗 그러면 onError 다음에 또 onNext를 하면 어떻게 되지? 라는 궁금증을 아주 살짝 했지만 원래 onError나 onComplete가 되면 Observable은 데이터를 더이상 보내지 않는다는 스펙이 있기 때문에 접었습니다. 그래도 궁금하신 분들은 해보시면 됩니다. 만약 서버가 잠깐 끊겨서 그런것이라던가, 큐가 너무 쌓여서 잠깐 안된것이라면? 다시 시도하는 코드가 있어야죠… <a href="http://ahea.files.wordpress.com/2017/02/faaf434ecc57540fb16efdaf498a30bd.png" target="_blank" rel="noopener"><img src="https://ahea.files.wordpress.com/2017/02/faaf434ecc57540fb16efdaf498a30bd.png" alt=""></a> retry를 이용해서 에러가 날경우 재시도를 합니다. retry는 숫자를 인수로 받을수 있는데 이경우에는 n번 재시도를 하며 없으면 무한으로 재시도를 합니다. retry의 조건을 조금 다양하게 만들고 싶으시다면 다음과 같이 구현하셔도 됩니다 <a href="http://ahea.files.wordpress.com/2017/02/0e4f7889bdf4d8d1026955c247914cdc.png" target="_blank" rel="noopener"><img src="https://ahea.files.wordpress.com/2017/02/0e4f7889bdf4d8d1026955c247914cdc.png" alt=""></a> retryWhen을 이용하여 디테일한 시간도 정할수 있습니다 <a href="http://ahea.files.wordpress.com/2017/02/983975c11f108d99bbe060995442e7cd.png" target="_blank" rel="noopener"><img src="https://ahea.files.wordpress.com/2017/02/983975c11f108d99bbe060995442e7cd.png" alt=""></a></p><h1 id="정리"><a href="#정리" class="headerlink" title="정리"></a>정리</h1><p>RxJava의 기본부터 Iterable한 데이터를 처리하는 법을 알아보았습니다. 또 Exception을 처리하는 방법도 알게 되었습니다. RxJava는 Java진영에서 가장 많이 사용되고 있는 Reactive Programming 라이브러리입니다. 저는 처음에는 리엑티브 프로그래밍을 하면 거대한 데이터를 처리하기에 적합한 방식으로만 개념을 이해하고 있었습니다. 하지만 api를 익히고 많은 에제들을 보면서 stream을 처리하는 좋은 방법으로 많이 와닿고 있습니다. 최근 java8이(java8이 이제 최근은 아니죠…) 나오면서 스트림, 람다를 적용할수 있게 되었고 이는 functional programming을 할수 있도록 하고 있습니다. 지금 작성한 코드들은 우리가 비즈니스 로직을 처리하는데 많이 쓰이는 아주 간단한 작업들입니다. 이런 작업들을 RxJava를 이용하여 개발한다면 우리가 작성한 코드의 구조화와 가독성이 충분히 증가할수 있으리라 생각합니다.</p><h1 id="참고"><a href="#참고" class="headerlink" title="참고"></a>참고</h1><p>RxJava와 Java8 stream이 매우 비슷한 모델을 가지고 갑니다. 이 차이점이 궁금했고 sof가 설명해줍니다. <a href="http://stackoverflow.com/questions/30216979/difference-between-java-8-streams-and-rxjava-observables" target="_blank" rel="noopener">http://stackoverflow.com/questions/30216979/difference-between-java-8-streams-and-rxjava-observables</a> 코드는 github에 올려놨지만 개인 스터디에서 작성한 코드이며 포스팅을 작성할때 코드가 좀 바꼈는데… push를 날려야 하나 말아야 하나 모르겠습니다. 우선 링크 <a href="https://github.com/devload/RxJavaExample/tree/master/src/main/java" target="_blank" rel="noopener">https://github.com/devload/RxJavaExample/tree/master/src/main/java</a></p>]]></content>
      
      
      <categories>
          
          <category> reactive </category>
          
      </categories>
      
      
        <tags>
            
            <tag> reactiveX </tag>
            
            <tag> RxJava </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>Reactive Streams</title>
      <link href="/2017/02/13/reactive-streams/"/>
      <url>/2017/02/13/reactive-streams/</url>
      
        <content type="html"><![CDATA[<p>Reactive 글 모음</p><ol><li><a href="https://ahea.wordpress.com/2017/02/02/iterable%ec%99%80-observable%ec%9d%98-%ea%b0%9c%eb%85%90/" target="_blank" rel="noopener">Iterable와 Observable의 개념</a></li><li><a href="https://ahea.wordpress.com/2017/02/03/reactive-history/" target="_blank" rel="noopener">Reactive History</a></li><li><a href="https://ahea.wordpress.com/2017/02/13/reactive-streams/" target="_blank" rel="noopener">Reactive Streams</a></li><li><a href="https://ahea.wordpress.com/2017/02/13/rxjava/" target="_blank" rel="noopener">RxJava</a></li><li><a href="https://ahea.wordpress.com/2017/02/15/spring-reactive/" target="_blank" rel="noopener">Spring Reactive</a></li><li><a href="https://ahea.wordpress.com/2017/02/20/reactive-publishon-subscribeon/" target="_blank" rel="noopener">Reactive PublishOn, SubscribeOn</a></li></ol><hr><h1 id="Observable의-문제"><a href="#Observable의-문제" class="headerlink" title="Observable의 문제"></a>Observable의 문제</h1><p>기존의 Observable을 살펴봅시다. <img src="http://ahea.files.wordpress.com/2017/02/40faf85dfe4048cf6074a6c6490b9830.png" alt=""> Observable을 상속받은 Observable은 say가 호출되면 등록된 옵저버들에게 dataArr를 하나씩 보내줍니다 <img src="http://ahea.files.wordpress.com/2017/02/5d33887faceb51a00668523be9cb44eb.png" alt=""> 그러면 등록된 N개의 옵저버들은 update라는 메소드에서 Obsavable과 보내준 데이터를 받게 됩니다.그러면 옵저버는 각자의 역활에 맞게 작업을 수행하면 되는 것이죠. 이때 몇가지 문제가 있습니다.1. 데이터가 다 왔는지 끝을 알수 없다.Observable의 기본적인 구조에서는 지금 날라온 데이터가 마지막 데이터인지 알수 없습니다. 물론 마지막이라는것을 표시해 줄수있는 토큰이나 데이터를 보냄으로써 이 문제를 처리할 수는 있지만 구조상 그런 기능을 제공해주고 있지는 않습니다.2. Exception의 처리만약 Observable에서 데이터를 처리하는데 Exception이 났을경우가 있습니다. 예를 들면 지금 예제에서는 단순히 고정된 List타입을 가지고 설명을 했지만 Database에서 값을 가져온다던지, 파일에서 값을 가져온다던지, Web에서 Request를 받는다던지 할수 있습니다. 이때 Exception이 발생할경우 이 에러는 어디서 처리해야 할까요. 상황에 따라서는 Observable에서 단독적으로 처리할 수도 있겠지만 Observer들은 에러가 났는지 알수가 없습니다. Reactive Streams는 Observable한 구조에서 이와같은 문제를 해결하려고 합니다. 물론 이와 같은 문제 이전에 비동기/동기 문제를 쉽게 해결해주고 이와같은 문제를 해결해주는 것도 하나의 중요한 초점이지만 이 문제는 Observable이 같은 특징에서 확장된 부분이기 때문에 설명하지 않았습니다.</p><h1 id="Reactive-Streams-표준"><a href="#Reactive-Streams-표준" class="headerlink" title="Reactive Streams 표준"></a>Reactive Streams 표준</h1><p>여러 기업들이 모여 Reactive Stream에 대한 표준을 정의하였습니다 (자세한 내용은 <a href="http://www.reactive-streams.org/" target="_blank" rel="noopener">http://www.reactive-streams.org/</a>)Reactive Stream의 스펙을 보면서 위의 문제를 어떻게 해결하였는지 확인하겠습니다. Reactive Stream는 구현체가 아니라 Reactive Stream을 구현하기 위한 스펙(API, 또는 Java에서는 Interface)입니다. 이 스펙에서는 4개의 interface spec이 나옵니다.</p><ul><li>Subscriber</li><li>Publisher</li><li>Subscription</li><li>Processor(얘는 Subscriber, Publisher를 상속한 아이입니다)</li></ul><p>첫번째로 Subscriber는 Observer입니다. 기존에 Observer는 Observable에 등록을 하여 데이터를 받는 역활이였습니다. 기존에 Observer와 다른점을 메소드를 보면서 확인하겠습니다.</p><p>public interface Subscriber {<br>    public void onSubscribe(Subscription s);<br>    public void onNext(T t);<br>    public void onError(Throwable t);<br>    public void onComplete();<br>}</p><p>Subscriber는 4개의 메소드를 가지며 필수적으로 implement는 하여야 합니다. 구현은 스펙에 따라 하면 되는데 스펙의 디테일한 부분은 (<a href="https://github.com/reactive-streams/reactive-streams-jvm/blob/v1.0.0/README.md#specification" target="_blank" rel="noopener">https://github.com/reactive-streams/reactive-streams-jvm/blob/v1.0.0/README.md#specification</a>) 에서 확인하면 됩니다. 이 글에서모두 설명하기에는 길기 때문에 영어가 안되도 스펙을 한번 보시면 좋습니다. onSubscribe는 최초 호출되는 메소드입니다. Subscriber를 사용할때에는 무조건 처음에 호출해야 하는 내용이 스펙에 등록되어있습니다. onNext는 기존 Observer에서 update와 같은 역활을 합니다. 데이터를 받을 때 사용됩니다. onNext는 여러번 호출될수가 있습니다. 물론 여러번 호출 되기 전 onSubscribe가 한번은 호출되야 합니다. 바로 위에 설명했듯이 Subscriber를 사용하려면 무조건 처음에는 onSubscribe가 호출되야 하는 스펙 내용이 있기 때문입니다. Observer패턴에서 문제가 있다는 부분이 onError와 onComplete로 해결됩니다. 메소드 이름에서 딱 보이다 싶히 에러가 난다면 onError, 다 끝났다면 onComplete가 호출됩니다. onError와 onComplete가 호출되면 Observable이 데이터를 더이상 보내지 않습니다( 정확히는 스펙상 보내지 않아야 합니다) 순서를 보면 이렇습니다 <img src="http://ahea.files.wordpress.com/2017/02/9afe0ddaa7613807908d01413dc32859.png" alt=""> 해당 내용을 spec에서는 이렇게 보여주고 있습니다</p><p>onSubscribe onNext* (onError | onComplete)?</p><p>이 텍스트가 위에 그림으로 설명이 됩니다. (혹시 api문서 읽으시다가 이런게 나오면 저런 flow라고 생각하면 됩니다) 두번째로 Publisher는 Obsavable입니다. Observer패턴에서는 Observer들이 Observable에 자신을 등록하는데 여기서는 Observer의 역활을 하는 Subscriber가 Publisher에 등록을 합니다</p><p>public interface Publisher {<br>    public void subscribe(Subscriber&lt;? super T&gt; s);<br>}</p><p>Subscriber는 Publisher의 subscribe메소드를 통해 등록을 합니다.(Observable에서는 addObservers) 세번째로 Subscription입니다. Subscription의 개념이 가장 중요한거 같은데 얘는 Publisher와 Subscriber 사에에서 역활을 하고 있습니다.</p><p>public interface Subscription {<br>    public void request(long n);<br>    public void cancel();<br>}</p><p>우선 Api부터 보면 request는 long타입의 파라미터를 받고 있는데 Subscriber가 이 메소드를 통해 요청을 하게 됩니다. 만약 데이터 3개가 필요하면 long파라미터에 3을 던져주면 Subscription은 3개를 던져주게 되죠. 만약 데이터가 10개정도가 있다고 하고 Subscriber가 한번에 3개씩 처리할수 있을때 request를 4번 호출하면 데이터가 3개-&gt;3개-&gt;3개-&gt;1개를 보내주는 것을 하게 되겠죠. 이때 request는 subscribe의 onNext를 통해 3개의 데이터를 전달합니다. Subscriber와 Subscription은 요청자와 응답자의 관계가 되겠군요. cancel은 메소드명 그대로 취소할때 사용됩니다. 만약 thread의 위에서 진행되고 있다면 cancel메소드의 일이 많아지겠군요. 스펙에서도 must be thread-safe라고 얘기하고 있습니다. cancel이 된다면 request는 멈춰야 겠죠. 4번째인 Processer는 Subscriber와 Publisher가 합쳐진 아이이기 때문에 설명은 생략합니다. 대충 스펙을 통해 Reactive Streams 표준을 확인했지만 실제 구현된 내용을 확인해봐야죠. Reactive Streams예제Reactive Streams가 제공해주는 예제는 개인적으로 봤을 때 정말 예술입니다만, 개념 자체를 이해하기에는 많은 양이 코드와 기능이 들어가 있습니다. 저는 심플하게 모든 스펙을 구현하지 않고 데이터 흐름만을 볼수 있도록 작성해봤습니다<a href="https://github.com/devload/RxJavaExample/blob/master/src/main/java/ReactiveStreamSample.java" target="_blank" rel="noopener">https://github.com/devload/RxJavaExample/blob/master/src/main/java/ReactiveStreamSample.java</a> <img src="http://ahea.files.wordpress.com/2017/02/af99a7001b5889a906918a49ad6a5dc4.png" alt=""> <img src="http://ahea.files.wordpress.com/2017/02/05e5639d9d19f8eba427d963be838e6b.png" alt=""> 저의 샘플 같은 경우에는 Publisher와 Subscription을 같이 구현했습니다. publisher의 subscribe메소드에는 1부터 10까지 가지고 있는 stack이 있습니다. subscriber의 onSubscription을 호출하게 되는데 이부분은 api spec에서 최초로 한번 호출해야 하는 부분이고 여기서는 inner클래스로 넣었습니다. cancel은 구현하지 않았으며 request를 보면 요청할 갯수를 파라미터로 받고 요청한 l개 많큼 스택에서 꺼내서 subscriber의 onNext를 통해 전달합니다. 만약 비어 있으면 onComplete를 호출하고요.즉 1부터 10까지 보내주는 Subscription입니다. <img src="http://ahea.files.wordpress.com/2017/02/7168660c3be86ea52235868b33935e02.png" alt=""> Subscriber는 onSubscribe, onNext, onError, onComplete를 구현하는데 대부분 가져온 데이터를 찍어보는 식으로 했습니다.여기서 주목할 것은 onSubscribe에서 subscriber에게 request를 날리는데, 1을 날렸으면 Subscription에서는 1개씩 onNext에게 데이터를 보내게 됩니다. onNext를 통해 데이터를 받아오면 해당 데이터를 처리하고 다시 request를 날립니다.마지막 줄에는 밖에서 publisher에 subscriber를 등록하는 코드가 깨알같이 캡쳐에 포함되었네요실행하면 다음과 같이 나옵니다 우선 단순하게 모든 스펙을 구현하지는 않았지만 api기준에 맞게 흐름을 태워봤습니다. 단순히 이것이 어떻게 우리의 개발하는 부분에서 적용이 될지는 아직 모르겠습니다. 하지만 우리는 개발자이기 때문에 단순한 이런 예제를 가지고 봤지만 다양한 스펙과 환경을 상상해볼수 있습니다. 만약 Subscription에서 줄 데이터가 DB에서 가져오는 데이터일경우 지금처럼 스택에서 꺼내오는 코드가 아닌 다른 jdbc코드가 될수 있겠죠, 또 만약 Subscriber에서 단순 System.out.println이 아닌 FileOutput이 될수도 있고 다른 네트워크로 http Rest방식으로 데이터를 쏠수도 있고요, 또~ 만약 Subscriber에서 onSubscribe가 최초 호출되었을때 ThreadPool을 10개를 세팅하고 request(10)을 해서 onNext에서는 데이터 하나당 스레드를 하나씩 줘서 처리를 하게 만들수도 있고요… 또~~ 만약에 Publisher에 등록된 Subscriber의 타입에 따라 비즈니스에 맞게 Subscription을 종류별로 만들어서 줄수도 있고요~~ 또~~~ 만약에 Publisher와 Subscription은 프레임워크에서 이미 구현이 되어 있다면? 우리는 그 구조에 맞게 Subscriber를 구현해주면 되겠죠 이렇게 생각하면 끝이 없겠네요..</p><h1 id="정리"><a href="#정리" class="headerlink" title="정리"></a>정리</h1><p>Reactive Stream에 대해 간략히 알아봤습니다. Reactive Stream을 이용하면 엄청난 소프트웨어를 만들수 있고, 난 심플한 코드 몇줄로 어썸~한 코드를 만들어 낼수 있을꺼야 라고 생각하셨다면, 조금더 Reactive Streams를 이해하셔야 겠습니다. 제가 여기서 소개한 Reactive Streams는 표준을 위한 api 스펙이며 구현체는 제각각입니다. 여러 구현체들이 있을수 있겠지만 이중 RxJava라는 것은 어떤지 다음에 보겠습니다.</p>]]></content>
      
      
      <categories>
          
          <category> reactive </category>
          
      </categories>
      
      
    </entry>
    
    <entry>
      <title>1. Spring batch 소개.</title>
      <link href="/2017/02/12/1-spring-batch-ec-86-8c-ea-b0-9c/"/>
      <url>/2017/02/12/1-spring-batch-ec-86-8c-ea-b0-9c/</url>
      
        <content type="html"><![CDATA[<p>0. Why Spring Batch</p><p>기존 배치 프로그램 [A씨의 배치 개발 일상] A씨는 배치 개발을 위해 개발을 시작한다. A씨는 DB에 자신있어서 프로시저를 애플리케이션에서 호출해서 쓰고, 스케줄러는 DB 스케줄러를 쓰기로 한다. 기껏 JPA로 DB에 독립적으로 만들어놨는데 프로시저를 호출함으로 써 DB에 다시 종속적으로 포함됬다. 프로시저를 작성하고 DB 스케줄러를 등록하면서 개발을 완료했다. 테스트 과정에서 갑자기 이유없이 배치가 정지되는 상황이 생기고, 비정상적으로 중단된것을 알지 못했다. 확인 결과 한꺼번에 많은 양이 몰려서 발생한 에러였고, A씨는 밤새 비정상 정지되었던 배치를 다시 돌리는 로직을 추가 했으며 A씨는 배치가 돌았는지 쿼리를 실행해보고 확인한다. 현업에서 배치프로그램을 쓰다가 수정요청사항이 와서 A씨의 후임 개발자 B씨가 배치 프로그램을 수정해야 하는 상황이 발생했다. B씨는 소스를 보고 파악하려고 했으나 코드에서 프로시저를 호출하는 부분만 있고, 스케줄은 어떻게 도는지는 소스만 보고 파악을 하지 못한다. 또한 프로시저에 익숙하지 않은 B씨는 유지보수에 애로사항을 겪는다. B씨는 정상적으로 쿼리가 돌았는지 확인하기 위해 쿼리를 받았지만 실서버에서 쿼리를 날려보지 못하고, 로그를 보며 잘 실행되었는지 일일히 확인한다. 실제 본인이 겪은 경험과 주변에서 배치를 사용하면서 겪었던일들을 페르소나를 통해 풀어봤습니다. 이문제들을 Spring Batch와 Spring Admin을 통해서 해결해보도록 하겟습니다. 1. spring batch를 쓰고 프로시저를 제거 -&gt; db 독립적(JPA를 사용한다는 가정) -&gt; 프로시저를 알지 못해도 유지 보수 가능. 2. spring admin 사용으로 비정상 종료 확인 -&gt;  Web based administration interface 3. batch와 스케줄러(Quartz, 티볼리, Control-M )사용으로 소스만 보고 로직 파악 4. 배치를 다시 돌리는 로직을 추가 -&gt; Start/Stop/Restart 5. 한꺼번에 많은 양이 몰려서 발생한 에러 -&gt; Chunk based processing Features 참고 : <a href="http://projects.spring.io/spring-batch/" target="_blank" rel="noopener">http://projects.spring.io/spring-batch/</a> Batch란</p><p><img src="https://ahea.files.wordpress.com/2017/02/batch1.png" alt="batch.png"></p><p>Batch 는 일괄적으로 처리되는 용어이며 Spring batch는  생산성 향상, POJO 기반 개발 접근법, 그리고 사람들이 Spring Framework에서 알게 된 일반적인 사용 편의성을 기반으로 합니다. Quartz, 티볼리, Control-M 등과 같은 다양한 엔터프라이즈 스케줄러가 있고,  스프링 배치는 스케줄러를 교체하지 않고 스케줄러와 함께 작동하도록 설계되었습니다. Spring Batch는 로깅 / 추적, 트랜잭션 관리, 작업 처리 통계, 작업 재시작, 건너 뛰기 및 자원 관리를 포함하여 많은 양의 레코드를 처리하는 데 필수적인 재사용 가능한 기능을 제공합니다.</p><p>1. Spring Batch Introduction</p><p>엔터프라이즈 도메인 내의 많은 애플리케이션은 비즈니스 운영을 수행하려면 대량의 처리가 필요합니다.  이러한 비즈니스 운영은 사용자 상호 작용 없이 방대한 양의 정보를 자동으로 처리합니다.</p><p>Batch 처리는 매일 수십억건의 트랜잭션을 처리하는 데 사용됩니다. 스프링 배치는 매일 기업 시스템의 일상적인 작업에 필수적인 견고한 배치 애플리케이션을 개발할 수 있도록 설계된 경량의 포괄적인 배치 프레임워크입니다.</p><p>스케줄러를 교체하지 않고 스케줄러와 함께 작동하도록 설계되어있고, Spring Batch는 로깅, 추적, 트랜잭션 관리, 작업 처리 통계, 작업 재시작, 건너 뛰기 및 자원 관리를 포함하여 많은 양의 레코드를 처리하는 데 필수적인 재사용 가능한 기능을 제공합니다.</p><p>복잡하고 대량의 대량 배치 작업은 매우 확장 가능한 방식으로 프레임워크를 활용하여 상당한 양의 정보를 처리할 수 있습니다.</p><p>Spring batch 는 이미 컨설팅 회사인 엑센츄어(Accenture)의 참여로 2008 년도쯤에 35개의 회사에서 안정적으로 쓰고 있다고 발표가 나서 안정성은 이미 보장되는 상황입니다.</p><p>~~~. Spring Batch already is in use at more than 35 Accenture clients</p><p><a href="https://www.cnet.com/news/accenture-springsource-team-up-but-heres-the-real-news/" target="_blank" rel="noopener">https://www.cnet.com/news/accenture-springsource-team-up-but-heres-the-real-news/</a></p><p>1.3 Spring Batch Architecture</p><p>Spring Batch는 확장 성과 다양한 최종 사용자 그룹을 염두에두고 설계되었습니다. 아래의 그림은 확장성을 지원하고 개발자가 쉽개 사용가능한 다층 아키텍처의 개요를 보여 줍니다.</p><p><img src="https://ahea.files.wordpress.com/2017/02/batch.png" alt="batch"></p><p>이 아키텍처는 애플리케이션, 코어, 인프라 스트럭처 등 세가지 주요 구성 요소를 중점적으로 다룹니다.</p><p>애플리케이션에는 Spring Batch를 사용하는 개발자가 작성한 custom 코드나 모든 batch 작업이 포함되어 있습니다.</p><p>Batch Core는 배치 작업을 시작하고 제어하는데 필요한 핵심 런타임 클래스를 포함합니다.</p><p>여기에는 JobLauncher, Job, Step이 포함됩니다. 두 애플리케이션과 코어는 common infrastructure 위에 구축됩니다. 이러한 infrastructure 에는 common readers and writers 가 포함되어 있으며, 애플리케이션 개발자와 코어 프레임워크 모두에서 사용되는 RetryTemplate와 같은 서비스를 제공합니다.</p><p>참고 : <a href="http://docs.spring.io/spring-batch/reference/html/" target="_blank" rel="noopener">http://docs.spring.io/spring-batch/reference/html/</a></p>]]></content>
      
      
      <categories>
          
          <category> spring batch </category>
          
      </categories>
      
      
    </entry>
    
    <entry>
      <title>Reactive History</title>
      <link href="/2017/02/03/reactive-history/"/>
      <url>/2017/02/03/reactive-history/</url>
      
        <content type="html"><![CDATA[<p>Reactive 글 모음</p><ol><li><a href="https://ahea.wordpress.com/2017/02/02/iterable%ec%99%80-observable%ec%9d%98-%ea%b0%9c%eb%85%90/" target="_blank" rel="noopener">Iterable와 Observable의 개념</a></li><li><a href="https://ahea.wordpress.com/2017/02/03/reactive-history/" target="_blank" rel="noopener">Reactive History</a></li><li><a href="https://ahea.wordpress.com/2017/02/13/reactive-streams/" target="_blank" rel="noopener">Reactive Streams</a></li><li><a href="https://ahea.wordpress.com/2017/02/13/rxjava/" target="_blank" rel="noopener">RxJava</a></li><li><a href="https://ahea.wordpress.com/2017/02/15/spring-reactive/" target="_blank" rel="noopener">Spring Reactive</a></li><li><a href="https://ahea.wordpress.com/2017/02/20/reactive-publishon-subscribeon/" target="_blank" rel="noopener">Reactive PublishOn, SubscribeOn</a></li></ol><hr><h2 id="volta-project와-ReactiveX"><a href="#volta-project와-ReactiveX" class="headerlink" title="volta project와 ReactiveX"></a>volta project와 ReactiveX</h2><p><img src="https://ahea.files.wordpress.com/2017/02/voltal-and-reactivex.png" alt="voltal-and-reactivex"></p><p>이것은 volta와 reactiveX의 로고입니다.</p><p>비슷함을 넘어서서 똑같죠</p><p>해당 이유는 msdn포럼에서 Erik Meijer가 리플로 대답을 했습니다</p><p>“It is brought to you by the same team.”</p><h6 id="https-social-msdn-microsoft-com-Forums-en-US-c48eb793-30ba-4be1-a5b7-46d6efd815f5-volta-logo-vs-rx-logo-forum-rx"><a href="#https-social-msdn-microsoft-com-Forums-en-US-c48eb793-30ba-4be1-a5b7-46d6efd815f5-volta-logo-vs-rx-logo-forum-rx" class="headerlink" title="https://social.msdn.microsoft.com/Forums/en-US/c48eb793-30ba-4be1-a5b7-46d6efd815f5/volta-logo-vs-rx-logo?forum=rx"></a><a href="https://social.msdn.microsoft.com/Forums/en-US/c48eb793-30ba-4be1-a5b7-46d6efd815f5/volta-logo-vs-rx-logo?forum=rx" target="_blank" rel="noopener">https://social.msdn.microsoft.com/Forums/en-US/c48eb793-30ba-4be1-a5b7-46d6efd815f5/volta-logo-vs-rx-logo?forum=rx</a></h6><h6 id="https-channel9-msdn-com-blogs-charles-getting-started-with-rx-extensions-for-net"><a href="#https-channel9-msdn-com-blogs-charles-getting-started-with-rx-extensions-for-net" class="headerlink" title="https://channel9.msdn.com/blogs/charles/getting-started-with-rx-extensions-for-net"></a><a href="https://channel9.msdn.com/blogs/charles/getting-started-with-rx-extensions-for-net" target="_blank" rel="noopener">https://channel9.msdn.com/blogs/charles/getting-started-with-rx-extensions-for-net</a></h6><h2 id="what-is-volta"><a href="#what-is-volta" class="headerlink" title="what is volta"></a>what is volta</h2><p>volta는 ms의 제품연구 부문인 ms live labs에서 생긴 프로젝트이며 애플리케이션의 각 구성요소를 네트워크 내에서 분배하는 것을 지원할 목적으로 설계된 개발 툴입니다</p><p>개발자는 보통 비동기/동기 상태에서 어떤식으로 개발해야 최고의 포퍼먼스가 날지 고민하게 되는데 이런 부분을 쉽게 해결하기 위해 volta가 진행되었습니다.</p><p>alex daiey는 ‘비주얼 스튜디오 2008’의 애드인 소프트웨어이며 개발자는 클라이언트 측의 코드를 쓰고, 다음에 어느 코드를 어디서 실행시킬지 주석으로 지정할 수 있다고 설명하고 있습니다</p><h6 id="http-www-zdnet-com-article-microsoft-architect-compares-volta-and-googles-gwt"><a href="#http-www-zdnet-com-article-microsoft-architect-compares-volta-and-googles-gwt" class="headerlink" title="http://www.zdnet.com/article/microsoft-architect-compares-volta-and-googles-gwt/"></a><a href="http://www.zdnet.com/article/microsoft-architect-compares-volta-and-googles-gwt/" target="_blank" rel="noopener">http://www.zdnet.com/article/microsoft-architect-compares-volta-and-googles-gwt/</a></h6><p>volta와 많이 거론되는 것이 gwt(google web toolkit)인데 java를 javascript로 변환시키는 gwt에 비해, volta는 조금더 넓게 닷넷 프레임워크에 적용시킬 계획이였으나 불행하게도 volta는 중단됬습니다</p><h2 id="volta에서-Reactive-Extensions로"><a href="#volta에서-Reactive-Extensions로" class="headerlink" title="volta에서 Reactive Extensions로"></a>volta에서 Reactive Extensions로</h2><p>volta의 일부였던 지금은 reactive framework는 2009년 reactive extensions로 이름을 바꾸고 공식 릴리즈 됩니다</p><ul><li>Reactive Extensions For .NET 3.5 Sp1</li><li>Reactive Extensions For .NET 4 beta 2</li><li>Rx for Silverlight3</li></ul><p>reactive extensions라는 이름에 관한것은</p><h6 id="https-channel9-msdn-com-Shows-Going-Deep-E2E-Erik-Meijer-and-Wes-Dyer-Reactive-Framework-Rx-Under-the-Hood-1-of-2"><a href="#https-channel9-msdn-com-Shows-Going-Deep-E2E-Erik-Meijer-and-Wes-Dyer-Reactive-Framework-Rx-Under-the-Hood-1-of-2" class="headerlink" title="https://channel9.msdn.com/Shows/Going+Deep/E2E-Erik-Meijer-and-Wes-Dyer-Reactive-Framework-Rx-Under-the-Hood-1-of-2"></a><a href="https://channel9.msdn.com/Shows/Going+Deep/E2E-Erik-Meijer-and-Wes-Dyer-Reactive-Framework-Rx-Under-the-Hood-1-of-2" target="_blank" rel="noopener">https://channel9.msdn.com/Shows/Going+Deep/E2E-Erik-Meijer-and-Wes-Dyer-Reactive-Framework-Rx-Under-the-Hood-1-of-2</a></h6><p>에서 확인할수 있습니다</p><p>Reactive Extensions는 처음에는 오픈소스가 아니였으나 2012년 Eric Meijer는 rx.net rx.js, rx++ 를 오픈소스로 공개하게 됩니다</p><h6 id="http-www-hanselman-com-blog-ReactiveExtensionsRxIsNowOpenSource-aspx"><a href="#http-www-hanselman-com-blog-ReactiveExtensionsRxIsNowOpenSource-aspx" class="headerlink" title="http://www.hanselman.com/blog/ReactiveExtensionsRxIsNowOpenSource.aspx"></a><a href="http://www.hanselman.com/blog/ReactiveExtensionsRxIsNowOpenSource.aspx" target="_blank" rel="noopener">http://www.hanselman.com/blog/ReactiveExtensionsRxIsNowOpenSource.aspx</a></h6><h2 id="RxJava와-Netflix"><a href="#RxJava와-Netflix" class="headerlink" title="RxJava와 Netflix"></a>RxJava와 Netflix</h2><p>Netflix의  TV User Interface 팀 개발자인 Jafar Husain은 rest service를 옵티마이징 하기 위해 아키텍쳐를 재설계 해야 한다고 생각했습니다</p><p>Netflix는 2012년 기준 북미의 인터넷 트래픽의 33%를 차지 할정도로 (당시 유튜브의 트래픽은 15%로 조사가 되었다) 엄청난 양의 데이터 처리를 요구받고 있었으며 Netflix는 엄청난 양의 네트워크의 포퍼먼스 문제를 해결하기 위한 옵티마이징 포인트를 Network Latency로 잡았습니다</p><p>넷플릭스는 사용자경험을 위해 api를 세분화 시키고 여러번 call이 들어오도록 설계되었습니다. 이안에서 network latency가 여러번 발생되여 지연되는 현상을 알게 되었습니다<img src="https://ahea.files.wordpress.com/2017/02/request-multi_1252.png" alt="request-multi_1252"></p><p>이런 문제를 해결하기 위해서는 네트워크 요청 단일화시켜서 축소시키는 것입니다. 즉 WAN의 대기시간을 줄이는 대신 처리가 빠른 강력한 하드웨어를 가진 서버를 둬서 이 문제를 해결하는 것입니다.</p><p><img src="https://ahea.files.wordpress.com/2017/02/request-single_1252.png" alt="request-single_1252"></p><p>이때 고려했던 키포인트 중 하나가 Reactive programming model이였습니다.</p><p>동시성(concurrency)을 가져가면서 스레드의 안정성과 병렬처리를 개발하는것은 매우 복잡한 일이였습니다. 그래서 이부분을 추상화시킬 프레임워크가 필요했습니다.</p><p>특히 기존 클라이언트 코드를 만지지 않으면서 java API를 통해 비동기 처리가 되도록 만들어야 했습니다. 그래서 이부분을 비동기 콜백으로 처리하기 위한 함수형 프로그래밍을 사용하는 반응형 모델을 선택하게 되었습니다. 이부분을 Rx Observable 모델로 가게 된것입니다.</p><p>그래서 Jafar Husain은 jvm환경에서 ReactiveExtensions 모델이 동작되는 Java버전을 개발하게 되었으며 이것이 rxJava가 되었습니다</p><h2 id="개발-패러다임의-변화와-맞물린-Reactive-Extensions"><a href="#개발-패러다임의-변화와-맞물린-Reactive-Extensions" class="headerlink" title="개발 패러다임의 변화와 맞물린 Reactive Extensions"></a>개발 패러다임의 변화와 맞물린 Reactive Extensions</h2><p>넷플릭스의 Reactive모델 적용은 단순히 포퍼먼스의 옵티마이징이 아니였다. Microservice architecture의 도입으로 비동기 통신에 기반하게 되었으며 이를 아주 쉽게 개발할수 있는 Reactive Programming 그중에서 대표적인 ReactiveExtensions가 주목받게 되었습니다.</p><p>웹 클라이언트에도 큰 변화가 있다. 그중에서도 javascript가 역동적으로 변하고 있다. 단순 돔을 제어하고 이벤트를 처리하는 언어였지만, 이제는 컴포넌트화 되고 다양한 프레임워크들이 쏟아져 나오고 있습니다. 서버의 변화로 클라이언트도 비동기처리에 대한 필요를 느끼고 reactiveExtensions의 rxJs가 많이 사용되고 있습니다. 최근 angular2에서도 react개 채택된것을 확인해본다면 이러한 패러다임의 변화가 아주 빠르게 바뀌고 있음을 알수 있습니다.</p><p>클라이언트 변화는 모바일에서도 마찬가지 입니다. SoundColud의 Matthias Käppler는 android에 reactiveExtensions를 적용한 rxAndroid를 내놓았으며 최근 rxSwift까지 나오면서 rxExtensions가 아주 빠르게 적용되고 바뀌어 나가고 있음을 알고 있습니다</p><h2 id="Reactive-and-Java-Future"><a href="#Reactive-and-Java-Future" class="headerlink" title="Reactive and Java Future"></a>Reactive and Java Future</h2><p>java의 reactive의 표준을 만들기 위해 Typesafe, Red Hat, Netflix, Pivotal, Oracle, Twitter, spray.io들이 모여 스펙을 정의하였습니다. 정확하게는 reactive stream에 대한 표준을 정의한것이며, Oracle은 이를 바탕으로 java9에서 해당 스펙이 어느정도 구현된 reactive stream이 탑재된다고 발표했습니다.</p><h6 id="http-www-reactive-streams-org"><a href="#http-www-reactive-streams-org" class="headerlink" title="http://www.reactive-streams.org/"></a><a href="http://www.reactive-streams.org/" target="_blank" rel="noopener">http://www.reactive-streams.org/</a></h6><p>이와 맞물려 spring.io에서는 spring 5.x에서 reactive programming을 지원한다고 하는데요. java시장에서 큰 점유율을 가진 spring framework가 아주 빠르게 대응함에 따라 비동기 프로그래밍의 장점을 가졌던 node.js나 다른 언어들과 치열한 전쟁은 계속될거 같습니다. 하지만 기존 개발자들이 이러한 패러다임에 빠르게 변화할수 있는지는 아직 미지수입니다.</p>]]></content>
      
      
      
        <tags>
            
            <tag> reactive </tag>
            
            <tag> reactive extensions </tag>
            
            <tag> reactiveX </tag>
            
            <tag> rx </tag>
            
            <tag> volta </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>Iterable와 Observable의 개념</title>
      <link href="/2017/02/02/iterable-ec-99-80-observable-ec-9d-98-ea-b0-9c-eb-85-90/"/>
      <url>/2017/02/02/iterable-ec-99-80-observable-ec-9d-98-ea-b0-9c-eb-85-90/</url>
      
        <content type="html"><![CDATA[<p>Reactive 글 모음</p><ol><li><a href="https://ahea.wordpress.com/2017/02/02/iterable%ec%99%80-observable%ec%9d%98-%ea%b0%9c%eb%85%90/" target="_blank" rel="noopener">Iterable와 Observable의 개념</a></li><li><a href="https://ahea.wordpress.com/2017/02/03/reactive-history/" target="_blank" rel="noopener">Reactive History</a></li><li><a href="https://ahea.wordpress.com/2017/02/13/reactive-streams/" target="_blank" rel="noopener">Reactive Streams</a></li><li><a href="https://ahea.wordpress.com/2017/02/13/rxjava/" target="_blank" rel="noopener">RxJava</a></li><li><a href="https://ahea.wordpress.com/2017/02/15/spring-reactive/" target="_blank" rel="noopener">Spring Reactive</a></li><li><a href="https://ahea.wordpress.com/2017/02/20/reactive-publishon-subscribeon/" target="_blank" rel="noopener">Reactive PublishOn, SubscribeOn</a></li></ol><hr><p>java에서는 데이터의 연속적인 자료구조를 표현할때 List(Collection)를 사용합니다.</p><p><img src="https://ahea.files.wordpress.com/2017/02/134_fix5844lwm.png" alt=""></p><p>그리고 이런 반복적인 데이터를 꺼내오기 위해 for-each문을 자주 사용하고 있습니다</p><p><img src="https://ahea.files.wordpress.com/2017/02/134_jabiyhlyuh.png" alt=""></p><p>이것이 가능한 이유는 List가 Iterable이라는 interface를 구현하고 있기 때문입니다</p><p><img src="https://ahea.files.wordpress.com/2017/02/134_qg5fbqurl5.png" alt=""></p><p>인텔리제이를 통해 Iterable을 열어봤습니다</p><p><img src="https://ahea.files.wordpress.com/2017/02/134_ivksqohpoo.png" alt=""></p><p>34-35 라인을 보면 흥미롭게 이 인터페이스를 구현하면 for-each loop문에 사용할수 있다고 합니다.</p><p>51 라인을 보면 Iterator라는것이 있어 이것을 이용하여 데이터를 꺼내올수 있습니다</p><p>Iterator는 다음과 같은 메소드가 정의되어 있는데</p><p><img src="https://ahea.files.wordpress.com/2017/02/134_nd8zjqjutt.png" alt=""></p><p>이중 핵심은 hasNext()를 통해 가져올 값이 있는지 체크하고 next()를 통해 가져오는 메소드입니다</p><p>이 내용들을 토대로 위에  dataArr를 List타입에서 Iterable타입으로 바꾸고 for-each문을 Iterator를 통해 돌리는 코드를 작성한다면 다음과 같이 되겠습니다</p><p><img src="https://ahea.files.wordpress.com/2017/02/134_tjpnfeibp7.png" alt=""></p><p><strong><em>정리. Iterable은 Iterator를 통해 데이터를 꺼내오고, Iterator의 next()를 통해 데이터를 가져온다</em></strong></p><hr><p>이번에는 Observable을 살펴봅시다</p><p>자바에서 Observable을 다음과 같이 정의해주고 있습니다</p><p><img src="https://ahea.files.wordpress.com/2017/02/134_ndq2yvp7ua.png" alt=""></p><p>영어가 짧아 멋들어진 해석은 안되지만 중간에 키워드를 보면 모델-뷰 패러다임이라는 것도 보이고요, Observable은 하나 또는 여러개의 Observer를 가진다고 하네요, Observable은 notifyObservers메소드를 호출함으로 변화를 Observer들에게 알려준다고 합니다</p><p>이정도만 알고 코드를 작성해봅시다</p><p>우리는 Observable을 상속받은 클래스를 하나 만듭니다</p><p><img src="https://ahea.files.wordpress.com/2017/02/134_ojkvegg9tk.png" alt=""></p><p>우리가 만든 Observable은 say라는 메소드를 가지며 say가 호출될경우 setChanged()를 통해 변화를 알려주고 notifyObservers()를 통해 등록된 Observer들에게 데이터를 날려줍니다</p><p>실제로 확인할수 있도록 우리가 만든 Observable에 Observer들을 등록해봅시다</p><p><img src="https://ahea.files.wordpress.com/2017/02/134_g_clco7re_.png" alt=""></p><p>Observer1을 만들어서 addObserver를 통해 등록하고 우리가 만든 Observable에 만든 say()를 호출합니다</p><p>실행결과를 보면</p><p><img src="https://ahea.files.wordpress.com/2017/02/134_f2cdjsbayp.png" alt=""></p><p>가 나옵니다</p><p>실행과정을 다시한번 살펴 보면</p><p>say()가 호출되었을 때 notifyObservers()를 통해 미리 등록된 Observer들에게 값을 전달합니다</p><p><strong><em>정리 Observable은 등록된 Observer들에게 notifyObservers()를 통해 데이터를 보낸다.</em></strong></p><p>두가지 방식 모두 같은 기능을 하고 있습니다</p><p>하지만 처리과정에서 차이를 보이고 있습니다</p><p>event</p><p>Iterable(pull)</p><p>Observable(push)</p><p>retrieve data</p><p>Tnext( void )</p><p>voidnotifyObservers( T )</p><p>complete check</p><p>hasNext</p><p>setChanged</p><p>이 표에서 주목할점은 Iterable은 pull, Observable은 push라고 정리되어 있습니다.</p><p>pull방식은 데이터를 땡겨오는것이죠, Iterator.next()를 하면 데이터를 리턴받는 부분을 pull방식으로 봅니다.</p><p>반대로 push방식은 데이터를 던져주죠, notifyObservers()에 데이터를 파라미터로 줌으로서 등록된 옵저버들에게 데이터를 push합니다.</p><p>Iterable &lt; — &gt; Observable</p><p>Pull &lt; — &gt; Push</p><p>두개의 차이점을 이해하셨나요?</p><p>차이가 분명 있으면서도 같은 기능을 하고 있습니다. 이부분을 duality라고 부릅니다.</p><p>duality란</p><p><strong>A와 B가 있을 때 A에서 성립하는 정리를 뒤집어서 B에도 적용할 수 있는 경우</strong>를 말한다. 한 마디로 A와 B의 본질이 같다는 뜻이다.</p><p>(by <a href="http://huns.me/development/2051" target="_blank" rel="noopener">http://huns.me/development/2051</a>)</p><p>duality라는 단어를 설명하기 참 어렵군요..</p><p>여튼 이중 Observable은 ReactiveX의 개념에서 가장 기초가 되는 개념입니다.</p><p>이번 포스팅에서는 Iterable과 Observable을 비교하며 배웠습니다</p><p>-추가-</p><p>코드를 java8에 맞게 다이어트 시킵시다</p><p><img src="https://ahea.files.wordpress.com/2017/02/134_lmegcbiqbt.png" alt=""></p><p>이 코드를 다음과 같이 한줄로 하면 더 깔끔하겠군요</p><p><img src="https://ahea.files.wordpress.com/2017/02/134_bh_ylzbinn.png" alt=""></p><p>-전체코드-</p><p>IteratorMain.java</p><p>importjava.util.Arrays; import java.util.Iterator;</p><p>publicclassIterableMain { publicstaticvoidmain(String[] args) { Iterable dataArr = Arrays.asList(1,2,3,4); for(Iterator it = dataArr.iterator();it.hasNext();) { System.out.println(it.next()); } } }</p><p>ObservableMain.java</p><p>importjava.util.Arrays; importjava.util.List; importjava.util.Observable; import java.util.Observer;</p><p>publicclassObservableMain { publicstaticvoidmain(String[] args) { Observable1 observable = new Observable1(); Observer observer1 = (o,data) -&gt; System.out.println(data); observable.addObserver(observer1); observable.say(); } } classObservable1extendsObservable { publicvoidsay() { List dataArr = Arrays.asList(1,2,3,4,5); for(Object i : dataArr) { setChanged(); notifyObservers(i); } } }</p>]]></content>
      
      
      
        <tags>
            
            <tag> java </tag>
            
            <tag> design pattern </tag>
            
            <tag> pattern </tag>
            
            <tag> reactive </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>오픈 그래프 프로토콜(Open Graph protocol)</title>
      <link href="/2017/01/22/ec-98-a4-ed-94-88-ea-b7-b8-eb-9e-98-ed-94-84-ed-94-84-eb-a1-9c-ed-86-a0-ec-bd-9copen-graph-protocol/"/>
      <url>/2017/01/22/ec-98-a4-ed-94-88-ea-b7-b8-eb-9e-98-ed-94-84-ed-94-84-eb-a1-9c-ed-86-a0-ec-bd-9copen-graph-protocol/</url>
      
        <content type="html"><![CDATA[<p>오픈 그래프 프로토콜은 페이스북에서 정의된 메타 태그 프로토콜 이라고 한다. 페이스북,트위터에서 링크 삽입시 해당사이트의 메타태그를 긁어와서 사이트정보를 미리 보여주는 정도의 용도로 생각하면 될거 같습니다. <strong>적용 예)</strong></p><p><meta property="og:title" content="The Rock">  <meta property="og:type" content="video.movie">  <meta property="og:url" content="http://www.imdb.com/title/tt0117500/">  <meta property="og:image" content="http://ia.media-imdb.com/images/rock.jpg"></p><h2 id="오픈-그래프-프로토콜-예시"><a href="#오픈-그래프-프로토콜-예시" class="headerlink" title="오픈 그래프 프로토콜 예시)"></a><strong>오픈 그래프 프로토콜 예시)</strong></h2><p>예시 링크 : <a href="https://www.youtube.com/watch?v=B2z5C_Mesx0" target="_blank" rel="noopener">https://www.youtube.com/watch?v=B2z5C_Mesx0</a>   <strong>트위터 예)</strong> <img src="https://ahea.files.wordpress.com/2017/01/201604241514340.png" alt="201604241514340"> <strong>페이스북 예)</strong> <img src="https://ahea.files.wordpress.com/2017/01/201604241515580.png" alt="201604241515580"> <strong>카카오톡 예)</strong> <img src="https://ahea.files.wordpress.com/2017/01/kakaolink.png" alt="kakaolink.png"> 위의 정보를 어떻게 가져와서 보여주는지 알아 보겠습니다.</p><h2 id="오픈-그래프-프로토콜을-사용해-보자"><a href="#오픈-그래프-프로토콜을-사용해-보자" class="headerlink" title="오픈 그래프 프로토콜을 사용해 보자."></a><strong>오픈 그래프 프로토콜을 사용해 보자.</strong></h2><p><a href="http://ogp.me/" target="_blank" rel="noopener">http://ogp.me/</a> 사이트를 방문 하면 <a href="http://ogp.me/#implementations" target="_blank" rel="noopener">Implementations</a> 메뉴에 디버깅 툴 및 플러그인 등 각종 링크가 있습니다. 여기서</p><ul><li><a href="http://developers.facebook.com/tools/debug/" target="_blank" rel="noopener">Facebook Object Debugger</a> - Facebook’s official parser and debugger</li></ul><p>에 대해 알아보고 어떻게 적용할지 알아 보겠습니다. <a href="http://developers.facebook.com/tools/debug/" target="_blank" rel="noopener">Facebook Object Debugger</a> - Facebook’s official parser and debugger는 페이스북에서 제공하는 오픈 그래프 프로토콜이 어떤건지 알수 있는 디버깅 툴 입니다. 해당페이지에 접속하여서 url을 넣고 Debug버튼 페이스북의 링크 공유시 어떻게 나올지 나타내게 됩니다. <a href="http://developers.facebook.com/tools/debug/" target="_blank" rel="noopener">Facebook Object Debugger</a> 예) <img src="https://ahea.files.wordpress.com/2017/01/developers_facebook_com_20160424_153500.png" alt="developers_facebook_com_20160424_153500.png"> 간단한 정보만 필요함으로 직접 작성하였습니다.</p><pre><code>  Document doc;  String url = &quot;https://www.youtube.com/watch?v=B2z5C_Mesx0&quot;;  Map&lt;String, List&lt;String&gt;\&gt; result = new HashMap&lt;String,List&lt;String&gt;&gt;();    try {             doc = Jsoup.connect(url).get();             Elements ogElements = doc.select(&quot;meta\[property^=og\], meta\[name^=og\]&quot;);  for (Element e : ogElements) {  String target=target = e.hasAttr(&quot;property&quot;) ? &quot;property&quot;:&quot;name&quot;;    if(!result.containsKey(e.attr(target))){  result.put(e.attr(target), new ArrayList&lt;String&gt;());                 }                 result.get(e.attr(target)).add(e.attr(&quot;content&quot;));             }    for(String s : result.keySet())  System.out.println(s + &quot; : &quot; \+ result.get(s));    } catch (Exception e){             e.printStackTrace();         }</code></pre><h2 id="실행결과"><a href="#실행결과" class="headerlink" title="실행결과"></a><strong>실행결과</strong></h2><p>og:image : [<a href="https://i.ytimg.com/vi/B2z5C_Mesx0/hqdefault.jpg\]" target="_blank" rel="noopener">https://i.ytimg.com/vi/B2z5C_Mesx0/hqdefault.jpg\]</a>  og:type : [video]  og:site_name : [YouTube]  og:title : [SNL코리아7 - 인스턴트 LOVE “3분 남친” by 에릭남, 정이랑 (2016.04.16)]  og:video:type : [text/html, application/x-shockwave-flash]  og:video:height : [720, 720]  og:video:url : [<a href="https://www.youtube.com/embed/B2z5C\_Mesx0" target="_blank" rel="noopener">https://www.youtube.com/embed/B2z5C\_Mesx0</a>, <a href="http://www.youtube.com/v/B2z5C\_Mesx0?version=3&amp;autohide=1\]" target="_blank" rel="noopener">http://www.youtube.com/v/B2z5C\_Mesx0?version=3&amp;autohide=1\]</a>  og:url : [<a href="https://www.youtube.com/watch?v=B2z5C_Mesx0\]" target="_blank" rel="noopener">https://www.youtube.com/watch?v=B2z5C_Mesx0\]</a>  og:video:secure_url : [<a href="https://www.youtube.com/embed/B2z5C\_Mesx0" target="_blank" rel="noopener">https://www.youtube.com/embed/B2z5C\_Mesx0</a>, <a href="https://www.youtube.com/v/B2z5C\_Mesx0?version=3&amp;autohide=1\]" target="_blank" rel="noopener">https://www.youtube.com/v/B2z5C\_Mesx0?version=3&amp;autohide=1\]</a>  og:video:tag : [SNL코리아7, 인스턴트 LOVE 3분 남친, 에릭남, 정이랑, 2016.04.16]  og:description : [SNL코리아7 - 인스턴트 LOVE “3분 남친” by 에릭남, 정이랑 (2016.04.16) #일부 국가 차단으로 다시 업로드 했습니다 ^^]  og:video:width : [1280, 1280]</p><p>  추가로 자바스크립트 적용 소스도 올리겠습니다. 유튜브 비디오 처리랑 일반 웹사이트만 추가했습니다.</p><p>this.ajaxUrlConnet = function (data) {         $.ajax({  url: ‘/tbbswrite/opengraph’,  method: “GET”,  async: false,  cache: false,  contentType: true,  processData: true,  data: {‘url’: data}         }).done(function(c) {  $.each(c, function(key,value){  console.log(key + ‘ : ‘ + value);             })  var html=’’;  if(‘video’.indexOf(c[‘og:type’][0]) &gt;= 0){                 html+=’<pre style="width: 300px;overflow: hidden;" onclick="location.href=\\''+c\['og:url'\]\[0\]+'\\'">‘;  if( !(c[‘og:video:secure_url’][0] === undefined)){                     html+=’+c[‘og:video:secure_url’][0]+’”&gt;’;                 }                 html+=’<h1><b>‘+c[‘og:title’][0]+’</b></h1>‘;  if( !(c[‘og:description’] === undefined)){                     html+=’<p>‘+c[‘og:description’]+’</p>‘;                 }                 html+=’<p><a href="'+c\['og:url'\]\[0\]+'">‘+c[‘og:url’][0]+’</a></p>‘;                 html+=’</pre>‘;                 context.invoke(‘editor.pasteHTML’, html);  } else {                 html+=’<pre style="width: 300px;overflow: hidden;" onclick="location.href=\\''+c\['og:url'\]\[0\]+'\\'">‘;  if( !(c[‘og:image’][0] === undefined)){                     html+=’<img src="'+c\['og:image'\]\[0\]+'" style="width: 100%;height: 100%;">‘;                 }                 html+=’<p></p><h1><b>‘+c[‘og:title’][0]+’</b></h1></pre></p>‘;  if( !(c[‘og:description’] === undefined)){                     html+=’<p>‘+c[‘og:description’]+’</p>‘;                 }                 html+=’<p><a href="'+c\['og:url'\]\[0\]+'">‘+c[‘og:url’][0]+’</a></p>‘;                 html+=’‘;                 context.invoke(‘editor.pasteHTML’, html);             }         }).fail(function() {             alert(‘error = ‘ + data);         });  }<p></p><p>  해당 프로젝트는 github에 올려놓았습니다. 문제점이 있거나 잘못된 코딩습관이 있으면 코멘트 부탁드리겠습니다^^ github : <a href="https://github.com/kji6252/JsoupOpenGrahpTest" target="_blank" rel="noopener">https://github.com/kji6252/JsoupOpenGrahpTest</a></p>]]></content>
      
      
      <categories>
          
          <category> 미분류 </category>
          
      </categories>
      
      
    </entry>
    
    <entry>
      <title>Devops 발표자료</title>
      <link href="/2017/01/19/devops-eb-b0-9c-ed-91-9c-ec-9e-90-eb-a3-8c/"/>
      <url>/2017/01/19/devops-eb-b0-9c-ed-91-9c-ec-9e-90-eb-a3-8c/</url>
      
        <content type="html"><![CDATA[<p>[slideshare id=71168083&amp;doc=devopsupload-170119025732]   devops 발표자료입니다 발표자 정해균</p>]]></content>
      
      
      <categories>
          
          <category> 미분류 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> devops </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>spring boot swagger 적용기</title>
      <link href="/2017/01/18/spring-boot-swagger-ec-a0-81-ec-9a-a9-ea-b8-b0/"/>
      <url>/2017/01/18/spring-boot-swagger-ec-a0-81-ec-9a-a9-ea-b8-b0/</url>
      
        <content type="html"><![CDATA[<p>spring boot 프로젝트에 swagger를 적용했습니다</p><p>rest api를 문서화 하기 위해 어떤걸 쓸지 고민하는 중 swagger를 써보기로 했습니다</p><p>문서화에 있어 필수적으로 고민한것들이 있습니다</p><ol><li>문서화가 자동으로 되어야 한다</li><li>description을 잘 넣을 수 있어야 한다</li><li>빨리 설치하고 필요없으면 삭제를 빠르게</li></ol><p>1번이 무조건 핵심인데 찾던것들중 어떤건 junit테스트를 해야 만들어지고(우린 왜 unit test를 안하나) 어떤건 node를 설치해야 했습니다.</p><p><img src="https://ahea.files.wordpress.com/2017/01/43_hxf5mftuj6.png" alt="스크린샷 2016-08-05 오전 10.53.06.png"></p><dependency><br><br>        <groupid>io.springfox</groupid><br><br>        <artifactid>springfox-swagger-ui</artifactid><br><br>        <version>2.2.2</version><br><br>        </dependency><dependency><br><br>    <groupid>io.springfox</groupid><br><br>    <artifactid>springfox-swagger2</artifactid><br><br>    <version>2.2.2</version><br><br></dependency><p>swagger는 swagger-core와 swagger-ui로 나뉘어 있습니다</p><p>ui를 넣지 않으면 json으로만 데이터를 봐야 하기 때문에 swagger-ui를 넣으면 됩니다</p><p>swagger-ui는 webjar로 배포된다고 하네요</p><p>javaConfig로 swagger를 설정합니다</p><p> Docket을 빈으로 등록해야 합니다</p><p>우리는 특별히 basePackage를 넣어줬습니다 저것을 하지 않으면 spring에 있는 앵간한 mapping이 다 들어갑니다 예를 들면 oauth 인증 url이라던가 말이죠</p><p><img src="https://ahea.files.wordpress.com/2017/01/43_brlay-y_ih.png" alt="스크린샷 2016-08-05 오전 11.13.50.png"></p><p>@Configuration</p><p>@EnableSwagger2</p><p>@EnableAutoConfiguration</p><p>public class SwaggerConfig {</p><pre><code>        @Bean        public Docket swaggerSpringMvcPlugin() {                return new Docket(DocumentationType.SWAGGER_2)                      .select()                                                  .apis(RequestHandlerSelectors.basePackage(&quot;org.ahea.blindinterview&quot;))            .build();        }</code></pre><p>}</p><p>/swagger-ui.html 로 호출하면 결과를 확인할수 있습니다.</p><p>하지만 spring-security가 적용되어 있는 경우 시큐리티에 막혀 호출이 되지 않습니다</p><p>그런 경우 WebSecurityConfigurerAdapter를 이용하여 uri를 ignoring해줍니다</p><p><img src="https://ahea.files.wordpress.com/2017/01/43_xtpwaqywwd.png" alt="스크린샷 2016-08-05 오전 11.20.16.png"></p><p>@Configuration</p><p>@EnableWebMvc</p><p>public class MyWebSecurity extends WebSecurityConfigurerAdapter {</p><pre><code>    @Override    protected void configure(HttpSecurity http) throws Exception {            http.authorizeRequests()                            .antMatchers(HttpMethod.OPTIONS, &quot;/oauth/token&quot;).permitAll();    }    @Override    public void configure(WebSecurity web) throws Exception {            web.ignoring().antMatchers(&quot;/v2/api-docs&quot;, &quot;/configuration/ui&quot;,                            &quot;/swagger-resources&quot;, &quot;/configuration/security&quot;,                            &quot;/swagger-ui.html&quot;, &quot;/webjars/**&quot;,&quot;/swagger/**&quot;);    }</code></pre><p>}</p><p>설치는 끝났습니다</p><p>api doc을 만들어봅시다</p><p><img src="https://ahea.files.wordpress.com/2017/01/43_gqblfdmnxu.png" alt="스크린샷 2016-08-05 오전 11.25.09.png"></p><p>@ApiOperation(value = “헬로우 테스트”, httpMethod = “GET”, notes = “헬로우 테스트입니다”)</p><pre><code>    @ApiResponses(value = {        @ApiResponse(code = 400, message = &quot;Invalid input:...&quot;),        @ApiResponse(code = 200, message = &quot;Ok&quot; )        })      @RequestMapping(value=&quot;/hello&quot;, method=RequestMethod.POST )    public String hello(@ApiParam(value = &quot;키값&quot;, required = true, defaultValue = &quot;기본값&quot;) String value) {            return &quot;Blind Interview Server Running\\n&quot;;    }</code></pre><p>Requstmapping이 걸린 메소드에 저런것들을 넣을수 있습니다</p><p>자 만들어진 것을 보죠</p><p><img src="https://ahea.files.wordpress.com/2017/01/43_f0hngulaux.png" alt="스크린샷 2016-08-05 오전 11.31.23.png"></p><p>이전에 더 깔끔하고 좋은 문서화 도구가 있었는데 이름을 도저히 모르겠습니다. 그래도 이정도면 훌륭합니다. 오 웹에서 테스트도 할수 있군요 try it out 버튼이 있군요</p><p>눌러보면</p><p><img src="https://ahea.files.wordpress.com/2017/01/43_olyvgtrz8l.png" alt="스크린샷 2016-08-05 오전 11.34.57.png"></p><p>권한이 없다고 나오네요</p><p>이 상황은 spring security oauth때문에 일어나는 문제입니다</p><p>헤더에 token값을 넣어줘야 하지요</p><p>security oauth를 적용하지 않았다면 결과가 잘 나올껍니다</p><p>헤더값을 넣을수 있도록 해보겠습니다</p><p><img src="https://ahea.files.wordpress.com/2017/01/43_uvjaqeo6qj.png" alt="스크린샷 2016-08-05 오전 11.37.36.png"></p><p>@ApiImplicitParams({</p><pre><code>    @ApiImplicitParam(name = &quot;Authorization&quot;, value = &quot;authorization header&quot;, required = true,            dataType = &quot;string&quot;, paramType = &quot;header&quot;, defaultValue = &quot;bearer cbbb1a6e-8614-4a4d-a967-b0a42924e7ca&quot;)    })</code></pre><p>헤더에 토큰을 넣을수 있도록 했습니다</p><p>우선 토큰값은 강제로 넣어놨습니다</p><p>결과를 다시 보면</p><p><img src="https://ahea.files.wordpress.com/2017/01/43_0gqnafutg2.png" alt="스크린샷 2016-08-05 오전 11.59.03.png"></p><p>Authorization 헤더값을 넣을수 있게 되었습니다</p><p>토큰 스토어에서 토큰을 받아올순 있지만 어떻게 처리할지 고민중이네요 우선 토큰 직접 발급 받으셔서 하세요</p><p>정상적인 토큰을 넣어주고 결과를 확인하면</p><p><img src="https://ahea.files.wordpress.com/2017/01/43_dp2qirz-rn.png" alt="스크린샷 2016-08-05 오후 12.01.29.png"></p><p>ResponseBody에 결과가 잘 나오는 것을 확인 할수 있습니다</p><p>이정도면 괜찮지만 많이 아쉽습니다</p><ol><li>코드에 annotations으로 넣어야 하는 문제</li><li>oauth 처리 문제 (이거로 어제 밤샐뻔했네요)</li><li>깔끔한 UI 필요 (이정도면 훌륭하지만 분명 저는 전설속에 나오는 문서를 본적이 있습니다 더 좋은 문서화가 가능한데 말이죠….)</li></ol>]]></content>
      
      
      <categories>
          
          <category> 미분류 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> spring boot </tag>
            
            <tag> swagger </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>Spring OAuth 적용기</title>
      <link href="/2017/01/18/spring-oauth/"/>
      <url>/2017/01/18/spring-oauth/</url>
      
        <content type="html"><![CDATA[<p>우선 제가 테스트 하는 로컬 환경의 설정은 이렇습니다</p><p><img src="https://ahea.files.wordpress.com/2017/01/27_eg2m7vmx1y.png" alt="스크린샷 2016-08-04 오전 11.35.37.png"></p><p>서버 포트는 9090이고 contextpath는 api입니다</p><p>즉 <a href="http://localhost:9090/api로" target="_blank" rel="noopener">http://localhost:9090/api로</a> 주소가 시작됩니다</p><p>테스트를 위해 해당 주소로 mapping을 만들었습니다</p><p>정상적으로 실행된다면 “Blind Interview Server Running” 이라는 문구가 나오겠죠</p><p><img src="https://ahea.files.wordpress.com/2017/01/27_ipim7asqkb.png" alt="스크린샷 2016-08-04 오전 11.33.57.png"></p><p>브라우저로 실행시켜보겠습니다</p><p><img src="https://ahea.files.wordpress.com/2017/01/27_pf5bxtpcoz.png" alt="스크린샷 2016-08-04 오전 11.37.30.png"></p><p>시큐리티에서 에러가 뜨네요</p><p>지금부터 시큐리티에서 token을 발급받고 발급받은 토큰으로 실행시키는 법을 확인해보겠습니다</p><p>저는 curl로 테스트를 진행하겠습니다</p><p>우선 토큰을 발급받기 위한 환경을 보겠습니다</p><p><img src="https://ahea.files.wordpress.com/2017/01/27_jt2vn6dbgi.png" alt="스크린샷 2016-08-04 오전 11.39.31.png"></p><p>@EnableResourceServer와 @EnableAuthorizationServer 어노테이션을 넣었습니다</p><p>application.properties에서는 해당 설정을 넣었습니다</p><p><img src="https://ahea.files.wordpress.com/2017/01/27_fjifkfcfv4.png" alt="스크린샷 2016-08-04 오전 11.40.41.png"></p><p>해당 정보가 어떻게 사용되는지는 다음을 확인하면 될것 같습니다</p><p><img src="https://ahea.files.wordpress.com/2017/01/27_zf7wbmfc9r.png" alt="스크린샷 2016-08-04 오전 11.42.18.png"></p><p>아 제 해상도가 레티나라서 너무 좋아서 안보이네요</p><p><img src="https://ahea.files.wordpress.com/2017/01/27_qsjmla_paj.png" alt="스크린샷 2016-08-04 오전 11.45.09.png"></p><p>아 확대했는데도 안보이네요(레티나 짱짱맨)</p><p><img src="https://ahea.files.wordpress.com/2017/01/27_d54e64ngor.png" alt="스크린샷 2016-08-04 오전 11.45.53.png"></p><p>(잘보이는군요)</p><p>해당 명령을 날렸습니다</p><p>curl ahea_client_id:ahea_client_secrit@localhost:9090/api/oauth/token -d grant_type=password -d client_id=ahea_client_id -d scope=read -d username=ahea -d password=ahea123</p><p>보면</p><p>curl {security.oauth2.client.client-id}:{security.oauth2.client.client-secret}@주소/oauth/token -d grant_type=password -d client_id={security.oauth2.client.client-id} -d scope=read -d username={security.user.name} -d password={security.user.password}</p><p>로 날린것을 확인할 수 있습니다 ( {var}는 application.properties 키 값을 말하는겁니다}</p><p>결과를 보면</p><p>{“access_token”:”211622d1-f256-4d23-9f77-a35ed7632396”,”token_type”:”bearer”,”refresh_token”:”ae2bf389-782b-40a2-b2a0-10da4e90f252”,”expires_in”:42976,”scope”:”read”}</p><p>이렇게 json으로 떨궈줍니다</p><p>이중 access_token값을 이용하여 api를 호출합니다 (나머지도 인증을 위해 저장해야 하는 값이니 클라이언트가 저장하고 있어야 합니다)</p><p>토큰을 이용해 api를 호출해봅니다</p><p><img src="https://ahea.files.wordpress.com/2017/01/27_zixjnwiuql.png" alt="스크린샷 2016-08-04 오전 11.51.52.png"></p><p>curl -H “Authorization: Bearer 211622d1-f256-4d23-9f77-a35ed7632396” “<a href="http://localhost:9090/api/&quot;" target="_blank" rel="noopener">http://localhost:9090/api/&quot;</a></p><p>다음과 같이 curl명령어를 날렸습니다</p><p>규칙은 다음과 같겠죠</p><p>curl -H “Authorization: Bearer {request_token}” “{api url}”</p><p>결과를 보니 해당 api가 정상적으로 호출되었습니다</p><p>만약 curl 을 이용하여 token헤더 없이 날린다면 다음과 같은 결과가 나옵니다</p><p><img src="https://ahea.files.wordpress.com/2017/01/27_ebdsat6epb.png" alt="스크린샷 2016-08-04 오전 11.54.25.png"></p><p>{“error”:”unauthorized”,”error_description”:”Full authentication is required to access this resource”}</p>]]></content>
      
      
      <categories>
          
          <category> 미분류 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> spring </tag>
            
            <tag> oauth </tag>
            
            <tag> spring oauth </tag>
            
            <tag> spring security </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>maven 외부 jar 추가</title>
      <link href="/2017/01/11/maven-ec-99-b8-eb-b6-80-jar-ec-b6-94-ea-b0-80/"/>
      <url>/2017/01/11/maven-ec-99-b8-eb-b6-80-jar-ec-b6-94-ea-b0-80/</url>
      
        <content type="html"><![CDATA[<p>maven을 이용해서 개발하다보면 알아서 라이브러리를 관리해 줘서 편하지만 메이븐 중앙 리파지토리에서 포함 안된 외부 jar를 포함 시켜야 할때가 있다.</p><p>다른 회사들과 모듈연동이나 암호화할때 jar파일만 받아서  그 api를 호출하는</p><p>방식일때 사용된다.</p><p>그럼 외부에서 제공해주는 jar 파일을 메이븐 프로젝트에 추가 시켜줘야하고</p><p>회사의 사설 리파지토리가 있으면 그쪽에 jar를 넣어주고 dependency를 추가하면</p><p>별다른 설정없이 외부 jar를 사용가능하다.</p><p>그렇게 하지 못한다면 프로젝트내 특정디렉토리를 리파지토리로 잡고</p><p>그 안에 외부 jar를 넣으면 된다.</p><p>pom.xml에</p><pre><code>         in-project         custom jars         file://${project.basedir}/external</code></pre><p>이런식으로 선언해주면 project.basedir 경로를 리파지토리로 등록한다.</p><p>리파지토리 아래에 폴더명은 다음과 같은 컨밴션을 따른다.</p><p>/groupId/artifactId/version/artifactId-verion.jar</p><p>groupId = org.mockito</p><p>artifactId = mockito-all</p><p>version = 1.9.0</p><p>the library file =  mockito-all-1.9.0.jar</p><pre><code>org.mockitomockito-all1.9.0</code></pre><p><img src="http://cfile25.uf.tistory.com/image/2545A14457ABE6B606DC3A" alt=""></p><p>리파지토리가 잘 잡히고 경로가 컨벤션에 따라 잘 설정되었다면</p><p>메이븐이 프로젝트내 리파지토리를 잡아서 해당 jar파일을 dependency 해줄 수 있다.</p><p>단순 참조를 위해 다음과 같이 쓸 수 도 있는데</p><p> system</p><pre><code>${project.basedir}/custom.jar</code></pre><p> scope 의 system 이기 때문에 maven 빌드 시 해당 jar 파일이 포함되지 않는다.</p><p>system - system 스코프는 provided와 비슷하다. provide는 컴파일 시점에는 필요</p><p>하지만, 배포할 때 포함할 필요는없다. jar파일을 제공해야하고 스코프의 jar파일은</p><p>포함이 안될수도 있다.</p>]]></content>
      
      
      <categories>
          
          <category> maven </category>
          
      </categories>
      
      
    </entry>
    
  
  
</search>
